---
phase: 13-login-ui
plan: 03
type: execute
wave: 2
depends_on: ["13-01", "13-02"]
files_modified:
  - apps/web/src/features/auth/context/AuthContext.tsx
  - apps/web/src/features/auth/context/useAuth.ts
  - apps/web/src/features/auth/components/ProtectedRoute.tsx
  - apps/web/src/routes.tsx
  - apps/web/src/main.tsx
  - apps/web/src/app/App.tsx
autonomous: true

must_haves:
  truths:
    - "AuthProvider attempts silent token refresh on mount via /auth/refresh"
    - "useAuth() hook exposes user, login, logout, isAuthenticated, isLoading"
    - "login() calls /auth/token, fetches /auth/me, and stores user profile in context"
    - "logout() calls /auth/logout and clears in-memory token"
    - "ProtectedRoute redirects unauthenticated users to /login silently"
    - "isLoading state prevents flash of login page during auth check"
  artifacts:
    - path: "apps/web/src/features/auth/context/AuthContext.tsx"
      provides: "AuthProvider with token management and user profile"
      contains: "AuthProvider"
    - path: "apps/web/src/features/auth/context/useAuth.ts"
      provides: "useAuth hook for consuming auth context"
      contains: "useAuth"
    - path: "apps/web/src/features/auth/components/ProtectedRoute.tsx"
      provides: "Route guard that redirects unauthenticated users"
      contains: "ProtectedRoute"
  key_links:
    - from: "apps/web/src/features/auth/context/AuthContext.tsx"
      to: "apps/web/src/lib/api.ts"
      via: "imports api and setAccessToken"
      pattern: "setAccessToken"
    - from: "apps/web/src/features/auth/context/AuthContext.tsx"
      to: "/auth/refresh"
      via: "optimistic mount refresh"
      pattern: "/auth/refresh"
    - from: "apps/web/src/features/auth/context/AuthContext.tsx"
      to: "/auth/me"
      via: "pre-fetch user profile after token"
      pattern: "/auth/me"
---

<objective>
Create the AuthContext provider, useAuth hook, ProtectedRoute component, and wire up TanStack Router routing.

Purpose: AuthContext is the central auth state manager. It handles optimistic token refresh on page load, stores user profile, and provides login/logout methods. ProtectedRoute uses this context to guard authenticated pages. TanStack Router provides type-safe client-side routing for login/register/verify/dashboard pages. Phase 14 will add TanStack Query + advanced routing patterns (loaders, search param validation, data prefetching).

Output: Working auth context with optimistic refresh, protected route component, TanStack Router setup.
</objective>

<execution_context>
@/home/developer/.claude/get-shit-done/workflows/execute-plan.md
@/home/developer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@apps/web/src/lib/api.ts
@apps/web/src/features/auth/types.ts
@apps/web/src/main.tsx
@apps/web/src/app/App.tsx
@.planning/phases/13-login-ui/13-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AuthContext provider with optimistic refresh and useAuth hook</name>
  <files>
    apps/web/src/features/auth/context/AuthContext.tsx
    apps/web/src/features/auth/context/useAuth.ts
  </files>
  <action>
**Create `apps/web/src/features/auth/context/AuthContext.tsx`:**

This is the core auth state manager. Implementation requirements:

1. **State:** `user: UserProfile | null`, `isLoading: boolean` (starts true), module-level accessToken via `setAccessToken`/`getAccessToken` from `lib/api.ts`

2. **Optimistic mount refresh (useEffect):**
   - On mount, call `POST /auth/refresh` via the api instance
   - On success: call `setAccessToken(token)`, then `GET /auth/me` to fetch user profile, set user state
   - On failure: user stays null (not authenticated)
   - Always: set isLoading to false
   - Use AbortController for cleanup to prevent React StrictMode double-mount race condition (see RESEARCH.md Pitfall 6)

3. **login(email, password, rememberMe):**
   - Call `POST /auth/token` with form-encoded body: `username=email&password=password&remember_me=rememberMe`
   - The /auth/token endpoint uses OAuth2PasswordRequestForm so body must be `application/x-www-form-urlencoded`
   - Use `URLSearchParams` or `new FormData()` for the body, and set Content-Type header to `application/x-www-form-urlencoded`
   - On success: call `setAccessToken(response.data.access_token)`, then `GET /auth/me` to fetch user profile
   - On failure: throw error (caller handles display)
   - Return void on success

4. **logout():**
   - Call `POST /auth/logout` via api instance (clears cookie server-side)
   - Call `setAccessToken(null)` to clear in-memory token
   - Set user to null
   - Navigate to `/login` — use `window.location.href = '/login'` to avoid coupling AuthContext to TanStack Router. The full page reload also clears any stale state (router cache, component state).

   Design choice: Use `window.location.href = '/login'` for logout redirect. This is simpler than injecting TanStack Router's navigate and ensures a clean state reset.

5. **Context value:** `{ user, isAuthenticated: !!user, isLoading, login, logout }`

6. **Derived computed state:** `isAuthenticated` is `!!user` (not separate state)

**Create `apps/web/src/features/auth/context/useAuth.ts`:**
```typescript
import { useContext } from 'react';
import { AuthContext } from './AuthContext';

export function useAuth() {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
}
```

Important implementation details:
- The api instance already has `withCredentials: true` so cookies are sent automatically
- The api interceptor handles token refresh on 401 for regular API calls — AuthContext only handles the initial mount refresh and explicit login/logout
- The login body must be form-encoded (not JSON) because the backend uses OAuth2PasswordRequestForm
- Type the context with a proper interface, not `any`
  </action>
  <verify>
    `npx nx typecheck web` passes.
    Verify AuthContext.tsx exports AuthProvider and AuthContext.
    Verify useAuth.ts exports useAuth hook.
  </verify>
  <done>
    AuthProvider handles optimistic refresh on mount, provides login/logout methods, stores user profile from /auth/me. useAuth hook provides typed access to auth context. AbortController prevents StrictMode double-mount issues.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ProtectedRoute and set up TanStack Router routing</name>
  <files>
    apps/web/src/features/auth/components/ProtectedRoute.tsx
    apps/web/src/routes.tsx
    apps/web/src/main.tsx
    apps/web/src/app/App.tsx
  </files>
  <action>
**Create `apps/web/src/features/auth/components/ProtectedRoute.tsx`:**

```typescript
import { Outlet } from '@tanstack/react-router';
import { useAuth } from '../context/useAuth';

export function ProtectedRoute() {
  const { isAuthenticated, isLoading } = useAuth();

  if (isLoading) {
    // Neutral loading state while checking auth — prevents FOUC (Pitfall 1 from research)
    return (
      <div className="flex min-h-screen items-center justify-center bg-background">
        <div className="text-muted-foreground">Loading...</div>
      </div>
    );
  }

  if (!isAuthenticated) {
    // Silent redirect — no toast/message per user decision
    window.location.href = '/login';
    return null;
  }

  return <Outlet />;
}
```

Note: TanStack Router doesn't have a `<Navigate>` component like react-router-dom. For unauthenticated redirects from the ProtectedRoute layout, use `window.location.href` or TanStack Router's `useNavigate` + useEffect. The simplest approach for the auth guard is `useNavigate` in a useEffect, OR use `redirect()` in the route's `beforeLoad`. Choose the approach that's cleanest:

**Preferred: Use `beforeLoad` on the protected layout route for auth redirects:**
```typescript
// In route definition:
const protectedLayoutRoute = createRoute({
  getParentRoute: () => rootRoute,
  id: 'protected',
  component: ProtectedRoute,
  beforeLoad: ({ context }) => {
    // context.auth is injected via router context
    if (!context.auth.isLoading && !context.auth.isAuthenticated) {
      throw redirect({ to: '/login' });
    }
  },
});
```

This gives you type-safe redirects. The ProtectedRoute component only needs to handle the loading state — the auth check happens at the route level via `beforeLoad`. If auth is still loading, render the loading spinner; if authenticated, render `<Outlet />`.

**Create `apps/web/src/routes.tsx`:**

Define the route tree using TanStack Router's code-based routing:

```typescript
import { createRootRouteWithContext, createRoute, createRouter, redirect, Outlet } from '@tanstack/react-router';
import type { AuthContextType } from './features/auth/context/AuthContext';

// Root route with auth context injection
const rootRoute = createRootRouteWithContext<{ auth: AuthContextType }>()({
  component: () => <Outlet />,
});

// Public routes (no auth required)
const loginRoute = createRoute({
  getParentRoute: () => rootRoute,
  path: '/login',
  component: () => <div>Login Page (placeholder)</div>, // Replaced in Plan 04
});

const registerRoute = createRoute({
  getParentRoute: () => rootRoute,
  path: '/register',
  component: () => <div>Register Page (placeholder)</div>, // Replaced in Plan 04
});

const verifyRoute = createRoute({
  getParentRoute: () => rootRoute,
  path: '/verify',
  component: () => <div>Verify Email (placeholder)</div>, // Replaced in Plan 05
});

// Protected layout route — auth guard via beforeLoad
const protectedLayoutRoute = createRoute({
  getParentRoute: () => rootRoute,
  id: 'protected',
  component: ProtectedRoute, // from ProtectedRoute.tsx
  beforeLoad: ({ context }) => {
    if (!context.auth.isLoading && !context.auth.isAuthenticated) {
      throw redirect({ to: '/login' });
    }
  },
});

const dashboardRoute = createRoute({
  getParentRoute: () => protectedLayoutRoute,
  path: '/dashboard',
  component: () => <div>Dashboard (placeholder)</div>, // Replaced in Plan 05
});

// Root index route — redirect based on auth state
const indexRoute = createRoute({
  getParentRoute: () => rootRoute,
  path: '/',
  beforeLoad: ({ context }) => {
    if (context.auth.isLoading) return; // let component handle loading
    throw redirect({ to: context.auth.isAuthenticated ? '/dashboard' : '/login' });
  },
  component: () => (
    <div className="flex min-h-screen items-center justify-center bg-background">
      <div className="text-muted-foreground">Loading...</div>
    </div>
  ),
});

// Build route tree
const routeTree = rootRoute.addChildren([
  loginRoute,
  registerRoute,
  verifyRoute,
  protectedLayoutRoute.addChildren([dashboardRoute]),
  indexRoute,
]);

// Create router factory (router created in main.tsx with context)
export { routeTree };
export type { AuthContextType };
```

**Update `apps/web/src/main.tsx`:**
Create the router with auth context and render RouterProvider:

```typescript
import { StrictMode } from 'react';
import { createRoot } from 'react-dom/client';
import { createRouter, RouterProvider } from '@tanstack/react-router';
import { AuthProvider, useAuth } from './features/auth/context/AuthContext';
import { routeTree } from './routes';

// fonts and styles (keep existing)

const router = createRouter({
  routeTree,
  context: { auth: undefined! }, // will be provided by InnerApp
  defaultNotFoundComponent: () => {
    window.location.href = '/';
    return null;
  },
});

// Register router type for type safety
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}

// Inner component that provides auth context to router
function InnerApp() {
  const auth = useAuth();
  return <RouterProvider router={router} context={{ auth }} />;
}

const root = document.getElementById('root')!;
createRoot(root).render(
  <StrictMode>
    <AuthProvider>
      <InnerApp />
    </AuthProvider>
  </StrictMode>,
);
```

**Update `apps/web/src/app/App.tsx`:**
This file becomes minimal or can be removed. The routing is now defined in routes.tsx and rendered via RouterProvider in main.tsx. If you want to keep App.tsx as a wrapper, it can export a simple component, but the route definitions live in routes.tsx.

Strip App.tsx down to a re-export or delete it and update any imports. The simplest approach: keep App.tsx but make it a thin wrapper that the route tree's root component uses, or just remove it since main.tsx now handles everything.

Important: The existing App.tsx has dark mode toggle and sidebar. Move that content to DashboardPage in Plan 05.

**Key TanStack Router concepts for the executor:**
- `createRootRouteWithContext<T>()` creates root with typed context
- `createRoute({ getParentRoute, path, component, beforeLoad })` defines routes
- `redirect({ to })` throws a redirect from `beforeLoad`
- `RouterProvider` renders the router
- `Outlet` from `@tanstack/react-router` renders child routes
- `useNavigate` from `@tanstack/react-router` for programmatic navigation
- `Link` from `@tanstack/react-router` for type-safe links
- `useSearch` from `@tanstack/react-router` for search params (used in VerifyEmailPage for ?token=)
- Route context is passed via `RouterProvider context={{ auth }}` and accessed via `beforeLoad({ context })`
  </action>
  <verify>
    `npx nx typecheck web` passes.
    `npx nx test web` — existing tests may need updating if they render App directly. Update test to render within TanStack Router test utilities (createMemoryHistory + RouterProvider).
  </verify>
  <done>
    ProtectedRoute guards authenticated pages with loading state. TanStack Router routes configured for /login, /register, /verify, /dashboard, and root redirect. Route-level beforeLoad handles auth redirects. Router context provides auth state to all routes. Existing tests updated if needed.
  </done>
</task>

</tasks>

<verification>
- `npx nx typecheck web && npx nx test web` passes
- AuthProvider exists and exports from AuthContext.tsx
- useAuth hook works outside tests
- ProtectedRoute redirects when not authenticated
- TanStack Router route tree renders correct placeholder components
- Root path redirects based on auth state via beforeLoad
- Router type registration enables type-safe navigation
</verification>

<success_criteria>
1. AuthProvider with optimistic refresh, login(), logout(), user profile
2. useAuth() hook with proper error on missing provider
3. ProtectedRoute shows loading state; beforeLoad redirects if unauthenticated
4. TanStack Router routes: /login, /register, /verify (public), /dashboard (protected), / (smart redirect)
5. Router context provides auth state to all routes
6. All tests pass with updated routing
</success_criteria>

<output>
After completion, create `.planning/phases/13-login-ui/13-03-SUMMARY.md`
</output>
