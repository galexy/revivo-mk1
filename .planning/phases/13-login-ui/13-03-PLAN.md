---
phase: 13-login-ui
plan: 03
type: execute
wave: 2
depends_on: ["13-01", "13-02"]
files_modified:
  - apps/web/src/features/auth/context/AuthContext.tsx
  - apps/web/src/features/auth/context/useAuth.ts
  - apps/web/src/features/auth/components/ProtectedRoute.tsx
  - apps/web/src/main.tsx
  - apps/web/src/app/App.tsx
autonomous: true

must_haves:
  truths:
    - "AuthProvider attempts silent token refresh on mount via /auth/refresh"
    - "useAuth() hook exposes user, login, logout, isAuthenticated, isLoading"
    - "login() calls /auth/token, fetches /auth/me, and stores user profile in context"
    - "logout() calls /auth/logout and clears in-memory token"
    - "ProtectedRoute redirects unauthenticated users to /login silently"
    - "isLoading state prevents flash of login page during auth check"
  artifacts:
    - path: "apps/web/src/features/auth/context/AuthContext.tsx"
      provides: "AuthProvider with token management and user profile"
      contains: "AuthProvider"
    - path: "apps/web/src/features/auth/context/useAuth.ts"
      provides: "useAuth hook for consuming auth context"
      contains: "useAuth"
    - path: "apps/web/src/features/auth/components/ProtectedRoute.tsx"
      provides: "Route guard that redirects unauthenticated users"
      contains: "ProtectedRoute"
  key_links:
    - from: "apps/web/src/features/auth/context/AuthContext.tsx"
      to: "apps/web/src/lib/api.ts"
      via: "imports api and setAccessToken"
      pattern: "setAccessToken"
    - from: "apps/web/src/features/auth/context/AuthContext.tsx"
      to: "/auth/refresh"
      via: "optimistic mount refresh"
      pattern: "/auth/refresh"
    - from: "apps/web/src/features/auth/context/AuthContext.tsx"
      to: "/auth/me"
      via: "pre-fetch user profile after token"
      pattern: "/auth/me"
---

<objective>
Create the AuthContext provider, useAuth hook, ProtectedRoute component, and wire up react-router-dom routing.

Purpose: AuthContext is the central auth state manager. It handles optimistic token refresh on page load, stores user profile, and provides login/logout methods. ProtectedRoute uses this context to guard authenticated pages. React Router provides minimal client-side routing for login/register/verify/dashboard pages.

Output: Working auth context with optimistic refresh, protected route component, basic routing setup.
</objective>

<execution_context>
@/home/developer/.claude/get-shit-done/workflows/execute-plan.md
@/home/developer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@apps/web/src/lib/api.ts
@apps/web/src/features/auth/types.ts
@apps/web/src/main.tsx
@apps/web/src/app/App.tsx
@.planning/phases/13-login-ui/13-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AuthContext provider with optimistic refresh and useAuth hook</name>
  <files>
    apps/web/src/features/auth/context/AuthContext.tsx
    apps/web/src/features/auth/context/useAuth.ts
  </files>
  <action>
**Create `apps/web/src/features/auth/context/AuthContext.tsx`:**

This is the core auth state manager. Implementation requirements:

1. **State:** `user: UserProfile | null`, `isLoading: boolean` (starts true), module-level accessToken via `setAccessToken`/`getAccessToken` from `lib/api.ts`

2. **Optimistic mount refresh (useEffect):**
   - On mount, call `POST /auth/refresh` via the api instance
   - On success: call `setAccessToken(token)`, then `GET /auth/me` to fetch user profile, set user state
   - On failure: user stays null (not authenticated)
   - Always: set isLoading to false
   - Use AbortController for cleanup to prevent React StrictMode double-mount race condition (see RESEARCH.md Pitfall 6)

3. **login(email, password, rememberMe):**
   - Call `POST /auth/token` with form-encoded body: `username=email&password=password&remember_me=rememberMe`
   - The /auth/token endpoint uses OAuth2PasswordRequestForm so body must be `application/x-www-form-urlencoded`
   - Use `URLSearchParams` or `new FormData()` for the body, and set Content-Type header to `application/x-www-form-urlencoded`
   - On success: call `setAccessToken(response.data.access_token)`, then `GET /auth/me` to fetch user profile
   - On failure: throw error (caller handles display)
   - Return void on success

4. **logout():**
   - Call `POST /auth/logout` via api instance (clears cookie server-side)
   - Call `setAccessToken(null)` to clear in-memory token
   - Set user to null
   - Navigate to `/login` (use react-router-dom's `useNavigate` — but since AuthContext wraps the Router, use `window.location.href = '/login'` instead to avoid circular dependency, OR accept navigate as a callback)

   Design choice: Use `window.location.href = '/login'` for logout redirect. This is simpler and avoids coupling AuthContext to the router. The full page reload also clears any stale state.

5. **Context value:** `{ user, isAuthenticated: !!user, isLoading, login, logout }`

6. **Derived computed state:** `isAuthenticated` is `!!user` (not separate state)

**Create `apps/web/src/features/auth/context/useAuth.ts`:**
```typescript
import { useContext } from 'react';
import { AuthContext } from './AuthContext';

export function useAuth() {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
}
```

Important implementation details:
- The api instance already has `withCredentials: true` so cookies are sent automatically
- The api interceptor handles token refresh on 401 for regular API calls — AuthContext only handles the initial mount refresh and explicit login/logout
- The login body must be form-encoded (not JSON) because the backend uses OAuth2PasswordRequestForm
- Type the context with a proper interface, not `any`
  </action>
  <verify>
    `npx nx typecheck web` passes.
    Verify AuthContext.tsx exports AuthProvider and AuthContext.
    Verify useAuth.ts exports useAuth hook.
  </verify>
  <done>
    AuthProvider handles optimistic refresh on mount, provides login/logout methods, stores user profile from /auth/me. useAuth hook provides typed access to auth context. AbortController prevents StrictMode double-mount issues.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ProtectedRoute and set up react-router-dom routing</name>
  <files>
    apps/web/src/features/auth/components/ProtectedRoute.tsx
    apps/web/src/main.tsx
    apps/web/src/app/App.tsx
  </files>
  <action>
**Create `apps/web/src/features/auth/components/ProtectedRoute.tsx`:**

```typescript
import { Navigate, Outlet } from 'react-router-dom';
import { useAuth } from '../context/useAuth';

export function ProtectedRoute() {
  const { isAuthenticated, isLoading } = useAuth();

  if (isLoading) {
    // Neutral loading state while checking auth — prevents FOUC (Pitfall 1 from research)
    // Show a minimal centered spinner or skeleton, NOT the login page
    return (
      <div className="flex min-h-screen items-center justify-center bg-background">
        <div className="text-muted-foreground">Loading...</div>
      </div>
    );
  }

  // Silent redirect — no toast/message per user decision
  return isAuthenticated ? <Outlet /> : <Navigate to="/login" replace />;
}
```

**Update `apps/web/src/main.tsx`:**
Wrap the app with BrowserRouter and AuthProvider:

```typescript
import { StrictMode } from 'react';
import { createRoot } from 'react-dom/client';
import { BrowserRouter } from 'react-router-dom';
import { AuthProvider } from './features/auth/context/AuthContext';

// fonts and styles (keep existing)

import { App } from './app/App';

createRoot(root).render(
  <StrictMode>
    <BrowserRouter>
      <AuthProvider>
        <App />
      </AuthProvider>
    </BrowserRouter>
  </StrictMode>,
);
```

**Update `apps/web/src/app/App.tsx`:**
Replace the current placeholder content with a Routes setup. For now, create placeholder page components inline (they'll be replaced in Plans 04-05):

```typescript
import { Routes, Route, Navigate } from 'react-router-dom';
import { useAuth } from '../features/auth/context/useAuth';
import { ProtectedRoute } from '../features/auth/components/ProtectedRoute';

// Placeholder pages — will be replaced in Plans 04 and 05
function LoginPage() {
  return <div>Login Page (placeholder)</div>;
}
function RegisterPage() {
  return <div>Register Page (placeholder)</div>;
}
function VerifyEmailPage() {
  return <div>Verify Email (placeholder)</div>;
}
function DashboardPage() {
  return <div>Dashboard (placeholder - authenticated)</div>;
}

export function App() {
  return (
    <Routes>
      {/* Public routes */}
      <Route path="/login" element={<LoginPage />} />
      <Route path="/register" element={<RegisterPage />} />
      <Route path="/verify" element={<VerifyEmailPage />} />

      {/* Protected routes */}
      <Route element={<ProtectedRoute />}>
        <Route path="/dashboard" element={<DashboardPage />} />
      </Route>

      {/* Root redirect */}
      <Route path="/" element={<RootRedirect />} />

      {/* Catch-all */}
      <Route path="*" element={<Navigate to="/" replace />} />
    </Routes>
  );
}

function RootRedirect() {
  const { isAuthenticated, isLoading } = useAuth();
  if (isLoading) {
    return (
      <div className="flex min-h-screen items-center justify-center bg-background">
        <div className="text-muted-foreground">Loading...</div>
      </div>
    );
  }
  return <Navigate to={isAuthenticated ? '/dashboard' : '/login'} replace />;
}
```

Keep the existing theme/dark mode toggle logic — it can move into DashboardPage later.

Important: The existing App.tsx has dark mode toggle and sidebar. For now, strip it down to just the routing shell. The sidebar/dashboard content will be restored in Plan 05 as the DashboardPage component.
  </action>
  <verify>
    `npx nx typecheck web` passes.
    `npx nx test web` — existing tests may need updating if they render App directly. Update test to render App within a MemoryRouter + AuthProvider mock.
  </verify>
  <done>
    ProtectedRoute guards authenticated pages with loading state. React Router routes configured for /login, /register, /verify, /dashboard, and root redirect. App.tsx renders route shell. Existing tests updated if needed.
  </done>
</task>

</tasks>

<verification>
- `npx nx typecheck web && npx nx test web` passes
- AuthProvider exists and exports from AuthContext.tsx
- useAuth hook works outside tests
- ProtectedRoute redirects when not authenticated
- Routes render correct placeholder components
- Root path redirects based on auth state
</verification>

<success_criteria>
1. AuthProvider with optimistic refresh, login(), logout(), user profile
2. useAuth() hook with proper error on missing provider
3. ProtectedRoute shows loading state then redirects if unauthenticated
4. Routes: /login, /register, /verify (public), /dashboard (protected), / (smart redirect)
5. All tests pass with updated routing
</success_criteria>

<output>
After completion, create `.planning/phases/13-login-ui/13-03-SUMMARY.md`
</output>
