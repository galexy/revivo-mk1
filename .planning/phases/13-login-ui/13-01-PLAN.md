---
phase: 13-login-ui
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/api/src/adapters/api/routes/auth.py
  - apps/web/package.json
  - apps/web/src/lib/api.ts
  - apps/web/src/features/auth/types.ts
autonomous: true

must_haves:
  truths:
    - "Axios instance sends cookies cross-origin (withCredentials: true)"
    - "401 responses trigger silent token refresh before retrying"
    - "Concurrent 401s are queued (failedQueue pattern) to prevent refresh race"
    - "Refresh token cookie uses samesite=lax for cross-origin CORS compatibility"
    - "Backend /auth/token accepts remember_me parameter controlling cookie persistence"
  artifacts:
    - path: "apps/web/src/lib/api.ts"
      provides: "Axios instance with auth interceptors"
      contains: "withCredentials"
    - path: "apps/web/src/features/auth/types.ts"
      provides: "Auth TypeScript types (UserProfile, TokenResponse, etc.)"
      contains: "UserProfile"
    - path: "apps/api/src/adapters/api/routes/auth.py"
      provides: "Fixed samesite cookie + remember_me support"
      contains: "remember_me"
  key_links:
    - from: "apps/web/src/lib/api.ts"
      to: "http://localhost:8000"
      via: "axios.create baseURL"
      pattern: "baseURL.*localhost:8000"
---

<objective>
Set up the HTTP client layer and fix backend cookie issues for cross-origin auth flow.

Purpose: The Axios instance with interceptors is the foundation for all frontend-backend communication. The backend cookie fix is critical because samesite=strict blocks cross-origin cookies entirely, breaking the refresh flow. The remember_me parameter is needed for the login form checkbox.

Output: Working Axios client with silent token refresh, fixed backend cookies, TypeScript auth types.
</objective>

<execution_context>
@/home/developer/.claude/get-shit-done/workflows/execute-plan.md
@/home/developer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@apps/api/src/adapters/api/routes/auth.py
@apps/api/src/adapters/api/schemas/auth.py
@apps/web/package.json
@apps/web/vite.config.ts
@libs/ui/package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix backend cookie samesite + add remember_me parameter</name>
  <files>
    apps/api/src/adapters/api/routes/auth.py
  </files>
  <action>
Two backend changes are required for the frontend auth flow:

**1. Fix samesite cookie issue:**
The refresh_token cookie currently uses `samesite="strict"` with `path="/auth/refresh"`. In cross-origin mode (localhost:5173 -> localhost:8000), browsers will NOT send samesite=strict cookies in cross-origin requests. Change to `samesite="lax"` in both `_set_refresh_cookie()` and `_clear_refresh_cookie()`.

Also change the cookie path from `/auth/refresh` to `/auth` so the cookie is sent for both `/auth/refresh` and `/auth/logout` endpoints. The path must match both endpoints that need the cookie.

**2. Add remember_me to /auth/token endpoint:**
The login endpoint currently uses `OAuth2PasswordRequestForm` which doesn't support `remember_me`. Modify the `/auth/token` endpoint to also accept a `remember_me` query parameter (or form field). When `remember_me` is false (default), set the cookie without `max_age` (makes it a session cookie — lost when browser closes). When `remember_me` is true, keep the existing 30-day max_age.

Implementation:
- Add `remember_me: bool = False` as a Form parameter alongside the existing OAuth2PasswordRequestForm
- Modify `_set_refresh_cookie()` to accept an optional `max_age` parameter (None = session cookie, integer = persistent)
- In the `/auth/token` handler, pass `max_age=REFRESH_TOKEN_MAX_AGE` if remember_me is True, else `max_age=None`
- Update REFRESH_TOKEN_MAX_AGE to 30 days (currently 7 days) per user decision
- Keep the refresh endpoint using persistent max_age (30 days) since it should extend the session

Note: `OAuth2PasswordRequestForm` uses `Depends()` which consumes the form body. The `remember_me` field must be a separate `Form(default=False)` parameter, not a query parameter, since the login uses form-encoded body.
  </action>
  <verify>
    Run `npx nx typecheck api && npx nx test api` to verify no regressions.
    Start the API with `npx nx serve api` and test:
    - `curl -X POST http://localhost:8000/auth/token -d "username=test@example.com&password=Test1234!&remember_me=true" -v` — verify Set-Cookie has samesite=lax and max-age
    - `curl -X POST http://localhost:8000/auth/token -d "username=test@example.com&password=Test1234!" -v` — verify Set-Cookie has NO max-age (session cookie)
  </verify>
  <done>
    samesite=lax on refresh cookies, cookie path=/auth, remember_me controls session vs persistent cookie, 30-day max_age when persistent, all existing tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Install frontend dependencies and create Axios client with auth interceptors</name>
  <files>
    apps/web/package.json
    apps/web/src/lib/api.ts
    apps/web/src/features/auth/types.ts
  </files>
  <action>
**1. Install frontend dependencies:**
```bash
cd /workspace && pnpm add --filter @workspace/web react-hook-form zod @hookform/resolvers @radix-ui/react-icons axios react-router-dom
pnpm add --filter @workspace/web -D @types/react-router-dom
```
Note: @types/react-router-dom may not be needed if react-router-dom v6 ships its own types. Check after install.

**2. Create auth types at `apps/web/src/features/auth/types.ts`:**
```typescript
export interface UserProfile {
  user_id: string;
  email: string;
  display_name: string;
  email_verified: boolean;
  created_at: string;
  household: {
    id: string;
    name: string;
    is_owner: boolean;
  };
}

export interface TokenResponse {
  access_token: string;
  token_type: string;
  expires_in: number;
}

export interface RegisterRequest {
  email: string;
  password: string;
  display_name: string;
}

export interface RegisterResponse {
  message: string;
  user_id: string;
  email: string;
}

export interface VerifyEmailResponse {
  message: string;
  user_id: string;
  email: string;
}

export interface AuthError {
  detail: string;
}
```

**3. Create Axios instance at `apps/web/src/lib/api.ts`:**
Implement the Axios instance with:
- `baseURL: 'http://localhost:8000'`
- `withCredentials: true` (send cookies cross-origin)
- Request interceptor: attach Bearer token from module-level `accessToken` variable
- Response interceptor: on 401, check if URL is /auth/refresh (if so, redirect to /login?expired=true and reject). Otherwise, use `failedQueue` pattern — first 401 triggers refresh, concurrent 401s wait. On successful refresh, update accessToken and retry. On failed refresh, clear token and redirect to login.
- Export `setAccessToken(token: string | null)` and `getAccessToken()` functions for AuthContext to control the token
- Export `api` as default export

Follow the exact pattern from 13-RESEARCH.md Code Examples section (Axios Instance with Auth Interceptor). Key difference: use `window.location.href = '/login?expired=true'` for session expiry redirect (not `?message=session_expired`).

Important: The interceptor must NOT retry requests to `/auth/refresh` to avoid infinite loops.
  </action>
  <verify>
    Run `npx nx typecheck web` to verify types compile.
    Run `npx nx test web` to verify no existing tests break.
  </verify>
  <done>
    Dependencies installed, auth types exported, Axios client has withCredentials, request interceptor attaches Bearer token, response interceptor handles 401 with failedQueue pattern, module-level token store with getters/setters.
  </done>
</task>

</tasks>

<verification>
- `npx nx typecheck api && npx nx test api` passes (backend changes)
- `npx nx typecheck web && npx nx test web` passes (frontend changes)
- Axios client has withCredentials: true
- Backend cookie uses samesite=lax
- Backend /auth/token accepts remember_me form field
</verification>

<success_criteria>
1. Backend refresh token cookie uses samesite=lax (not strict) for CORS compatibility
2. Backend login endpoint supports remember_me parameter (session vs persistent cookie)
3. Axios instance with interceptors created and type-checks
4. Auth types match backend API contract exactly
5. All existing tests pass for both api and web projects
</success_criteria>

<output>
After completion, create `.planning/phases/13-login-ui/13-01-SUMMARY.md`
</output>
