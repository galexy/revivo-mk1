---
phase: 14-frontend-api-routing
plan: 02
type: execute
wave: 2
depends_on: ["14-01"]
files_modified:
  - apps/web/src/lib/api-client.ts
  - apps/web/src/lib/query-client.ts
  - apps/web/src/lib/query-keys.ts
  - apps/web/src/lib/query-options.ts
  - apps/web/src/lib/api-error.ts
  - apps/web/src/main.tsx
  - apps/web/src/routes.tsx
autonomous: true

must_haves:
  truths:
    - "QueryClientProvider wraps the app and provides TanStack Query context"
    - "ReactQueryDevtools are available in development"
    - "Type-safe API client functions use generated OpenAPI types for request/response"
    - "Query key factory organizes keys by entity with hierarchical invalidation"
    - "queryOptions factories exist for accounts, transactions, categories, payees"
    - "API errors are parsed into a consistent ApiError type with code and message"
    - "Route loaders use queryOptions + ensureQueryData for instant navigation"
    - "Auth context preserved as React Context (not refactored to TanStack Query)"
  artifacts:
    - path: "apps/web/src/lib/api-client.ts"
      provides: "Type-safe API client wrapper over existing Axios instance"
      contains: "api-types.generated"
    - path: "apps/web/src/lib/query-client.ts"
      provides: "TanStack Query client configuration"
      contains: "QueryClient"
    - path: "apps/web/src/lib/query-keys.ts"
      provides: "Query key factory for entity-based key hierarchy"
      contains: "queryKeys"
    - path: "apps/web/src/lib/query-options.ts"
      provides: "queryOptions factories for all entity types"
      contains: "queryOptions"
    - path: "apps/web/src/lib/api-error.ts"
      provides: "API error parsing utilities"
      contains: "ApiError"
    - path: "apps/web/src/main.tsx"
      provides: "App entry with QueryClientProvider"
      contains: "QueryClientProvider"
    - path: "apps/web/src/routes.tsx"
      provides: "Route definitions with loader patterns using queryOptions"
      contains: "ensureQueryData"
  key_links:
    - from: "apps/web/src/lib/api-client.ts"
      to: "apps/web/src/lib/api.ts"
      via: "imports existing axios instance"
      pattern: "import.*api"
    - from: "apps/web/src/lib/api-client.ts"
      to: "apps/web/src/lib/api-types.generated.ts"
      via: "imports generated types for type safety"
      pattern: "api-types.generated"
    - from: "apps/web/src/main.tsx"
      to: "apps/web/src/lib/query-client.ts"
      via: "imports QueryClient and wraps app"
      pattern: "QueryClientProvider"
    - from: "apps/web/src/lib/query-options.ts"
      to: "apps/web/src/lib/api-client.ts"
      via: "uses typed API client functions as queryFn"
      pattern: "fetchAccounts|fetchTransactions"
    - from: "apps/web/src/lib/query-options.ts"
      to: "apps/web/src/lib/query-keys.ts"
      via: "uses query key factory for cache keys"
      pattern: "queryKeys"
    - from: "apps/web/src/routes.tsx"
      to: "apps/web/src/lib/query-options.ts"
      via: "route loaders use queryOptions for data prefetch"
      pattern: "queryOptions|ensureQueryData"
---

<objective>
Create TanStack Query infrastructure and integrate with TanStack Router loaders. QueryClient configuration, type-safe API client, query key factory, queryOptions factories, API error handling, and route loader integration.

Purpose: Establish the data layer patterns that all future UI phases (15-26) will use. Type-safe API calls ensure frontend stays in sync with backend. Query keys enable smart cache invalidation. Route loaders prefetch data so navigation feels instant (per user decision: "Route loaders prefetch data so navigation feels instant").

Output: QueryClientProvider in app, typed API client, query key hierarchy, queryOptions factories, API error utilities, route loader pattern with ensureQueryData.
</objective>

<execution_context>
@/home/developer/.claude/get-shit-done/workflows/execute-plan.md
@/home/developer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@apps/web/src/main.tsx
@apps/web/src/routes.tsx
@apps/web/src/lib/api.ts
@apps/web/src/lib/api-types.generated.ts
@apps/web/src/features/auth/types.ts
@apps/web/src/features/auth/context/AuthContext.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create QueryClient, query keys, API client, wire into app</name>
  <files>
    apps/web/src/lib/query-client.ts
    apps/web/src/lib/query-keys.ts
    apps/web/src/lib/api-client.ts
    apps/web/src/main.tsx
  </files>
  <action>
    1. Create `apps/web/src/lib/query-client.ts`:
       - Export a `queryClient` instance with sensible defaults:
         - `staleTime: 30_000` (30s default — accounts/categories change rarely)
         - `gcTime: 5 * 60_000` (5 min garbage collection)
         - `retry: 1` (retry once, but NOT on 401 — Axios interceptor handles that)
         - `refetchOnWindowFocus: true` for stale-while-revalidate behavior
       - Export a `createQueryClient()` factory for tests (fresh client per test)
       - Configure mutation defaults: no retry for mutations

    2. Create `apps/web/src/lib/query-keys.ts`:
       - Export `queryKeys` factory following TkDodo's v5 pattern:
         ```typescript
         export const queryKeys = {
           accounts: {
             all: ['accounts'] as const,
             lists: () => [...queryKeys.accounts.all, 'list'] as const,
             list: (filters?: AccountFilters) => [...queryKeys.accounts.lists(), filters] as const,
             details: () => [...queryKeys.accounts.all, 'detail'] as const,
             detail: (id: string) => [...queryKeys.accounts.details(), id] as const,
           },
           transactions: {
             all: ['transactions'] as const,
             lists: () => [...queryKeys.transactions.all, 'list'] as const,
             list: (filters?: TransactionFilters) => [...queryKeys.transactions.lists(), filters] as const,
             details: () => [...queryKeys.transactions.all, 'detail'] as const,
             detail: (id: string) => [...queryKeys.transactions.details(), id] as const,
           },
           categories: {
             all: ['categories'] as const,
             tree: () => [...queryKeys.categories.all, 'tree'] as const,
             lists: () => [...queryKeys.categories.all, 'list'] as const,
           },
           payees: {
             all: ['payees'] as const,
             lists: () => [...queryKeys.payees.all, 'list'] as const,
           },
           user: {
             profile: ['user', 'profile'] as const,
           },
         };
         ```
       - Filter types can be minimal for now (just type aliases — Phase 15+ will add real filters)

    3. Create `apps/web/src/lib/api-client.ts`:
       - Import the existing `api` axios instance from `./api`
       - Import generated types from `./api-types.generated`
       - Export typed API functions that use the generated `paths` type for endpoint matching:
         ```typescript
         // Accounts
         export async function fetchAccounts() { ... }
         export async function fetchAccount(id: string) { ... }
         export async function createAccount(data: CreateAccountRequest) { ... }
         export async function updateAccount(id: string, data: UpdateAccountRequest) { ... }
         export async function deleteAccount(id: string) { ... }

         // Transactions
         export async function fetchTransactions(accountId: string) { ... }
         export async function fetchTransaction(id: string) { ... }
         export async function createTransaction(data: CreateTransactionRequest) { ... }
         export async function updateTransaction(id: string, data: UpdateTransactionRequest) { ... }
         export async function deleteTransaction(id: string) { ... }

         // Categories
         export async function fetchCategories() { ... }
         export async function fetchCategoryTree() { ... }

         // Payees
         export async function fetchPayees() { ... }
         ```
       - Each function extracts the response `.data` (unwrap AxiosResponse)
       - Use the generated component schema types for request/response typing
       - Export type aliases for commonly used types (AccountResponse, TransactionResponse, etc.)

    4. Update `apps/web/src/main.tsx`:
       - Import `QueryClientProvider` from `@tanstack/react-query`
       - Import `ReactQueryDevtools` from `@tanstack/react-query-devtools`
       - Import `queryClient` from `./lib/query-client`
       - Wrap the app tree with `QueryClientProvider`:
         ```tsx
         <StrictMode>
           <QueryClientProvider client={queryClient}>
             <AuthProvider>
               <InnerApp />
             </AuthProvider>
             <ReactQueryDevtools initialIsOpen={false} />
           </QueryClientProvider>
         </StrictMode>
         ```
       - Note: QueryClientProvider OUTSIDE AuthProvider so auth context can use queries
       - ReactQueryDevtools INSIDE QueryClientProvider but OUTSIDE AuthProvider (it's a debug panel, doesn't need auth)

    5. Run `npx nx typecheck web` and `npx nx test web` to verify everything compiles and existing tests pass.
  </action>
  <verify>
    - `npx nx typecheck web` passes
    - `npx nx test web` passes (all existing tests still work)
    - main.tsx contains QueryClientProvider wrapping the app tree
    - api-client.ts references generated types from api-types.generated.ts
    - query-keys.ts exports query key factory
  </verify>
  <done>
    QueryClient configured and wired into app with QueryClientProvider. ReactQueryDevtools available in development. Type-safe API client wraps existing Axios instance with generated types. Query key hierarchy supports entity-based invalidation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create queryOptions factories, API error utilities, and route loader integration</name>
  <files>
    apps/web/src/lib/query-options.ts
    apps/web/src/lib/api-error.ts
    apps/web/src/routes.tsx
  </files>
  <action>
    1. Create `apps/web/src/lib/api-error.ts`:
       - Define `ApiError` type:
         ```typescript
         export interface ApiError {
           status: number;
           code: string;
           message: string;
           isValidation: boolean;   // 4xx
           isServerError: boolean;  // 5xx
         }
         ```
       - Export `parseApiError(error: unknown): ApiError` function:
         - If AxiosError with response: extract status, parse detail (FastAPI returns `{ detail: string | { code, message } }`)
         - Handle both string detail (auth endpoints) and object detail (domain endpoints)
         - If network error (no response): return `{ status: 0, code: 'NETWORK_ERROR', message: 'Unable to connect to server', ... }`
         - If unknown error: return generic server error
       - Export `isApiError(error: unknown): error is AxiosError` type guard
       - Export `getErrorMessage(error: unknown): string` convenience function that returns user-friendly message:
         - For validation errors (4xx): use backend message directly (it's specific and actionable, per user decision)
         - For server errors (5xx): return friendly "Something went wrong. Please try again." (per user decision)
         - For network errors: return "Unable to connect. Please check your connection."

    2. Create `apps/web/src/lib/query-options.ts`:
       - Import `queryOptions` from `@tanstack/react-query`
       - Import API client functions from `./api-client`
       - Import query keys from `./query-keys`
       - Create queryOptions factories following TkDodo's v5 pattern:

         ```typescript
         // Accounts
         export const accountsQueryOptions = queryOptions({
           queryKey: queryKeys.accounts.lists(),
           queryFn: fetchAccounts,
           staleTime: 60_000, // accounts rarely change
         });

         export const accountDetailQueryOptions = (id: string) =>
           queryOptions({
             queryKey: queryKeys.accounts.detail(id),
             queryFn: () => fetchAccount(id),
             staleTime: 60_000,
           });

         // Transactions
         export const transactionsQueryOptions = (accountId: string) =>
           queryOptions({
             queryKey: queryKeys.transactions.list({ accountId }),
             queryFn: () => fetchTransactions(accountId),
             staleTime: 15_000, // transactions change more often
           });

         export const transactionDetailQueryOptions = (id: string) =>
           queryOptions({
             queryKey: queryKeys.transactions.detail(id),
             queryFn: () => fetchTransaction(id),
             staleTime: 15_000,
           });

         // Categories
         export const categoriesQueryOptions = queryOptions({
           queryKey: queryKeys.categories.lists(),
           queryFn: fetchCategories,
           staleTime: 5 * 60_000, // categories very rarely change
         });

         export const categoryTreeQueryOptions = queryOptions({
           queryKey: queryKeys.categories.tree(),
           queryFn: fetchCategoryTree,
           staleTime: 5 * 60_000,
         });

         // Payees
         export const payeesQueryOptions = queryOptions({
           queryKey: queryKeys.payees.lists(),
           queryFn: fetchPayees,
           staleTime: 60_000,
         });
         ```

    3. Update `apps/web/src/routes.tsx` to add route loader patterns:
       - Import `queryClient` from `./lib/query-client`
       - Import `accountsQueryOptions` from `./lib/query-options`
       - Update `createRootRouteWithContext` context type to include `queryClient`:
         ```typescript
         const rootRoute = createRootRouteWithContext<{
           auth: AuthContextType;
           queryClient: QueryClient;
         }>()({ component: () => <Outlet /> });
         ```
       - Add a loader to the dashboard route as a pattern example:
         ```typescript
         const dashboardRoute = createRoute({
           getParentRoute: () => protectedLayoutRoute,
           path: '/dashboard',
           component: DashboardPage,
           loader: ({ context }) => {
             // Prefetch accounts data so dashboard loads instantly
             context.queryClient.ensureQueryData(accountsQueryOptions);
           },
         });
         ```
       - This establishes the loader pattern that Phase 15+ routes will follow.
         Future routes (e.g., /accounts/:id) will use `ensureQueryData(accountDetailQueryOptions(id))` in their loaders.
       - Update `apps/web/src/main.tsx` to pass queryClient to the router context:
         The router creation in main.tsx should include `context: { queryClient }` alongside `context: { auth }`.
         Check how the router is currently created and add queryClient to the context.

    4. Auth context: do NOT refactor AuthContext to use TanStack Query — auth state management via React Context is the correct pattern (per user decision: auth state = React Context, server state = TanStack Query). The api-error.ts utilities are available for FUTURE use by Phase 15+ components.

    5. Run all quality checks:
       - `npx nx typecheck web`
       - `npx nx test web`
       - `npx nx lint web`
  </action>
  <verify>
    - `npx nx typecheck web` passes
    - `npx nx test web` passes (all existing tests still work)
    - `npx nx lint web` passes
    - query-options.ts exports factories for accounts, transactions, categories, payees
    - api-error.ts exports parseApiError, getErrorMessage, ApiError type
    - routes.tsx imports queryClient and uses ensureQueryData in a route loader
    - Router context type includes queryClient
  </verify>
  <done>
    queryOptions factories configured with per-entity stale times. API error parsing handles FastAPI error format consistently. Route loaders use ensureQueryData for instant navigation. Router context includes queryClient for loader access. Auth context preserved as React Context.
  </done>
</task>

</tasks>

<verification>
1. `npx nx typecheck web` passes
2. `npx nx test web` passes
3. `npx nx lint web` passes
4. `apps/web/src/main.tsx` contains QueryClientProvider wrapping the app
5. `apps/web/src/lib/api-client.ts` imports from `api-types.generated`
6. `apps/web/src/lib/query-keys.ts` exports query key factory
7. `apps/web/src/lib/query-options.ts` exports queryOptions factories
8. `apps/web/src/lib/api-error.ts` exports parseApiError and getErrorMessage
9. `apps/web/src/routes.tsx` uses ensureQueryData in a route loader
10. Router context type includes queryClient
</verification>

<success_criteria>
- QueryClientProvider wraps app with configured defaults
- ReactQueryDevtools available
- Type-safe API client uses generated OpenAPI types
- Query key hierarchy supports entity-based invalidation
- queryOptions factories usable by route loaders and components
- Route loaders use ensureQueryData for data prefetch (instant navigation pattern)
- API errors parsed consistently with user-friendly messages
- Auth context unchanged (React Context for auth, TanStack Query for server state)
- All existing tests and quality checks pass
</success_criteria>

<output>
After completion, create `.planning/phases/14-frontend-api-routing/14-02-SUMMARY.md`
</output>
