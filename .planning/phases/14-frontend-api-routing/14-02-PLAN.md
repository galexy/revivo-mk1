---
phase: 14-frontend-api-routing
plan: 02
type: execute
wave: 2
depends_on: ["14-01"]
files_modified:
  - apps/web/src/lib/api-client.ts
  - apps/web/src/lib/query-client.ts
  - apps/web/src/lib/query-keys.ts
  - apps/web/src/main.tsx
autonomous: true

must_haves:
  truths:
    - "QueryClientProvider wraps the app and provides TanStack Query context"
    - "ReactQueryDevtools are available in development"
    - "Type-safe API client functions use generated OpenAPI types for request/response"
    - "Query key factory organizes keys by entity with hierarchical invalidation"
  artifacts:
    - path: "apps/web/src/lib/api-client.ts"
      provides: "Type-safe API client wrapper over existing Axios instance"
      contains: "api-types.generated"
    - path: "apps/web/src/lib/query-client.ts"
      provides: "TanStack Query client configuration"
      contains: "QueryClient"
    - path: "apps/web/src/lib/query-keys.ts"
      provides: "Query key factory for entity-based key hierarchy"
      contains: "queryKeys"
    - path: "apps/web/src/main.tsx"
      provides: "App entry with QueryClientProvider"
      contains: "QueryClientProvider"
  key_links:
    - from: "apps/web/src/lib/api-client.ts"
      to: "apps/web/src/lib/api.ts"
      via: "imports existing axios instance"
      pattern: "import.*api"
    - from: "apps/web/src/lib/api-client.ts"
      to: "apps/web/src/lib/api-types.generated.ts"
      via: "imports generated types for type safety"
      pattern: "api-types.generated"
    - from: "apps/web/src/main.tsx"
      to: "apps/web/src/lib/query-client.ts"
      via: "imports QueryClient and wraps app"
      pattern: "QueryClientProvider"
---

<objective>
Create TanStack Query infrastructure: QueryClient configuration, type-safe API client wrapper, and query key factory.

Purpose: Establish the data layer patterns that all future UI phases (15-26) will use. Type-safe API calls ensure frontend stays in sync with backend. Query keys enable smart cache invalidation.

Output: QueryClientProvider in app, typed API client, query key hierarchy.
</objective>

<execution_context>
@/home/developer/.claude/get-shit-done/workflows/execute-plan.md
@/home/developer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@apps/web/src/main.tsx
@apps/web/src/lib/api.ts
@apps/web/src/lib/api-types.generated.ts
@apps/web/src/features/auth/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create QueryClient, query keys, and API client</name>
  <files>
    apps/web/src/lib/query-client.ts
    apps/web/src/lib/query-keys.ts
    apps/web/src/lib/api-client.ts
  </files>
  <action>
    1. Create `apps/web/src/lib/query-client.ts`:
       - Export a `queryClient` instance with sensible defaults:
         - `staleTime: 30_000` (30s default — accounts/categories change rarely)
         - `gcTime: 5 * 60_000` (5 min garbage collection)
         - `retry: 1` (retry once, but NOT on 401 — Axios interceptor handles that)
         - `refetchOnWindowFocus: true` for stale-while-revalidate behavior
       - Export a `createQueryClient()` factory for tests (fresh client per test)
       - Configure mutation defaults: no retry for mutations

    2. Create `apps/web/src/lib/query-keys.ts`:
       - Export `queryKeys` factory following TkDodo's v5 pattern:
         ```typescript
         export const queryKeys = {
           accounts: {
             all: ['accounts'] as const,
             lists: () => [...queryKeys.accounts.all, 'list'] as const,
             list: (filters?: AccountFilters) => [...queryKeys.accounts.lists(), filters] as const,
             details: () => [...queryKeys.accounts.all, 'detail'] as const,
             detail: (id: string) => [...queryKeys.accounts.details(), id] as const,
           },
           transactions: {
             all: ['transactions'] as const,
             lists: () => [...queryKeys.transactions.all, 'list'] as const,
             list: (filters?: TransactionFilters) => [...queryKeys.transactions.lists(), filters] as const,
             details: () => [...queryKeys.transactions.all, 'detail'] as const,
             detail: (id: string) => [...queryKeys.transactions.details(), id] as const,
           },
           categories: {
             all: ['categories'] as const,
             tree: () => [...queryKeys.categories.all, 'tree'] as const,
             lists: () => [...queryKeys.categories.all, 'list'] as const,
           },
           payees: {
             all: ['payees'] as const,
             lists: () => [...queryKeys.payees.all, 'list'] as const,
           },
           user: {
             profile: ['user', 'profile'] as const,
           },
         };
         ```
       - Filter types can be minimal for now (just type aliases — Phase 15+ will add real filters)

    3. Create `apps/web/src/lib/api-client.ts`:
       - Import the existing `api` axios instance from `./api`
       - Import generated types from `./api-types.generated`
       - Export typed API functions that use the generated `paths` type for endpoint matching:
         ```typescript
         // Accounts
         export async function fetchAccounts() { ... }
         export async function fetchAccount(id: string) { ... }
         export async function createAccount(data: CreateAccountRequest) { ... }
         export async function updateAccount(id: string, data: UpdateAccountRequest) { ... }
         export async function deleteAccount(id: string) { ... }

         // Transactions
         export async function fetchTransactions(accountId: string) { ... }
         export async function fetchTransaction(id: string) { ... }
         export async function createTransaction(data: CreateTransactionRequest) { ... }
         export async function updateTransaction(id: string, data: UpdateTransactionRequest) { ... }
         export async function deleteTransaction(id: string) { ... }

         // Categories
         export async function fetchCategories() { ... }
         export async function fetchCategoryTree() { ... }

         // Payees
         export async function fetchPayees() { ... }
         ```
       - Each function extracts the response `.data` (unwrap AxiosResponse)
       - Use the generated component schema types for request/response typing
       - Example: `api.get<AccountResponse>('/api/v1/accounts/' + id).then(r => r.data)`
       - Extract request/response types from generated `components['schemas']` type
       - Export type aliases for commonly used types (AccountResponse, TransactionResponse, etc.)
  </action>
  <verify>
    - `npx nx typecheck web` passes with no errors
    - All three files exist and have correct imports
    - api-client.ts references generated types from api-types.generated.ts
  </verify>
  <done>
    QueryClient configured with sensible defaults. Query key factory provides hierarchical keys for all entities. Type-safe API client wraps existing Axios instance with generated types.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire QueryClientProvider into app and add devtools</name>
  <files>
    apps/web/src/main.tsx
  </files>
  <action>
    1. Update `apps/web/src/main.tsx`:
       - Import `QueryClientProvider` from `@tanstack/react-query`
       - Import `ReactQueryDevtools` from `@tanstack/react-query-devtools`
       - Import `queryClient` from `./lib/query-client`
       - Wrap the app tree with `QueryClientProvider`:
         ```tsx
         <StrictMode>
           <QueryClientProvider client={queryClient}>
             <AuthProvider>
               <InnerApp />
             </AuthProvider>
             <ReactQueryDevtools initialIsOpen={false} />
           </QueryClientProvider>
         </StrictMode>
         ```
       - Note: QueryClientProvider OUTSIDE AuthProvider so auth context can use queries
       - ReactQueryDevtools INSIDE QueryClientProvider but OUTSIDE AuthProvider (it's a debug panel, doesn't need auth)

    2. Run all checks:
       - `npx nx typecheck web`
       - `npx nx test web`
       - `npx nx lint web`
  </action>
  <verify>
    - `npx nx typecheck web` passes
    - `npx nx test web` passes (all existing tests still work)
    - `npx nx lint web` passes
    - main.tsx imports QueryClientProvider and wraps app tree
  </verify>
  <done>
    TanStack Query is wired into the app. QueryClientProvider wraps the component tree. ReactQueryDevtools available in development.
  </done>
</task>

</tasks>

<verification>
1. `npx nx typecheck web` passes
2. `npx nx test web` passes
3. `npx nx lint web` passes
4. `apps/web/src/main.tsx` contains QueryClientProvider wrapping the app
5. `apps/web/src/lib/api-client.ts` imports from `api-types.generated`
6. `apps/web/src/lib/query-keys.ts` exports query key factory
</verification>

<success_criteria>
- QueryClientProvider wraps app with configured defaults
- ReactQueryDevtools available
- Type-safe API client uses generated OpenAPI types
- Query key hierarchy supports entity-based invalidation
- All existing tests and quality checks pass
</success_criteria>

<output>
After completion, create `.planning/phases/14-frontend-api-routing/14-02-SUMMARY.md`
</output>
