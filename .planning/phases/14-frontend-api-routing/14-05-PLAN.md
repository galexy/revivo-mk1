---
phase: 14-frontend-api-routing
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/web/e2e/smoke.spec.ts
  - apps/web/e2e/auth.setup.ts
  - apps/web/playwright.config.ts
autonomous: true

must_haves:
  truths:
    - "Playwright smoke test verifies login page loads without errors"
    - "Auth setup fixture can register and log in a test user"
    - "Authenticated smoke test verifies dashboard loads after login"
    - "e2e tests work with the auth-guarded app (not old placeholder shell)"
  artifacts:
    - path: "apps/web/e2e/smoke.spec.ts"
      provides: "Updated smoke tests for auth-guarded app"
      contains: "login"
    - path: "apps/web/e2e/auth.setup.ts"
      provides: "Playwright auth setup fixture"
      contains: "storageState"
    - path: "apps/web/playwright.config.ts"
      provides: "Updated config with auth setup project"
      contains: "setup"
  key_links:
    - from: "apps/web/e2e/auth.setup.ts"
      to: "apps/web/src/pages/LoginPage.tsx"
      via: "fills login form to authenticate"
      pattern: "fill.*email|password"
    - from: "apps/web/e2e/smoke.spec.ts"
      to: "apps/web/src/pages/DashboardPage.tsx"
      via: "navigates to dashboard after auth"
      pattern: "dashboard|Personal Finance"
---

<objective>
Update Playwright e2e smoke tests for the auth-guarded app. Replace old placeholder expectations with login page tests and add auth fixtures for authenticated test scenarios.

Purpose: The current smoke.spec.ts expects the old placeholder shell (Phase 12) but Phase 13 replaced it with auth-guarded login flow. This plan fixes the broken e2e tests and establishes auth fixtures that all future e2e tests will use.

Output: Working smoke tests, auth setup fixture, Playwright config with auth project.
</objective>

<execution_context>
@/home/developer/.claude/get-shit-done/workflows/execute-plan.md
@/home/developer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@apps/web/e2e/smoke.spec.ts
@apps/web/playwright.config.ts
@apps/web/src/routes.tsx
@apps/web/src/pages/LoginPage.tsx
@apps/web/src/pages/DashboardPage.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create auth setup fixture and update Playwright config</name>
  <files>
    apps/web/e2e/auth.setup.ts
    apps/web/playwright.config.ts
  </files>
  <action>
    1. Create `apps/web/e2e/auth.setup.ts`:
       - This is a Playwright setup project that runs before authenticated tests
       - It registers a test user (if not exists) and logs in, saving browser state
       - Use the actual UI to log in (not API shortcuts) for realistic e2e:
         ```typescript
         import { test as setup, expect } from '@playwright/test';

         const TEST_USER = {
           email: 'e2e-test@example.com',
           password: 'TestPass123!',
           displayName: 'E2E Test User',
         };

         setup('authenticate', async ({ page }) => {
           // First, try to register (will succeed first time, 202 always on duplicate)
           await page.goto('/register');
           await page.getByLabel('Email').fill(TEST_USER.email);
           await page.getByLabel('Display name').fill(TEST_USER.displayName);
           await page.getByLabel('Password').fill(TEST_USER.password);
           await page.getByRole('button', { name: /create account/i }).click();

           // Wait for registration response (either success or already exists)
           // Then navigate to login
           await page.goto('/login');

           // Log in
           await page.getByLabel('Email').fill(TEST_USER.email);
           await page.getByLabel('Password').fill(TEST_USER.password);
           await page.getByRole('button', { name: /sign in/i }).click();

           // Wait for redirect to dashboard
           await page.waitForURL('**/dashboard');
           await expect(page.getByText('Personal Finance')).toBeVisible();

           // Save signed-in state to file
           await page.context().storageState({ path: 'apps/web/e2e/.auth/user.json' });
         });
         ```
       - Note: The registration step handles the case where the user doesn't exist yet.
         If user already exists, /register returns 202 (enumeration protection) so it doesn't fail.
         The email may not be verified but the login endpoint works for unverified users in dev.
         If login requires email verification, the setup needs to call the verify endpoint directly via API.
         Check the backend: if EMAIL_NOT_VERIFIED error is returned on login, add a direct API call to
         `POST /auth/register` then manually verify via `GET /verify?token=...` or skip verification.
         Actually, check auth routes â€” in Phase 4, login returns EMAIL_NOT_VERIFIED for unverified users.
         The setup should handle this: after registration, either:
         a) Call the backend verify endpoint directly via API (the token is in Mailpit), OR
         b) Use `page.request.post()` to register, get the token somehow, OR
         c) Create the user directly via the API with auto-verification

         Simplest approach: Use page.request to:
         1. Register via API: POST /auth/register
         2. Since we can't easily get the verification token from Mailpit in Playwright,
            the test user should be pre-created or the backend should have a dev-only auto-verify.

         PRACTICAL APPROACH: Since email verification is required for login, and we can't
         easily access Mailpit from Playwright, use a two-step approach:
         1. Register via page.request.post (API call, not UI)
         2. Get the verification token by calling the Mailpit API (Mailpit has a REST API
            at http://mailpit:8025/api/v1/messages for listing emails)
         3. Extract token from email body
         4. Verify via page.goto('/verify?token=...')
         5. Then log in via UI

         OR SIMPLER: If the backend auth service allows login for unverified users in development
         mode, just skip verification. Check the login route.

         ACTUALLY, the cleanest approach that avoids all this complexity:
         The setup should FIRST check if login works. If it does (user already exists and is verified),
         skip registration. If login fails, register + verify + login.

         For the initial implementation, keep it simple:
         - Try to log in first
         - If login succeeds (dashboard loads), save state and done
         - If login fails, register via API, verify via Mailpit API, then log in
         - Store auth state for reuse across tests

    2. Update `apps/web/playwright.config.ts`:
       - Add a `setup` project that runs auth.setup.ts
       - Add `storageState` to the chromium project so all tests run authenticated
       - Add `.auth/` to the testDir ignore or add it to .gitignore
       ```typescript
       projects: [
         // Setup project: authenticate once
         { name: 'setup', testMatch: /.*\.setup\.ts/ },
         // Test project: use authenticated state
         {
           name: 'chromium',
           use: {
             ...devices['Desktop Chrome'],
             headless: true,
             storageState: 'apps/web/e2e/.auth/user.json',
             launchOptions: {
               executablePath: '/usr/bin/chromium',
               args: ['--no-sandbox', '--disable-gpu', '--disable-dev-shm-usage'],
             },
           },
           dependencies: ['setup'],
         },
       ]
       ```
       - Add to .gitignore: `apps/web/e2e/.auth/`

    3. NOTE: The setup project should NOT use storageState (it creates it).
       Only the chromium project should use the saved state.
  </action>
  <verify>
    - `apps/web/e2e/auth.setup.ts` exists
    - `apps/web/playwright.config.ts` has setup project and storageState
    - `.gitignore` includes `apps/web/e2e/.auth/`
  </verify>
  <done>
    Auth setup fixture authenticates a test user and saves browser state. Playwright config uses setup project as dependency for authenticated tests.
  </done>
</task>

<task type="auto">
  <name>Task 2: Rewrite smoke tests for auth-guarded app</name>
  <files>
    apps/web/e2e/smoke.spec.ts
  </files>
  <action>
    1. Rewrite `apps/web/e2e/smoke.spec.ts`:
       - Remove old tests that expect placeholder shell (hardcoded balances, "Quick Add Transaction", "Accounts" sidebar)
       - Add unauthenticated smoke test (runs without auth state):
         ```typescript
         test.describe('Unauthenticated', () => {
           test.use({ storageState: { cookies: [], origins: [] } });

           test('redirects to login page', async ({ page }) => {
             await page.goto('/');
             await page.waitForURL('**/login');
             await expect(page.getByRole('heading', { name: /sign in/i })).toBeVisible();
           });

           test('login page loads without errors', async ({ page }) => {
             const errors: string[] = [];
             page.on('console', (msg) => {
               if (msg.type() === 'error') errors.push(msg.text());
             });

             await page.goto('/login');
             await expect(page.getByRole('heading', { name: /sign in/i })).toBeVisible();
             await expect(page.getByLabel('Email')).toBeVisible();
             await expect(page.getByLabel('Password')).toBeVisible();
             expect(errors).toHaveLength(0);
           });
         });
         ```
       - Add authenticated smoke test (uses saved auth state from setup):
         ```typescript
         test.describe('Authenticated', () => {
           test('dashboard loads after login', async ({ page }) => {
             await page.goto('/dashboard');
             await expect(page.getByText('Personal Finance')).toBeVisible();
           });

           test('dashboard has user menu', async ({ page }) => {
             await page.goto('/dashboard');
             // UserMenu shows user initials
             await expect(page.getByRole('button')).toBeVisible();
           });
         });
         ```

    2. The tests should pass when both API backend and web frontend are running.
       Since e2e tests require running servers, verify by:
       - Starting `npx nx serve api` (background)
       - Starting `npx nx serve web` (background)
       - Running `npx nx e2e web`
       - Stopping both servers

    3. If the auth setup fails due to email verification requirements, adjust
       the auth.setup.ts to handle it (see Task 1 notes about Mailpit API).
       The key insight: in development, we may need to either:
       - Call Mailpit API to get the verification token
       - Or modify the setup to use direct API calls for registration and verification
  </action>
  <verify>
    - Smoke tests are rewritten for auth-guarded app
    - No references to old placeholder content (hardcoded balances, etc.)
    - Unauthenticated test verifies login page loads
    - Authenticated test verifies dashboard loads
    - `npx nx e2e web` passes with both servers running
  </verify>
  <done>
    Smoke tests updated for auth-guarded app. Login page smoke test works without auth. Dashboard smoke test uses saved auth state. All e2e tests pass.
  </done>
</task>

</tasks>

<verification>
1. `npx nx e2e web` passes with API + web servers running
2. Unauthenticated tests verify login page
3. Authenticated tests verify dashboard (using auth fixture)
4. No stale references to old placeholder shell
5. Auth state file properly gitignored
</verification>

<success_criteria>
- Playwright smoke tests work with auth-guarded app
- Auth setup fixture creates/logs in test user
- Unauthenticated tests verify login page loads
- Authenticated tests verify dashboard loads after login
- e2e test infrastructure ready for Phase 15+ feature tests
</success_criteria>

<output>
After completion, create `.planning/phases/14-frontend-api-routing/14-05-SUMMARY.md`
</output>
