# Phase 4.1: Test Schema Parity - Context

**Gathered:** 2026-02-05
**Status:** Ready for planning

<domain>
## Phase Boundary

Eliminate schema drift between SQLAlchemy table metadata and Alembic migrations. Replace all 7 hand-written migrations with a single autogenerated migration from current SQLAlchemy metadata (fresh start, no data migrations needed). Add drift detection and prevention so the two paths never silently diverge. Verify all previous phase behavior still works.

</domain>

<decisions>
## Implementation Decisions

### Root cause analysis
- All 7 migrations in the project were hand-written (none autogenerated)
- Migration 006 (auth tables) had a circular FK bootstrap that required multi-step DDL (nullable → data backfill → alter NOT NULL → add FKs)
- The SQLAlchemy `tables.py` defined `households.owner_id` as a plain column (no `ForeignKey()` declaration) while migration 006 created the FK constraint — tests ran without the FK, production had it
- `tables.py` included `email_verified` column that had no corresponding migration — tests had the column, production didn't
- Migration 007 removed the circular FK (replaced `owner_id` with `role` column), resolving the immediate drift, but the structural problem remained

### Migration rework (fresh start)
All 7 existing migrations (001-007) were hand-written, which is the root cause of drift. We are replacing them entirely with autogenerated migrations. Since this is a development-stage project with no production data to preserve, there is no need for data migrations — the database starts empty.

**Before rework:** Capture a `pg_dump --schema-only` snapshot of the schema produced by the current hand-written migrations (`alembic upgrade head` on a clean database). Save this to a file in the phase directory so it can be diffed later.

**The rework itself:** Delete all 7 migration files. Reset Alembic state (drop `alembic_version` table or equivalent). Then use `alembic revision --autogenerate` to generate fresh migration(s) from the current `tables.py` metadata. The SQLAlchemy metadata in `tables.py` is the source of truth — the autogenerated migrations must produce whatever schema `tables.py` describes.

**After rework:** Apply the new autogenerated migration(s) to a clean database, then capture another `pg_dump --schema-only` snapshot. Diff the before and after snapshots. Differences are expected where the old hand-written migrations had drift (e.g., the `owner_id` circular FK that no longer exists in `tables.py`, the missing `email_verified` column). But any unexpected differences indicate a problem with either `tables.py` or the autogenerate output and must be investigated.

### Migration workflow going forward (autogenerate-first policy)
After the rework, all future schema changes must follow the autogenerate-first workflow. The SQLAlchemy `tables.py` metadata is always the source of truth for schema structure. The workflow is:

1. Make the schema change in `tables.py` first (add/modify columns, tables, indexes, constraints)
2. Run `alembic revision --autogenerate -m "description"` to generate a migration from the metadata diff
3. Review the generated migration. Hand-edit ONLY if the migration needs data backfill logic (e.g., populating a new NOT NULL column from existing data). Never hand-write DDL operations — if autogenerate didn't produce the right DDL, the fix is in `tables.py`, not in the migration file
4. Run `alembic check` to confirm no remaining drift between metadata and migration chain

### Drift detection
Add an integration test that programmatically checks whether the SQLAlchemy metadata and the Alembic migration chain describe the same schema. If someone edits `tables.py` without generating a migration (or vice versa), this test fails. It runs as part of the normal pytest test suite — not as a CI-only step or pre-commit hook — so developers see the failure immediately when running tests locally.

### Test schema creation
Integration tests continue using `metadata.create_all()` for speed. This is safe because the drift detection test (above) guarantees that `create_all()` produces the same schema as `alembic upgrade head`. If those two ever diverge, the drift test fails before any other test can pass against a wrong schema. There is no need to switch the test suite to run Alembic migrations — that would add latency to every test run for no additional safety given the drift guard.

### Knowledge encoding (three reinforcement layers)
The autogenerate-first workflow and migration safety rules need to be encoded so that future Claude agents (and the user) don't repeat the same mistakes. Three layers of reinforcement:

1. **CLAUDE.md rules** — CLAUDE.md is always loaded by Claude Code at the start of every session. Add concise, actionable rules about the autogenerate-first workflow and the requirement to never hand-write DDL. These rules are always visible and override any default behavior.

2. **SKILL.md procedure** — Create a non-interactive skill file that codifies the complete safe schema change procedure as a step-by-step reference. This is NOT a slash command — it's a document that agents read and follow when a plan involves schema changes. CLAUDE.md should reference it so agents know where to find the detailed procedure.

3. **PROJECT.md rules** — Add key decisions to PROJECT.md so that GSD planning and execution agents (which read PROJECT.md for project context) know to follow the autogenerate-first workflow when creating or executing plans that involve database schema changes.

### Verification (planning notes)
The migration rework changes the schema creation path but must not change application behavior. Verification happens in two ways:

**1. Schema comparison (during execution):** The before/after `pg_dump` diff described above in "Migration rework" confirms the autogenerated migration produces an equivalent schema to the old hand-written migrations.

**2. UAT regression (at verification stage, not during planning):** After the migration rework is complete and all existing tests pass, gather the success criteria from ROADMAP.md for phases 1 through 4 and the existing integration test suites. Run them all to confirm that every previously-verified behavior still works. This is a regression check — the migration rework should be invisible to application behavior. Do not gather or enumerate these UATs during planning; do it at verification time when the rework is done and you can actually run them.

### Claude's Discretion
- Exact implementation of the drift detection test (alembic check vs autogenerate diff comparison)
- SKILL.md file location and structure
- How to surface the skill reference to GSD agents (PROJECT.md section vs CLAUDE.md reference)

</decisions>

<specifics>
## Specific Ideas

- The skill should encode: "edit tables.py first, then autogenerate, then hand-edit only data migration, then verify with alembic check"
- The drift detection test should catch both directions: columns in metadata but not migrations, and constraints in migrations but not metadata
- CLAUDE.md rules should be concise enough to be always-visible, not buried in paragraphs

</specifics>

<deferred>
## Deferred Ideas

None — discussion stayed within phase scope

</deferred>

---

*Phase: 04.1-test-schema-parity*
*Context gathered: 2026-02-05*
