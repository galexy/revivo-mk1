# Phase 4.1: Test Schema Parity - Research

**Researched:** 2026-02-05
**Domain:** Alembic migration management, SQLAlchemy metadata/schema parity, drift detection
**Confidence:** HIGH

## Summary

This phase eliminates schema drift between SQLAlchemy table metadata (`tables.py`) and Alembic migrations by replacing all 7 hand-written migrations with autogenerated ones, adding a drift detection integration test, and encoding the autogenerate-first workflow into project documentation.

The standard approach for this type of problem is well-established in the SQLAlchemy/Alembic ecosystem: use `alembic revision --autogenerate` from `tables.py` as source of truth, verify with `alembic check`, and guard parity with a test that uses `compare_metadata()`. The tooling is mature (Alembic 1.18.3, SQLAlchemy 2.0.46) and all APIs needed are available in the installed versions.

**Primary recommendation:** Delete all 7 hand-written migrations, fix `env.py` to import `tables.py` (critical bug), run `alembic revision --autogenerate`, add drift detection test using `compare_metadata()`, encode autogenerate-first workflow in CLAUDE.md/SKILL.md/PROJECT.md.

## Standard Stack

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| Alembic | 1.18.3 | Migration management, autogenerate, drift detection | Already installed; `alembic check` (v1.9+) and `compare_metadata()` are the standard APIs for drift detection |
| SQLAlchemy | 2.0.46 | ORM metadata, `MetaData.create_all()`, schema inspection | Already installed; metadata is source of truth for schema |
| psycopg2 | 2.9.11 | Sync PostgreSQL driver for migrations | Already installed; used via `DATABASE_URL_SYNC` |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| pytest | (installed) | Drift detection test runner | Run drift test as part of integration test suite |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| `compare_metadata()` in test | `alembic check` CLI in test | CLI harder to integrate into pytest; programmatic API is cleaner |
| `compare_metadata()` in test | `pg_dump --schema-only` diff | `pg_dump` not available in devcontainer; would need installation |
| Keep `metadata.create_all()` for tests | Switch tests to `alembic upgrade head` | Adds latency to every test run; unnecessary given drift guard test |

**Installation:** No new packages needed. All tools are already installed.

## Architecture Patterns

### Current Project Structure (relevant files)
```
alembic/
  env.py                  # Alembic environment config (NEEDS FIX)
  versions/               # Migration files (7 hand-written, to be replaced)
    001_initial_schema.py
    002_create_accounts_table.py
    003_add_transaction_tables.py
    004_add_category_type.py
    005_add_split_identity.py
    006_add_auth_tables.py
    007_replace_owner_with_role.py
  script.py.mako          # Migration file template (NEEDS UPDATE)
src/adapters/persistence/orm/
  base.py                 # MetaData + naming convention
  tables.py               # Table definitions (SOURCE OF TRUTH)
  types.py                # Custom TypeDecorators
tests/integration/
  conftest.py             # Uses metadata.create_all() (STAYS)
  test_database.py        # Basic table existence tests
```

### Pattern 1: Autogenerate-First Migration Workflow
**What:** All schema changes start in `tables.py`, then `alembic revision --autogenerate` generates the migration.
**When to use:** Every time a schema change is needed.
**Steps:**
1. Edit `tables.py` (add/modify columns, tables, indexes, constraints)
2. Run `alembic revision --autogenerate -m "description"`
3. Review generated migration. Hand-edit ONLY for data backfill logic.
4. Run `alembic check` to confirm no remaining drift.
5. Run `alembic upgrade head` against real DB.

### Pattern 2: Drift Detection via compare_metadata()
**What:** Integration test that programmatically verifies migrations and metadata describe the same schema.
**When to use:** Runs as part of integration test suite on every `pytest` invocation.
**How it works:**
1. Apply all migrations to a clean database (`alembic upgrade head`)
2. Use `compare_metadata(migration_context, metadata)` to diff the DB schema against SQLAlchemy metadata
3. If diff list is non-empty, test fails with details about what diverged

```python
# Source: Alembic 1.18.3 official API (verified in installed version)
from alembic.autogenerate import compare_metadata
from alembic.migration import MigrationContext
from sqlalchemy import create_engine

from src.adapters.persistence.orm.base import metadata
from src.adapters.persistence.orm import tables  # registers tables with metadata

engine = create_engine(database_url)
with engine.connect() as conn:
    mc = MigrationContext.configure(conn)
    diffs = compare_metadata(mc, metadata)
    assert diffs == [], f"Schema drift detected: {diffs}"
```

### Pattern 3: Fresh Migration Rework (One-Time)
**What:** Delete all existing migrations, reset Alembic state, autogenerate from current `tables.py`.
**When to use:** One-time operation during this phase.
**Steps:**
1. Capture pre-rework schema snapshot (via SQLAlchemy inspection, since `pg_dump` is unavailable)
2. Delete all 7 migration files from `alembic/versions/`
3. Drop `alembic_version` table (or run `alembic stamp base`)
4. Fix `env.py` to import `tables.py` (required for autogenerate)
5. Run `alembic revision --autogenerate -m "initial schema"`
6. Review and clean up generated migration
7. Apply migration to clean database
8. Compare post-rework schema against pre-rework snapshot

### Anti-Patterns to Avoid
- **Hand-writing DDL in migrations:** If autogenerate doesn't produce the right DDL, fix `tables.py`, not the migration.
- **Running `alembic check` without importing `tables.py` in `env.py`:** Produces false results (empty metadata).
- **Using `metadata.create_all()` as the only schema verification:** Bypasses Alembic entirely; schema can drift without detection.
- **Adding server_defaults in migrations that don't exist in `tables.py`:** Creates silent drift between test and production schemas.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Schema comparison | Custom SQL diff logic | `alembic.autogenerate.compare_metadata()` | Handles all column types, indexes, FKs, naming conventions; maintained by Alembic team |
| Migration generation | Hand-written `op.create_table()` calls | `alembic revision --autogenerate` | Automatic from metadata, consistent naming, no typo risk |
| Drift detection CI | Custom bash scripts comparing schemas | `alembic check` CLI or `compare_metadata()` in test | Standard API, well-tested, community-supported |
| Schema snapshot | `pg_dump --schema-only` | SQLAlchemy `inspect()` + JSON serialization | `pg_dump` not available in devcontainer; inspect() gives equivalent structural info |

**Key insight:** Alembic's autogenerate tooling handles the entire drift detection lifecycle. Every piece of this phase uses existing Alembic/SQLAlchemy APIs -- no custom schema comparison logic is needed.

## Common Pitfalls

### Pitfall 1: env.py Missing tables.py Import (CRITICAL - EXISTING BUG)
**What goes wrong:** `alembic check` and `alembic revision --autogenerate` see an empty metadata (no tables) because `env.py` only imports the `MetaData` object from `base.py` but never imports `tables.py` which registers Table objects with that MetaData.
**Why it happens:** `base.py` creates the MetaData instance, `tables.py` registers tables on import. If `tables.py` isn't imported, MetaData stays empty.
**How to avoid:** Add `import src.adapters.persistence.orm.tables  # noqa: F401` to `env.py`. Alternatively, change the import to `from src.adapters.persistence.orm.tables import metadata` (but tables.py doesn't re-export metadata).
**Warning signs:** `alembic check` reports all tables should be removed. `alembic revision --autogenerate` generates a migration that drops all tables.
**Verified:** Tested programmatically -- importing only `base.py` yields 0 tables in metadata; importing `tables.py` yields 10 tables.

### Pitfall 2: Custom TypeDecorators in Autogenerated Migrations
**What goes wrong:** Autogenerate emits custom type names like `src.adapters.persistence.orm.types.UserIdType(length=36)` instead of `sa.String(length=36)`. Migration files won't run unless they import these custom types.
**Why it happens:** SQLAlchemy's autogenerate renders the actual column type, not the impl type. Custom TypeDecorators are rendered with their full module path.
**How to avoid:** Configure `env.py` with `user_module_prefix` or add custom type imports to `script.py.mako` template. Alternatively, use `render_item` callback to render TypeDecorators as their impl type.
**Warning signs:** Generated migration files fail with `ImportError` or `NameError` when applied.
**Verified:** Tested autogenerate output -- it uses 12 custom type references (all TypeDecorators from `types.py`).

### Pitfall 3: compare_metadata Does Not Detect Constraint Naming Differences
**What goes wrong:** `compare_metadata()` returns 0 diffs even when FK constraint names differ between DB and metadata (e.g., `fk_accounts_household_id` vs `fk_accounts_household_id_households`).
**Why it happens:** Autogenerate compares schema structure (tables, columns, types, FKs by column), not constraint names. This is by design -- constraint names are metadata, not schema.
**How to avoid:** The fresh migration rework resolves this. New autogenerated migrations will use the naming convention from `base.py`, producing correct names. After rework, `compare_metadata()` on a clean DB will correctly detect structural drift.
**Warning signs:** FK constraint names in production DB differ from those defined by the naming convention in `base.py`.
**Verified:** Found exactly 5 FK naming mismatches -- all `household_id` FKs from migration 006 which used hand-written names without the `_<referred_table>` suffix.

### Pitfall 4: Alembic revision IDs (Simple vs Hash)
**What goes wrong:** Existing migrations use simple sequential IDs (`001`, `002`, etc.) which could collide with autogenerated hash-based IDs.
**Why it happens:** Hand-written migrations used simple numbering. Alembic's `--autogenerate` produces random hash-based revision IDs by default.
**How to avoid:** Since we're deleting all existing migrations, this isn't a collision risk. But the new autogenerated migration will have a hash ID. Consider whether to use `--rev-id` to assign a clean ID.
**Warning signs:** Alembic version table contains unexpected revision IDs.

### Pitfall 5: Test Database vs Main Database Schema Drift
**What goes wrong:** Integration tests run against `finance_test` using `metadata.create_all()`, while the main app runs against `personal_finance` using Alembic migrations. If the drift detection test runs against `personal_finance` but other tests use `finance_test`, you get false confidence.
**Why it happens:** Different databases can have different schemas if not both kept in sync.
**How to avoid:** The drift detection test should run `alembic upgrade head` on a clean test database, then compare. Existing integration tests continue using `metadata.create_all()` on `finance_test` for speed. The drift test guards parity between the two approaches.
**Warning signs:** Drift test passes but integration tests fail, or vice versa.

## Code Examples

### Example 1: Fixed env.py (import tables for autogenerate)
```python
# alembic/env.py - critical fix
import os
from logging.config import fileConfig

from alembic import context
from sqlalchemy import engine_from_config, pool

# Import metadata for autogenerate support
from src.adapters.persistence.orm.base import metadata

# CRITICAL: Import tables module to register Table objects with metadata
# Without this, autogenerate sees an empty metadata (0 tables)
import src.adapters.persistence.orm.tables  # noqa: F401

# ... rest of env.py unchanged
target_metadata = metadata
```

### Example 2: env.py configure() with TypeDecorator handling
```python
# In run_migrations_online():
context.configure(
    connection=connection,
    target_metadata=target_metadata,
    # Render custom TypeDecorators with a prefix for cleaner imports
    user_module_prefix="types.",
    # Enable type comparison for more thorough autogenerate
    compare_type=True,
)
```

### Example 3: Updated script.py.mako for custom type imports
```mako
"""${message}

Revision ID: ${up_revision}
Revises: ${down_revision | comma,n}
Create Date: ${create_date}
"""
from typing import Sequence, Union
from alembic import op
import sqlalchemy as sa
from src.adapters.persistence.orm import types  # Custom TypeDecorators
${imports if imports else ""}
```

### Example 4: Drift Detection Integration Test
```python
"""Test that SQLAlchemy metadata and Alembic migrations produce the same schema."""

import pytest
from alembic.autogenerate import compare_metadata
from alembic.config import Config
from alembic import command
from alembic.migration import MigrationContext
from sqlalchemy import create_engine, text

from src.adapters.persistence.orm.base import metadata
from src.adapters.persistence.orm import tables  # noqa: F401


@pytest.fixture(scope="module")
def migration_engine(database_url):
    """Create a clean database and apply all migrations."""
    engine = create_engine(database_url)

    # Clean slate
    with engine.connect() as conn:
        conn.execute(text("DROP SCHEMA public CASCADE"))
        conn.execute(text("CREATE SCHEMA public"))
        conn.commit()

    # Run all migrations
    cfg = Config("alembic.ini")
    cfg.set_main_option("sqlalchemy.url", str(engine.url))
    command.upgrade(cfg, "head")

    yield engine

    # Cleanup
    with engine.connect() as conn:
        conn.execute(text("DROP SCHEMA public CASCADE"))
        conn.execute(text("CREATE SCHEMA public"))
        conn.commit()


def test_migrations_match_metadata(migration_engine):
    """Verify Alembic migrations produce same schema as SQLAlchemy metadata."""
    with migration_engine.connect() as conn:
        mc = MigrationContext.configure(conn)
        diffs = compare_metadata(mc, metadata)

        if diffs:
            diff_descriptions = []
            for diff in diffs:
                if isinstance(diff, tuple):
                    diff_descriptions.append(f"{diff[0]}: {diff[1:]}")
                elif isinstance(diff, list):
                    for sub in diff:
                        diff_descriptions.append(f"{sub[0]}: {sub[1:]}")

            pytest.fail(
                f"Schema drift detected between migrations and metadata:\n"
                + "\n".join(diff_descriptions)
            )
```

### Example 5: Capturing Schema Snapshot via SQLAlchemy Inspection
```python
"""pg_dump is not available in devcontainer. Use SQLAlchemy inspect() instead."""

from sqlalchemy import create_engine, inspect
import json

def capture_schema_snapshot(engine) -> dict:
    """Capture current database schema as a dict for comparison."""
    insp = inspect(engine)
    snapshot = {}
    for table_name in sorted(insp.get_table_names()):
        if table_name == "alembic_version":
            continue
        snapshot[table_name] = {
            "columns": [
                {"name": c["name"], "type": str(c["type"]), "nullable": c["nullable"]}
                for c in insp.get_columns(table_name)
            ],
            "pk": insp.get_pk_constraint(table_name),
            "fks": sorted(
                [{"name": fk["name"], "referred_table": fk["referred_table"]}
                 for fk in insp.get_foreign_keys(table_name)],
                key=lambda x: x["name"]
            ),
            "indexes": sorted(
                [{"name": idx["name"], "unique": idx["unique"]}
                 for idx in insp.get_indexes(table_name)],
                key=lambda x: x["name"]
            ),
        }
    return snapshot
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Hand-write all DDL in migrations | `alembic revision --autogenerate` from metadata | Alembic 0.7+ (2014), matured significantly in 1.x | Eliminates hand-writing errors, enforces parity |
| No drift detection | `alembic check` CLI command | Alembic 1.9.0 (2022) | One-command verification of metadata vs DB parity |
| Compare schemas with pg_dump | `compare_metadata()` programmatic API | Available since Alembic 0.7+ | Works without pg_dump, integrates with pytest |
| TypeDecorators invisible to autogenerate | Full TypeDecorator rendering with `user_module_prefix` | SQLAlchemy 1.4+ / Alembic improvements | Custom types properly reflected in migrations |

## Specific Findings for This Project

### Existing Drift Inventory (5 FK naming mismatches)

All caused by hand-written FK names in migration 006 that didn't follow the naming convention:

| Table | DB FK Name (from migration) | Metadata FK Name (from convention) |
|-------|---------------------------|-----------------------------------|
| accounts | `fk_accounts_household_id` | `fk_accounts_household_id_households` |
| categories | `fk_categories_household_id` | `fk_categories_household_id_households` |
| payees | `fk_payees_household_id` | `fk_payees_household_id_households` |
| transactions | `fk_transactions_household_id` | `fk_transactions_household_id_households` |
| users | `fk_users_household_id` | `fk_users_household_id_households` |

These are naming-only mismatches (structural schema is identical). They will be resolved by the fresh migration rework since autogenerate follows the naming convention.

### Database Environment
- Main DB: `personal_finance` (migration target, `alembic_version` = 007)
- Test DB: `finance_test` (empty, used by integration tests with `metadata.create_all()`)
- Both on PostgreSQL 16 via Docker Compose
- `pg_dump` NOT available in devcontainer (no `postgresql-client` package, can't install)
- Schema comparison must use SQLAlchemy `inspect()` API or `compare_metadata()` instead

### Custom TypeDecorators (12 total)
All defined in `src/adapters/persistence/orm/types.py`, all have `impl = String`:
- EntityId types: `AccountIdType`, `UserIdType`, `HouseholdIdType`, `CategoryIdType`, `PayeeIdType`, `TransactionIdType`, `SplitIdType`
- Enum types: `AccountTypeEnum`, `AccountStatusEnum`, `AccountSubtypeEnum`, `TransactionStatusEnum`, `TransactionSourceEnum`

Autogenerate renders these as `src.adapters.persistence.orm.types.TypeName(length=N)` by default. The migration template and env.py need updating to handle this.

### Current env.py Bug
Line 17 imports `metadata` from `base.py` but never imports `tables.py`. This means:
- `alembic check` sees empty metadata (0 tables), reports false "remove all" diffs
- `alembic revision --autogenerate` would generate a migration that drops everything
- This MUST be fixed before any autogenerate operation

### Test Infrastructure
- `tests/integration/conftest.py`: Session-scoped `setup_database` fixture uses `metadata.create_all(engine)` + `metadata.drop_all(engine)`
- Per-test isolation via transactional rollback (connection.begin() / rollback)
- Test DB URL: `TEST_DATABASE_URL` env var, defaults to `postgresql://postgres:postgres@postgres:5432/finance_test`
- 407 total tests (152 integration + 255 unit) - all must continue passing

## Open Questions

1. **TypeDecorator rendering strategy**
   - What we know: Autogenerate renders full module paths for custom types. Can be controlled via `user_module_prefix` or `render_item` callback.
   - What's unclear: Whether to render as custom types (explicit, needs imports) or as impl types (sa.String, simpler but loses domain semantics).
   - Recommendation: Use custom types with `user_module_prefix="types."` and add import to `script.py.mako`. This preserves domain intent and is the standard Alembic approach. The planner has discretion here (CONTEXT.md listed this as Claude's discretion).

2. **SKILL.md file location**
   - What we know: No existing skills directory in `.claude/`. CONTEXT.md says "non-interactive skill file" referenced from CLAUDE.md.
   - What's unclear: Best directory location within the project structure.
   - Recommendation: Create at `.claude/skills/safe-schema-change.md` (or similar path that GSD agents can find via CLAUDE.md reference). Planner has discretion on exact location.

3. **Drift test scope (module vs session)**
   - What we know: The drift test needs a clean DB with migrations applied. This is expensive (DROP/CREATE schema + alembic upgrade head). Running it per-test is wasteful.
   - What's unclear: Whether to scope it as module, session, or separate test file.
   - Recommendation: Separate test file (`tests/integration/test_schema_parity.py`) with module-scoped fixture. Runs once per test session. Does not interfere with other integration tests that use `metadata.create_all()`.

## Sources

### Primary (HIGH confidence)
- **Alembic 1.18.3** (installed) - `compare_metadata()`, `produce_migrations()`, `command.check()` APIs verified by reading source code and running programmatically
- **SQLAlchemy 2.0.46** (installed) - `MetaData`, `inspect()`, `create_engine()` APIs verified by direct usage
- **Project source code** - All findings verified by reading actual files and running Python against the live databases

### Secondary (MEDIUM confidence)
- Alembic documentation on `user_module_prefix` and `render_item` - verified exists in installed version's function signatures

### Tertiary (LOW confidence)
- None. All findings verified against installed code and running databases.

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - all tools already installed and verified
- Architecture: HIGH - patterns verified by running code against live DBs
- Pitfalls: HIGH - all 5 pitfalls verified by direct experimentation (ran compare_metadata, checked env.py import behavior, inspected DB constraint names)

**Research date:** 2026-02-05
**Valid until:** Stable domain, no expiration concern. Alembic/SQLAlchemy APIs are mature and unlikely to change.
