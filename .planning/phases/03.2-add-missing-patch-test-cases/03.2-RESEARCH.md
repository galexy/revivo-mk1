# Phase 3.2: Add Missing PATCH Test Cases - Research

**Researched:** 2026-02-02
**Domain:** Integration testing for PATCH /transactions/{id} endpoint
**Confidence:** HIGH

## Summary

This research investigates the test coverage requirements for Phase 3.2, which focuses on adding comprehensive PATCH endpoint tests for split transaction modifications. The goal is to fill test gaps identified in the 03.1-CONTEXT.md specification.

Phase 3.1 successfully implemented split identity (SplitId), source_split_id for mirrors, and validation improvements. However, integration tests for many PATCH edge cases were not added. The 03.1-CONTEXT.md document specifies 21 distinct integration test scenarios for PATCH operations, of which only 4-5 are currently covered.

**Primary recommendation:** Add integration tests in `tests/integration/test_transaction_api.py` following the existing test patterns. Group tests into a new `TestPatchSplitModifications` class covering the M1-M6 modification sub-cases and split addition/removal scenarios.

## Standard Stack

This is a test-only phase. No new libraries required.

### Core

| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| pytest | existing | Test framework | Already used throughout codebase |
| FastAPI TestClient | existing | HTTP testing | Already used in test_transaction_api.py |

### Supporting

| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| pytest-subtests | if needed | Test parameterization | For similar tests with different inputs (optional) |

### Installation

No new packages required.

```bash
# No new installations needed
```

## Architecture Patterns

### Recommended Test File Structure

Tests should be added to the existing file:

```
tests/
└── integration/
    └── test_transaction_api.py  # Add new test class(es) here
```

### Pattern 1: Test Class Organization

**What:** Group related tests by feature area into separate test classes.
**When to use:** When adding multiple tests for a specific feature like PATCH modifications.
**Example:**
```python
# Already exists:
class TestTransactionAPI:
    """Core transaction CRUD tests."""

class TestTransactionValidationErrors:
    """Tests for proper 400/422 responses on validation errors."""

class TestSplitIdentity:
    """Tests for split ID persistence and PATCH semantics."""

# ADD:
class TestPatchSplitModifications:
    """Tests for PATCH modification sub-cases (M1-M6)."""

class TestPatchSplitAddRemove:
    """Tests for adding and removing splits via PATCH."""

class TestPatchValidationErrors:
    """Tests for PATCH-specific validation errors."""
```

### Pattern 2: Test Fixture Reuse

**What:** Leverage existing fixtures (client, test_account, test_category) for test setup.
**When to use:** All new tests.
**Example:**
```python
def test_patch_category_split_amount_change(
    self, client: TestClient, test_account: JsonDict, test_category: JsonDict
) -> None:
    """PATCH changing amount on category split (M1)."""
    # Create initial transaction
    create_response = client.post(
        "/api/v1/transactions",
        json={...},
    )
    txn_id = create_response.json()["id"]
    split_id = create_response.json()["splits"][0]["id"]

    # PATCH to update split amount
    patch_response = client.patch(
        f"/api/v1/transactions/{txn_id}",
        json={
            "amount": {"amount": "-150.00", "currency": "USD"},
            "splits": [
                {
                    "id": split_id,
                    "amount": {"amount": "-150.00", "currency": "USD"},
                    "category_id": test_category["id"],
                }
            ],
        },
    )
    assert patch_response.status_code == 200
    # Verify amount changed, split ID preserved
```

### Pattern 3: Mirror Verification

**What:** After PATCH operations involving transfers, verify mirror state in destination account.
**When to use:** Any test involving transfer splits.
**Example:**
```python
# After PATCH, verify mirrors
savings_txns = client.get(f"/api/v1/transactions?account_id={savings['id']}").json()
assert len(savings_txns["transactions"]) == expected_mirror_count
mirror = savings_txns["transactions"][0]
assert mirror["is_mirror"] is True
assert Decimal(mirror["amount"]["amount"]) == expected_mirror_amount
```

### Anti-Patterns to Avoid

- **Hardcoding IDs:** Always use IDs returned from API responses, never hardcode split/transaction IDs.
- **Not verifying mirror state:** Always verify mirror transactions after transfer-related PATCH operations.
- **Testing multiple behaviors per test:** Keep tests focused on one modification scenario each.

## Don't Hand-Roll

This phase is test-only. No custom solutions needed.

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Test HTTP client | Custom requests | FastAPI TestClient | Integrated with app, handles cookies/sessions |
| JSON comparison | Manual dict comparison | pytest assertions | Better error messages |

## Common Pitfalls

### Pitfall 1: Forgetting to Include Amount with Splits

**What goes wrong:** PATCH request includes splits but not amount, gets 400 error.
**Why it happens:** The PATCH endpoint requires `amount` whenever `splits` is provided.
**How to avoid:** Always include both `amount` and `splits` in PATCH requests that modify splits.
**Warning signs:** Tests failing with "amount is required when updating splits" error.

### Pitfall 2: Not Verifying Split ID Preservation

**What goes wrong:** Test passes but split IDs changed unexpectedly.
**Why it happens:** If split ID is omitted from PATCH, server generates a new one.
**How to avoid:** Always include split `id` in PATCH request and verify it in response.
**Warning signs:** Split IDs differ between create and PATCH responses.

### Pitfall 3: Mirror Account Contamination

**What goes wrong:** Tests interfere with each other due to shared accounts having multiple mirrors.
**Why it happens:** Using same destination account across multiple transfer tests.
**How to avoid:** Create fresh accounts per test OR filter results carefully.
**Warning signs:** Test passes in isolation but fails when run with other tests.

### Pitfall 4: Not Cleaning Up After Failed Tests

**What goes wrong:** Database accumulates test data, affecting subsequent tests.
**Why it happens:** Transaction rollback only works when tests complete normally.
**How to avoid:** Tests in test_transaction_api.py use module-scoped setup; create unique entities per test.
**Warning signs:** Flaky tests that fail intermittently.

## Code Examples

### Creating a Transaction for Testing

```python
def test_example(self, client: TestClient, test_account: JsonDict, test_category: JsonDict) -> None:
    """Example test structure."""
    # ARRANGE: Create transaction
    create_response = client.post(
        "/api/v1/transactions",
        json={
            "account_id": test_account["id"],
            "effective_date": date.today().isoformat(),
            "amount": {"amount": "-100.00", "currency": "USD"},
            "splits": [
                {
                    "amount": {"amount": "-100.00", "currency": "USD"},
                    "category_id": test_category["id"],
                }
            ],
        },
    )
    assert create_response.status_code == 201
    txn = create_response.json()
    txn_id = txn["id"]
    split_id = txn["splits"][0]["id"]

    # ACT: PATCH the transaction
    patch_response = client.patch(
        f"/api/v1/transactions/{txn_id}",
        json={...},
    )

    # ASSERT: Verify expected outcome
    assert patch_response.status_code == expected_status
```

### Transfer with Mirror Verification

```python
def test_patch_transfer_destination_change(
    self, client: TestClient, test_account: JsonDict
) -> None:
    """M4: Transfer destination changed - old mirror deleted, new created."""
    # Create two destination accounts
    savings1 = client.post(
        "/api/v1/accounts/savings",
        json={"name": "Savings1", "opening_balance": {"amount": "0.00", "currency": "USD"}},
    ).json()
    savings2 = client.post(
        "/api/v1/accounts/savings",
        json={"name": "Savings2", "opening_balance": {"amount": "0.00", "currency": "USD"}},
    ).json()

    # Create transfer to savings1
    source = client.post(
        "/api/v1/transactions",
        json={
            "account_id": test_account["id"],
            "effective_date": date.today().isoformat(),
            "amount": {"amount": "-500.00", "currency": "USD"},
            "splits": [
                {
                    "amount": {"amount": "-500.00", "currency": "USD"},
                    "transfer_account_id": savings1["id"],
                }
            ],
        },
    ).json()
    split_id = source["splits"][0]["id"]

    # Verify mirror in savings1
    s1_txns = client.get(f"/api/v1/transactions?account_id={savings1['id']}").json()
    assert len(s1_txns["transactions"]) == 1
    old_mirror_id = s1_txns["transactions"][0]["id"]

    # PATCH to change destination to savings2
    client.patch(
        f"/api/v1/transactions/{source['id']}",
        json={
            "amount": {"amount": "-500.00", "currency": "USD"},
            "splits": [
                {
                    "id": split_id,
                    "amount": {"amount": "-500.00", "currency": "USD"},
                    "transfer_account_id": savings2["id"],
                }
            ],
        },
    )

    # Verify old mirror deleted
    s1_txns_after = client.get(f"/api/v1/transactions?account_id={savings1['id']}").json()
    assert len(s1_txns_after["transactions"]) == 0

    # Verify new mirror created in savings2
    s2_txns = client.get(f"/api/v1/transactions?account_id={savings2['id']}").json()
    assert len(s2_txns["transactions"]) == 1
    assert s2_txns["transactions"][0]["is_mirror"] is True
    assert Decimal(s2_txns["transactions"][0]["amount"]["amount"]) == Decimal("500.00")
```

## Test Coverage Gap Analysis

### Current Coverage (from existing tests)

| Test | Coverage | Location |
|------|----------|----------|
| PATCH with split ID preserves ID | YES | TestSplitIdentity.test_patch_with_split_id_updates_specific_split |
| Mirror has source_split_id | YES | TestSplitIdentity.test_mirror_transaction_has_source_split_id |
| Cannot PATCH mirror directly | YES | TestTransactionAPI.test_cannot_patch_mirror_directly |
| Transfer amount update syncs mirror | YES | TestTransactionAPI.test_update_transfer_syncs_mirror |
| Invalid split ID in PATCH | NO | Not tested |
| Split with neither category nor transfer | NO | Not tested (only POST tested) |
| Split with both category and transfer | PARTIAL | Only POST tested |
| Empty string category_id | YES | TestTransactionValidationErrors.test_empty_string_category_id_returns_422 (POST only) |

### Required Tests (from 03.1-CONTEXT.md)

**Modification Sub-Cases (M1-M6):**

| Case | Description | Current Status | Priority |
|------|-------------|----------------|----------|
| M1 | Amount changed (category split) | NOT TESTED | HIGH |
| M2 | Amount changed (transfer split) - verify mirror sync | PARTIAL (test_update_transfer_syncs_mirror) | MEDIUM |
| M3 | Category changed | NOT TESTED | HIGH |
| M4 | Transfer destination changed - old mirror deleted, new created | NOT TESTED | HIGH |
| M5 | Category to Transfer conversion | NOT TESTED | HIGH |
| M6 | Transfer to Category conversion | NOT TESTED | HIGH |

**Split Addition/Removal:**

| Scenario | Current Status | Priority |
|----------|----------------|----------|
| All splits match, no changes | NOT TESTED | MEDIUM |
| Some splits removed (category only) | NOT TESTED | HIGH |
| Some splits removed (transfer) - verify mirrors deleted | NOT TESTED | HIGH |
| New splits added (category) | NOT TESTED | HIGH |
| New splits added (transfer) - verify mirrors created | NOT TESTED | HIGH |
| Mixed: some updated, some removed, some added | NOT TESTED | HIGH |

**Validation Errors (PATCH-specific):**

| Error Case | Current Status | Priority |
|------------|----------------|----------|
| Invalid split ID in PATCH returns 400 | NOT TESTED | HIGH |
| Split with neither category nor transfer returns 400 | NOT TESTED (POST version exists) | MEDIUM |
| Split with both category and transfer returns 400 | NOT TESTED (POST version exists) | MEDIUM |
| Empty string category_id in PATCH returns 422 | NOT TESTED | MEDIUM |
| Invalid category_id format in PATCH returns 400 | NOT TESTED | MEDIUM |
| Non-existent category_id in PATCH returns 400 | NOT TESTED | MEDIUM |
| Invalid account_id format in PATCH returns 400 | NOT TESTED | MEDIUM |
| Non-existent account_id in PATCH returns 400 | NOT TESTED | MEDIUM |

### Recommended Test Count

| Category | Count |
|----------|-------|
| Modification sub-cases (M1-M6) | 6 |
| Split addition/removal | 6 |
| Validation errors | 6-8 |
| **Total new tests** | **18-20** |

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Value object splits | Entity splits with IDs | Phase 3.1 | PATCH can target specific splits |

**Deprecated/outdated:**
- SplitLine without ID: Now has `id: SplitId` as required first field

## Open Questions

None. The requirements are well-defined in 03.1-CONTEXT.md.

## Sources

### Primary (HIGH confidence)

- `/workspace/.planning/phases/03.1-split-identity-validation-fixes/03.1-CONTEXT.md` - Test requirements specification
- `/workspace/tests/integration/test_transaction_api.py` - Existing test patterns
- `/workspace/src/adapters/api/routes/transactions.py` - PATCH endpoint implementation
- `/workspace/src/application/services/transaction_service.py` - update_transaction_splits() method

### Secondary (MEDIUM confidence)

- `/workspace/.planning/phases/03.1-split-identity-validation-fixes/03.1-VERIFICATION.md` - Phase 3.1 completion status

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - No new libraries, use existing pytest/TestClient
- Architecture: HIGH - Follow existing test patterns exactly
- Pitfalls: HIGH - Derived from actual codebase review

**Research date:** 2026-02-02
**Valid until:** N/A (internal testing phase)
