---
phase: 01-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/domain/__init__.py
  - src/domain/model/__init__.py
  - src/domain/model/money.py
  - src/domain/model/entity_id.py
  - src/domain/events/__init__.py
  - src/domain/events/base.py
  - src/domain/ports/__init__.py
  - src/domain/ports/repository.py
  - src/domain/ports/unit_of_work.py
  - src/domain/exceptions.py
autonomous: true

must_haves:
  truths:
    - "Money value object performs addition, subtraction, multiplication without precision loss"
    - "Money rejects operations between different currencies"
    - "EntityId generates Stripe-style prefixed identifiers (acct_xxx, txn_xxx)"
    - "Domain layer has no imports from infrastructure packages"
    - "Domain events can be created with aggregate metadata"
  artifacts:
    - path: "src/domain/model/money.py"
      provides: "Immutable Money value object with Decimal precision"
      contains: "frozen=True"
      exports: ["Money"]
    - path: "src/domain/model/entity_id.py"
      provides: "Prefixed UUID identifiers"
      contains: "TypeID"
      exports: ["AccountId", "TransactionId", "UserId"]
    - path: "src/domain/ports/unit_of_work.py"
      provides: "Abstract UnitOfWork protocol"
      contains: "Protocol"
    - path: "src/domain/events/base.py"
      provides: "Domain event base class"
      contains: "DomainEvent"
  key_links:
    - from: "src/domain/model/money.py"
      to: "decimal.Decimal"
      via: "stdlib import only"
      pattern: "from decimal import"
    - from: "src/domain/model/entity_id.py"
      to: "typeid"
      via: "external library for UUID generation"
      pattern: "from typeid import"
---

<objective>
Create the pure domain layer with Money value object, prefixed entity IDs, domain event infrastructure, and port interfaces (Repository, UnitOfWork protocols).

Purpose: Establish the domain primitives that all future domain entities will build upon. The Money value object and EntityId are foundational - every account balance, transaction amount, and entity identifier will use these.

Output: Complete domain layer scaffolding with value objects, ports, and event base classes - all pure Python with no infrastructure dependencies.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation/01-CONTEXT.md
@.planning/phases/01-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Money value object with precision arithmetic</name>
  <files>
    src/domain/__init__.py
    src/domain/model/__init__.py
    src/domain/model/money.py
  </files>
  <action>
Create the Money value object following RESEARCH.md Pattern 2:

1. **src/domain/model/money.py**:
   - Frozen dataclass with slots=True for immutability and performance
   - Fields: amount (Decimal), currency (str, default "USD")
   - __post_init__: Normalize amount to 4 decimal places using ROUND_HALF_UP
   - __post_init__: Validate currency is 3-letter ISO code
   - Use `object.__setattr__` for frozen dataclass computed field (per RESEARCH.md pitfall #4)

   Arithmetic operations (return new Money, never mutate):
   - __add__: Add two Money of same currency
   - __sub__: Subtract two Money of same currency
   - __mul__: Multiply by Decimal or int factor
   - __neg__: Negate amount
   - __eq__: Compare amount and currency
   - __lt__, __le__, __gt__, __ge__: Compare amounts (same currency only)

   Helper methods:
   - is_positive() -> bool
   - is_negative() -> bool
   - is_zero() -> bool
   - abs() -> Money (absolute value)

   Critical: Initialize Decimal from string, never from float!
   - Good: Decimal("100.50")
   - Bad: Decimal(100.50) - causes precision issues (RESEARCH.md pitfall #3)

2. **Package __init__.py files**:
   - src/domain/__init__.py: Empty or docstring only
   - src/domain/model/__init__.py: Export Money

Important: NO imports from sqlalchemy, fastapi, pydantic, or any infrastructure package. Only stdlib (dataclasses, decimal, typing) and typeid-python.
  </action>
  <verify>
    - `grep -r "from sqlalchemy" src/domain/` returns empty (no infrastructure imports)
    - `grep "frozen=True" src/domain/model/money.py` shows immutability
    - `grep "Decimal" src/domain/model/money.py` shows proper decimal usage
  </verify>
  <done>
    - Money value object is immutable (frozen dataclass)
    - All arithmetic operations return new Money instances
    - Currency validation enforces 3-letter ISO codes
    - No infrastructure imports in domain layer
  </done>
</task>

<task type="auto">
  <name>Task 2: Create prefixed EntityId value objects</name>
  <files>
    src/domain/model/entity_id.py
  </files>
  <action>
Create Stripe-style prefixed entity identifiers following RESEARCH.md Pattern 3:

1. **src/domain/model/entity_id.py**:

   Base EntityId class (frozen dataclass):
   - value: str field holding the full prefixed ID
   - Classmethod generate(prefix: str) -> EntityId using TypeID
   - Classmethod from_string(value: str) -> EntityId with validation
   - Property prefix -> str (extracts prefix from value)
   - __str__ returns value for easy serialization

   Specific ID types (each frozen dataclass inheriting pattern):
   - AccountId: prefix "acct" (e.g., acct_01h455vb4pex5vsknk084sn02q)
   - TransactionId: prefix "txn"
   - UserId: prefix "user"
   - CategoryId: prefix "cat"
   - BudgetId: prefix "budg"

   Each specific type:
   - Classmethod generate() -> Self (uses hardcoded prefix)
   - Classmethod from_string(value: str) -> Self (validates prefix matches)

   TypeID provides:
   - UUID7-based (time-sortable)
   - URL-safe base32 encoding
   - Prefix validation

2. **Update src/domain/model/__init__.py**:
   - Export all ID types: AccountId, TransactionId, UserId, CategoryId, BudgetId

Format examples:
- AccountId: acct_01h455vb4pex5vsknk084sn02q
- TransactionId: txn_01h455vb4pex5vsknk084sn02q
  </action>
  <verify>
    - `grep "TypeID" src/domain/model/entity_id.py` shows typeid usage
    - `grep "frozen=True" src/domain/model/entity_id.py` shows immutability
    - `grep "acct" src/domain/model/entity_id.py` shows account prefix
  </verify>
  <done>
    - EntityId base class supports any prefix
    - Specific ID types (AccountId, TransactionId, etc.) have hardcoded prefixes
    - IDs are immutable and validate format on parse
    - TypeID provides UUID7-based, time-sortable identifiers
  </done>
</task>

<task type="auto">
  <name>Task 3: Create domain events and port interfaces</name>
  <files>
    src/domain/events/__init__.py
    src/domain/events/base.py
    src/domain/ports/__init__.py
    src/domain/ports/repository.py
    src/domain/ports/unit_of_work.py
    src/domain/exceptions.py
  </files>
  <action>
Create domain event infrastructure and port interfaces:

1. **src/domain/events/base.py** - Domain event base class:
   - Frozen dataclass DomainEvent with:
     - aggregate_id: str
     - aggregate_type: str
     - occurred_at: datetime (default factory: datetime.now(UTC))
   - Property event_type -> str (returns class name)
   - Method to_dict() -> dict (for serialization, uses dataclasses.asdict with custom handling)

2. **src/domain/ports/repository.py** - Repository protocols:
   - Use typing.Protocol for interface definitions (not ABC)
   - Generic Repository[T, ID] protocol with:
     - add(entity: T) -> None
     - get(id: ID) -> T | None
     - get_or_raise(id: ID) -> T (raises DomainException if not found)

   Note: Concrete repositories (AccountRepository, TransactionRepository) will be defined when their aggregates are created in later phases. For now, just the generic protocol pattern.

3. **src/domain/ports/unit_of_work.py** - UnitOfWork protocol:
   - Protocol UnitOfWork with:
     - __enter__() -> Self
     - __exit__(*args) -> None
     - commit() -> None
     - rollback() -> None
     - collect_events(events: list[DomainEvent]) -> None

4. **src/domain/exceptions.py** - Domain exceptions:
   - DomainException(Exception): Base for all domain errors
   - EntityNotFoundError(DomainException): Entity lookup failed
   - ValidationError(DomainException): Domain validation failed
   - BusinessRuleViolationError(DomainException): Business rule broken

   Each exception includes:
   - message: str
   - Optional context dict for additional info

5. **Package exports**:
   - src/domain/events/__init__.py: Export DomainEvent
   - src/domain/ports/__init__.py: Export UnitOfWork protocol

These are pure interfaces - no implementation logic, no infrastructure dependencies.
  </action>
  <verify>
    - `grep "Protocol" src/domain/ports/unit_of_work.py` shows Protocol usage
    - `grep "DomainEvent" src/domain/events/base.py` shows event class
    - `grep "DomainException" src/domain/exceptions.py` shows base exception
    - `grep -r "from sqlalchemy" src/domain/` returns empty
  </verify>
  <done>
    - DomainEvent base class captures aggregate metadata and timestamp
    - Repository protocol defines generic interface for persistence
    - UnitOfWork protocol defines transaction boundary interface
    - Domain exceptions provide typed error handling
    - All code is pure Python with no infrastructure imports
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. Verify no infrastructure imports in domain:
   ```bash
   grep -r "from sqlalchemy\|from fastapi\|from pydantic\|from alembic" src/domain/
   # Should return nothing
   ```

2. Verify Money can be instantiated:
   ```python
   # Quick validation (run in Python REPL)
   from decimal import Decimal
   from src.domain.model.money import Money
   m = Money(Decimal("100.50"), "USD")
   print(m.amount, m.currency)
   ```

3. Verify EntityId generates valid IDs:
   ```python
   from src.domain.model.entity_id import AccountId
   aid = AccountId.generate()
   print(aid.value)  # Should show acct_xxxxx
   ```
</verification>

<success_criteria>
- [ ] Money value object exists with all arithmetic operations
- [ ] Money uses Decimal with 4 decimal place precision
- [ ] Money rejects mixed-currency operations
- [ ] EntityId types generate prefixed identifiers (acct_, txn_, etc.)
- [ ] DomainEvent base class exists with aggregate metadata
- [ ] Repository and UnitOfWork protocols defined
- [ ] Domain exceptions hierarchy established
- [ ] ZERO imports from infrastructure packages in src/domain/
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md` with:
- Domain model structure created
- Value object design decisions
- Event and port interface patterns
- Verification that domain layer is pure (no infrastructure imports)
</output>
