---
phase: 01-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - .devcontainer/devcontainer.json
  - .devcontainer/Dockerfile
  - docker-compose.yml
  - docker-compose.override.yml
  - pyproject.toml
  - .pre-commit-config.yaml
  - .github/workflows/ci.yml
  - README.md
autonomous: true

must_haves:
  truths:
    - "Developer can open project in VS Code devcontainer and have working environment"
    - "Running 'uv sync' installs all dependencies reproducibly"
    - "Pre-commit hooks run ruff, mypy, and import-linter on staged files"
    - "GitHub Actions CI runs tests and lint checks on push"
    - "PostgreSQL container is accessible from application container"
  artifacts:
    - path: ".devcontainer/devcontainer.json"
      provides: "VS Code devcontainer configuration"
      contains: "docker-compose"
    - path: "docker-compose.yml"
      provides: "Service orchestration (app, postgres)"
      contains: "postgres"
    - path: "docker-compose.override.yml"
      provides: "Development overrides (hot reload, debug ports)"
      contains: "reload"
    - path: "pyproject.toml"
      provides: "Python project config with dependencies and tool settings"
      contains: "ruff"
    - path: ".pre-commit-config.yaml"
      provides: "Git hooks for code quality"
      contains: "mypy"
    - path: ".github/workflows/ci.yml"
      provides: "CI pipeline definition"
      contains: "pytest"
  key_links:
    - from: ".devcontainer/devcontainer.json"
      to: "docker-compose.yml"
      via: "dockerComposeFile reference"
      pattern: "dockerComposeFile.*docker-compose"
    - from: "pyproject.toml"
      to: ".pre-commit-config.yaml"
      via: "tool configs used by pre-commit"
      pattern: "tool\\.ruff"
---

<objective>
Set up the complete development environment with devcontainer, Docker Compose services, Python tooling (uv, ruff, mypy), pre-commit hooks, and GitHub Actions CI pipeline.

Purpose: Establish the foundation that enforces code quality from the first commit. Every future contribution will pass through these quality gates.

Output: Working devcontainer that developers can open and immediately start coding with all services running.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation/01-CONTEXT.md
@.planning/phases/01-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create devcontainer with Docker Compose services</name>
  <files>
    .devcontainer/devcontainer.json
    .devcontainer/Dockerfile
    docker-compose.yml
    docker-compose.override.yml
  </files>
  <action>
Create Docker Compose-based development environment:

1. **docker-compose.yml** - Production-like service definitions:
   - `app` service: Python 3.12 with uv, mounts src/ volume
   - `postgres` service: PostgreSQL 16 with named volume for data persistence
   - Network for service communication
   - Docker secrets for sensitive config (encryption key placeholder)

   NOTE: Redis is deferred to Phase 6 when background workers are implemented.
   The outbox pattern infrastructure is created in Phase 1, but the worker that
   processes the outbox (which needs Redis for job queuing) comes later.

2. **docker-compose.override.yml** - Development overrides:
   - Hot reload enabled (uvicorn --reload)
   - VS Code debugger port exposed
   - Bind mounts for code editing

3. **.devcontainer/Dockerfile** - Development container:
   - Base: python:3.12-slim
   - Install uv globally
   - Install git, build essentials for native deps
   - Non-root user for security

4. **.devcontainer/devcontainer.json**:
   - Reference docker-compose.yml with dockerComposeFile
   - Service: app
   - VS Code extensions: Python, Pylance, Ruff, PostgreSQL
   - Settings: Python path, ruff as formatter
   - postCreateCommand: "uv sync"
   - Ports: 8000 (FastAPI), 5432 (PostgreSQL)

Key decisions from CONTEXT.md:
- Docker secrets for encryption keys (not env vars)
- Structured logging configured for development (pretty) vs production (JSON)
  </action>
  <verify>
    - `ls .devcontainer/` shows devcontainer.json, Dockerfile
    - `docker compose config` validates docker-compose.yml syntax
    - `ls docker-compose.override.yml` confirms override file exists
    - devcontainer.json contains "dockerComposeFile" and "service: app"
  </verify>
  <done>
    - Devcontainer files exist and are syntactically valid
    - Docker Compose defines app and postgres services
    - docker-compose.override.yml provides development settings
    - Services can communicate over shared network
  </done>
</task>

<task type="auto">
  <name>Task 2: Configure Python tooling and pre-commit hooks</name>
  <files>
    pyproject.toml
    .pre-commit-config.yaml
    .gitignore
  </files>
  <action>
Create Python project configuration with all tooling:

1. **pyproject.toml**:
   - [project] section with name="personal-finance", python=">=3.12"
   - Dependencies from RESEARCH.md standard stack:
     - Core: fastapi, uvicorn, pydantic, sqlalchemy, alembic, asyncpg, psycopg2-binary
     - Supporting: structlog, cryptography, typeid-python, returns
   - Dev dependencies: ruff, mypy, import-linter, pytest, hypothesis, pytest-cov, pytest-asyncio, pre-commit

   - [tool.ruff] section (copy from RESEARCH.md code examples):
     - line-length = 88
     - target-version = "py312"
     - Full lint select list from research
     - isort known-first-party = ["src"]

   - [tool.mypy] section:
     - python_version = "3.12"
     - strict = true
     - plugins = ["pydantic.mypy"]

   - [tool.importlinter] section (copy from RESEARCH.md):
     - root_packages = ["src"]
     - Domain layer forbidden imports contract
     - Hexagonal architecture layers contract
     - Adapters independence contract

   - [tool.pytest.ini_options]:
     - testpaths = ["tests"]
     - asyncio_mode = "auto"

2. **.pre-commit-config.yaml**:
   - ruff (format + check)
   - mypy with --cache-dir for speed
   - import-linter

3. **.gitignore** (Python standard):
   - __pycache__, *.pyc, .mypy_cache, .ruff_cache
   - .venv, .env, .coverage
   - *.egg-info, dist, build
  </action>
  <verify>
    - `cat pyproject.toml | grep "tool.ruff"` shows ruff config exists
    - `cat pyproject.toml | grep "tool.importlinter"` shows import-linter config
    - `cat .pre-commit-config.yaml` shows ruff, mypy hooks
  </verify>
  <done>
    - pyproject.toml contains all dependencies and tool configurations
    - Pre-commit hooks configured for ruff, mypy, import-linter
    - .gitignore excludes Python artifacts
  </done>
</task>

<task type="auto">
  <name>Task 3: Create GitHub Actions CI and README</name>
  <files>
    .github/workflows/ci.yml
    README.md
    src/__init__.py
    tests/__init__.py
  </files>
  <action>
Create CI pipeline and project documentation:

1. **.github/workflows/ci.yml**:
   - Trigger: push to main, pull requests
   - Jobs:
     - lint: Run ruff check, mypy, import-linter
     - test: Run pytest with coverage
   - Use uv for dependency installation (fast)
   - Cache uv dependencies
   - PostgreSQL service container for integration tests
   - Python 3.12

2. **README.md**:
   - Project title and description
   - Quick start with devcontainer
   - Manual setup instructions (uv sync, docker compose up)
   - Running tests: `pytest`
   - Architecture overview (hexagonal, DDD patterns)
   - Link to .planning/ for detailed docs

3. **Create empty package markers**:
   - src/__init__.py (empty)
   - tests/__init__.py (empty)
   - These ensure Python recognizes the directories as packages
  </action>
  <verify>
    - `cat .github/workflows/ci.yml | grep "pytest"` shows test step
    - `cat README.md | head -5` shows project title
    - `ls src/__init__.py tests/__init__.py` shows package markers exist
  </verify>
  <done>
    - GitHub Actions CI runs lint and tests on every push
    - README documents setup and architecture
    - Package structure initialized
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. Validate Docker Compose:
   ```bash
   docker compose config
   ```

2. Validate pyproject.toml:
   ```bash
   # In devcontainer or with uv available
   uv sync --dry-run
   ```

3. Validate pre-commit config:
   ```bash
   pre-commit validate-config
   ```

4. Check GitHub Actions workflow syntax:
   ```bash
   # GitHub CLI if available, otherwise visual inspection
   cat .github/workflows/ci.yml
   ```

5. Verify override file exists:
   ```bash
   ls docker-compose.override.yml
   ```
</verification>

<success_criteria>
- [ ] Devcontainer can be opened in VS Code (validated by file structure)
- [ ] Docker Compose defines app and postgres services with network
- [ ] docker-compose.override.yml exists with development settings
- [ ] pyproject.toml has all dependencies from RESEARCH.md standard stack
- [ ] ruff, mypy, import-linter configured in pyproject.toml
- [ ] Pre-commit hooks configured for code quality enforcement
- [ ] GitHub Actions CI runs lint and tests
- [ ] README documents project setup
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-01-SUMMARY.md` with:
- Files created
- Configuration choices made
- Any deviations from research recommendations
- Commands to validate the setup
</output>
