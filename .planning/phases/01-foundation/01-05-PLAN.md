---
phase: 01-foundation
plan: 05
type: execute
wave: 3
depends_on: ["01-01", "01-02"]
files_modified:
  - src/adapters/security/__init__.py
  - src/adapters/security/encryption.py
  - src/adapters/api/__init__.py
  - src/adapters/api/app.py
  - src/adapters/api/dependencies.py
  - src/adapters/api/routes/__init__.py
  - src/adapters/api/routes/health.py
  - src/adapters/logging.py
  - src/application/__init__.py
  - src/main.py
autonomous: true

must_haves:
  truths:
    - "Field-level encryption encrypts and decrypts sensitive strings"
    - "FastAPI app starts with uvicorn and responds to health check"
    - "OpenAPI documentation available at /docs"
    - "Structured logging outputs JSON in production, pretty in development"
    - "Encryption key is loaded from Docker secrets"
  artifacts:
    - path: "src/adapters/security/encryption.py"
      provides: "AES-256-GCM field encryption"
      contains: "AESGCM"
      exports: ["FieldEncryption"]
    - path: "src/adapters/api/app.py"
      provides: "FastAPI application factory"
      contains: "FastAPI"
    - path: "src/adapters/api/routes/health.py"
      provides: "Health check endpoint"
      contains: "@router.get"
    - path: "src/adapters/logging.py"
      provides: "Structlog configuration"
      contains: "structlog"
    - path: "src/main.py"
      provides: "Application entry point"
      contains: "uvicorn"
  key_links:
    - from: "src/adapters/api/app.py"
      to: "src/adapters/api/routes/health.py"
      via: "router include"
      pattern: "include_router"
    - from: "src/adapters/security/encryption.py"
      to: "Docker secrets"
      via: "key loading"
      pattern: "secrets"
    - from: "src/main.py"
      to: "src/adapters/api/app.py"
      via: "uvicorn target"
      pattern: "src.adapters.api.app:app"
---

<objective>
Create security infrastructure (field-level AES-256-GCM encryption) and FastAPI application skeleton with health endpoint, dependency injection setup, and structured logging.

Purpose: Establish the security and API foundations that all future features will build upon. Encryption ensures sensitive data like Plaid tokens are never stored in plaintext.

Output: Running FastAPI application with health endpoint and working encryption service.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-foundation/01-CONTEXT.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create field-level encryption service</name>
  <files>
    src/adapters/security/__init__.py
    src/adapters/security/encryption.py
  </files>
  <action>
Create AES-256-GCM encryption service following RESEARCH.md code example:

1. **src/adapters/security/__init__.py**:
   - Export FieldEncryption class

2. **src/adapters/security/encryption.py**:
   ```python
   """Field-level AES-256-GCM encryption for sensitive data."""
   import os
   import base64
   from pathlib import Path
   from cryptography.hazmat.primitives.ciphers.aead import AESGCM


   class FieldEncryption:
       """
       AES-256-GCM encryption for sensitive database fields.

       Usage:
           encryptor = FieldEncryption.from_docker_secret()
           encrypted = encryptor.encrypt("sensitive_data")
           decrypted = encryptor.decrypt(encrypted)
       """

       def __init__(self, key: bytes):
           """
           Initialize with 32-byte key for AES-256.

           Args:
               key: 32-byte encryption key

           Raises:
               ValueError: If key is not 32 bytes
           """
           if len(key) != 32:
               raise ValueError("Key must be 32 bytes for AES-256")
           self._aesgcm = AESGCM(key)

       @classmethod
       def generate_key(cls) -> bytes:
           """
           Generate a new encryption key.

           Returns:
               32-byte key suitable for AES-256

           Note:
               Store this key securely! Loss of key = loss of encrypted data.
           """
           return AESGCM.generate_key(bit_length=256)

       @classmethod
       def from_docker_secret(
           cls,
           secret_name: str = "encryption_key",
           secrets_dir: str = "/run/secrets",
       ) -> "FieldEncryption":
           """
           Load encryption key from Docker secret.

           Args:
               secret_name: Name of the secret file
               secrets_dir: Directory where Docker mounts secrets

           Returns:
               FieldEncryption instance

           Raises:
               FileNotFoundError: If secret file doesn't exist
               ValueError: If key is invalid
           """
           secret_path = Path(secrets_dir) / secret_name
           if not secret_path.exists():
               # Fall back to environment variable for development
               env_key = os.getenv("ENCRYPTION_KEY")
               if env_key:
                   key = base64.b64decode(env_key)
                   return cls(key)
               raise FileNotFoundError(
                   f"Secret not found at {secret_path} and ENCRYPTION_KEY env var not set"
               )

           key = secret_path.read_bytes().strip()
           # Key might be base64 encoded in the secret file
           if len(key) == 44:  # Base64 encoded 32 bytes
               key = base64.b64decode(key)
           return cls(key)

       @classmethod
       def from_env(cls) -> "FieldEncryption":
           """
           Load encryption key from environment variable.
           For development/testing only.

           Returns:
               FieldEncryption instance

           Raises:
               ValueError: If ENCRYPTION_KEY not set or invalid
           """
           env_key = os.getenv("ENCRYPTION_KEY")
           if not env_key:
               raise ValueError("ENCRYPTION_KEY environment variable not set")
           key = base64.b64decode(env_key)
           return cls(key)

       def encrypt(self, plaintext: str) -> str:
           """
           Encrypt a string.

           Args:
               plaintext: String to encrypt

           Returns:
               Base64-encoded nonce+ciphertext
           """
           nonce = os.urandom(12)  # 96-bit nonce for GCM
           ciphertext = self._aesgcm.encrypt(nonce, plaintext.encode("utf-8"), None)
           # Prepend nonce to ciphertext for storage
           return base64.b64encode(nonce + ciphertext).decode("ascii")

       def decrypt(self, encrypted: str) -> str:
           """
           Decrypt an encrypted string.

           Args:
               encrypted: Base64-encoded nonce+ciphertext from encrypt()

           Returns:
               Original plaintext

           Raises:
               cryptography.exceptions.InvalidTag: If decryption fails
           """
           data = base64.b64decode(encrypted)
           nonce = data[:12]
           ciphertext = data[12:]
           plaintext = self._aesgcm.decrypt(nonce, ciphertext, None)
           return plaintext.decode("utf-8")
   ```

Key design decisions:
- Docker secrets as primary key source (CONTEXT.md requirement)
- Environment variable fallback for development
- Base64 encoding for key storage (human-readable in secret files)
- Nonce prepended to ciphertext for self-contained encrypted values
  </action>
  <verify>
    - `grep "AESGCM" src/adapters/security/encryption.py` shows AES-GCM usage
    - `grep "from_docker_secret" src/adapters/security/encryption.py` shows Docker integration
    - Python syntax check passes
  </verify>
  <done>
    - FieldEncryption class implements AES-256-GCM
    - Key loading from Docker secrets with env fallback
    - encrypt() and decrypt() methods work with strings
    - Key generation utility for setup
  </done>
</task>

<task type="auto">
  <name>Task 2: Create structured logging configuration</name>
  <files>
    src/adapters/logging.py
  </files>
  <action>
Create structured logging setup following RESEARCH.md example:

**src/adapters/logging.py**:
```python
"""Structured logging configuration."""
import logging
import sys
from typing import Literal

import structlog


def configure_logging(
    environment: Literal["development", "production"] = "development",
    log_level: str = "INFO",
) -> None:
    """
    Configure structlog for structured logging.

    Args:
        environment: "development" for pretty output, "production" for JSON
        log_level: Logging level (DEBUG, INFO, WARNING, ERROR, CRITICAL)

    In development:
        - Colored, human-readable output
        - Easy to scan in terminal

    In production:
        - JSON output for log aggregation (ELK, Datadog, etc.)
        - Structured fields for querying
    """
    shared_processors: list[structlog.types.Processor] = [
        structlog.stdlib.add_logger_name,
        structlog.stdlib.add_log_level,
        structlog.contextvars.merge_contextvars,
        structlog.processors.TimeStamper(fmt="iso", utc=True),
        structlog.processors.StackInfoRenderer(),
        structlog.processors.format_exc_info,
    ]

    if environment == "development":
        # Human-readable output for development
        processors = [
            *shared_processors,
            structlog.dev.ConsoleRenderer(colors=True),
        ]
    else:
        # JSON output for production log aggregation
        processors = [
            *shared_processors,
            structlog.processors.JSONRenderer(),
        ]

    structlog.configure(
        processors=processors,
        wrapper_class=structlog.stdlib.BoundLogger,
        context_class=dict,
        logger_factory=structlog.stdlib.LoggerFactory(),
        cache_logger_on_first_use=True,
    )

    # Configure standard library logging to use structlog
    logging.basicConfig(
        format="%(message)s",
        stream=sys.stdout,
        level=getattr(logging, log_level.upper()),
    )


def get_logger(name: str | None = None) -> structlog.stdlib.BoundLogger:
    """
    Get a logger instance.

    Args:
        name: Logger name (typically __name__)

    Returns:
        Structlog bound logger

    Usage:
        logger = get_logger(__name__)
        logger.info("user_created", user_id="user_xxx", email="test@example.com")
    """
    return structlog.get_logger(name)
```

Features:
- Environment-based configuration (pretty vs JSON)
- Standard library integration
- Context variables support for request tracing
- Typed interface
  </action>
  <verify>
    - `grep "structlog" src/adapters/logging.py` shows structlog usage
    - `grep "JSONRenderer" src/adapters/logging.py` shows production config
    - `grep "ConsoleRenderer" src/adapters/logging.py` shows dev config
  </verify>
  <done>
    - Logging configured for development (pretty) and production (JSON)
    - get_logger() utility for consistent logger creation
    - Standard library integration for third-party library logs
  </done>
</task>

<task type="auto">
  <name>Task 3: Create FastAPI application with health endpoint</name>
  <files>
    src/adapters/api/__init__.py
    src/adapters/api/app.py
    src/adapters/api/dependencies.py
    src/adapters/api/routes/__init__.py
    src/adapters/api/routes/health.py
    src/application/__init__.py
    src/main.py
  </files>
  <action>
Create FastAPI application skeleton:

1. **Package init files**:
   - src/adapters/api/__init__.py (empty)
   - src/adapters/api/routes/__init__.py (empty)
   - src/application/__init__.py (empty)

2. **src/adapters/api/dependencies.py** - FastAPI dependency providers:
   ```python
   """FastAPI dependency injection providers."""
   import os
   from functools import lru_cache
   from typing import Generator

   from src.adapters.security.encryption import FieldEncryption
   from src.adapters.logging import get_logger

   logger = get_logger(__name__)


   @lru_cache
   def get_settings() -> dict:
       """
       Application settings from environment.
       Cached for performance.
       """
       return {
           "environment": os.getenv("ENVIRONMENT", "development"),
           "database_url": os.getenv(
               "DATABASE_URL",
               "postgresql://postgres:postgres@postgres:5432/finance"
           ),
           "log_level": os.getenv("LOG_LEVEL", "INFO"),
       }


   def get_encryption() -> FieldEncryption:
       """
       Provide encryption service.
       Attempts Docker secrets first, falls back to env var.
       """
       try:
           return FieldEncryption.from_docker_secret()
       except FileNotFoundError:
           logger.warning("docker_secret_not_found", fallback="environment_variable")
           return FieldEncryption.from_env()


   # Add more dependencies as needed in later phases:
   # - get_unit_of_work() -> UnitOfWork
   # - get_account_repository() -> AccountRepository
   ```

3. **src/adapters/api/routes/health.py** - Health check endpoint:
   ```python
   """Health check endpoint."""
   from fastapi import APIRouter, Depends
   from pydantic import BaseModel
   from typing import Literal

   from ..dependencies import get_settings

   router = APIRouter(tags=["health"])


   class HealthResponse(BaseModel):
       """Health check response."""
       status: Literal["healthy", "unhealthy"]
       environment: str
       version: str = "0.1.0"


   @router.get("/health", response_model=HealthResponse)
   async def health_check(
       settings: dict = Depends(get_settings),
   ) -> HealthResponse:
       """
       Health check endpoint.

       Returns:
           Health status with environment info
       """
       return HealthResponse(
           status="healthy",
           environment=settings["environment"],
       )


   @router.get("/ready")
   async def readiness_check() -> dict:
       """
       Readiness check for Kubernetes.
       Checks if app is ready to receive traffic.

       TODO: Add database connectivity check in Phase 4
       """
       return {"ready": True}
   ```

4. **src/adapters/api/app.py** - Application factory:
   ```python
   """FastAPI application factory."""
   import os
   from contextlib import asynccontextmanager
   from typing import AsyncGenerator

   from fastapi import FastAPI
   from fastapi.middleware.cors import CORSMiddleware

   from src.adapters.logging import configure_logging, get_logger
   from src.adapters.persistence.orm.mappers import start_mappers
   from .routes import health

   logger = get_logger(__name__)


   @asynccontextmanager
   async def lifespan(app: FastAPI) -> AsyncGenerator[None, None]:
       """
       Application lifespan events.
       Startup: Configure logging, start mappers
       Shutdown: Cleanup resources
       """
       # Startup
       environment = os.getenv("ENVIRONMENT", "development")
       log_level = os.getenv("LOG_LEVEL", "INFO")
       configure_logging(environment=environment, log_level=log_level)

       logger.info("application_starting", environment=environment)

       # Initialize ORM mappers
       start_mappers()
       logger.info("orm_mappers_initialized")

       yield

       # Shutdown
       logger.info("application_shutting_down")


   def create_app() -> FastAPI:
       """
       Create FastAPI application instance.

       Returns:
           Configured FastAPI application
       """
       app = FastAPI(
           title="Personal Finance API",
           description="Personal finance management with data sovereignty",
           version="0.1.0",
           docs_url="/docs",
           redoc_url="/redoc",
           lifespan=lifespan,
       )

       # CORS middleware for web frontend
       app.add_middleware(
           CORSMiddleware,
           allow_origins=["http://localhost:3000"],  # React dev server
           allow_credentials=True,
           allow_methods=["*"],
           allow_headers=["*"],
       )

       # Include routers
       app.include_router(health.router)

       return app


   # Application instance for uvicorn
   app = create_app()
   ```

5. **src/main.py** - Application entry point:
   ```python
   """Entry point for running the application."""
   import uvicorn

   if __name__ == "__main__":
       uvicorn.run(
           "src.adapters.api.app:app",
           host="0.0.0.0",
           port=8000,
           reload=True,
       )
   ```
  </action>
  <verify>
    - `grep "FastAPI" src/adapters/api/app.py` shows FastAPI usage
    - `grep "include_router" src/adapters/api/app.py` shows router mounting
    - `grep "@router.get" src/adapters/api/routes/health.py` shows health endpoint
    - `ls src/main.py` confirms entry point exists
  </verify>
  <done>
    - FastAPI app factory created with lifespan events
    - Health check endpoint at /health returns status
    - Readiness endpoint at /ready for Kubernetes
    - OpenAPI docs available at /docs
    - CORS configured for React frontend
    - Dependency injection setup for encryption service
    - Entry point (src/main.py) created for running the application
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. Verify encryption works:
   ```python
   import os
   import base64
   os.environ["ENCRYPTION_KEY"] = base64.b64encode(os.urandom(32)).decode()
   from src.adapters.security.encryption import FieldEncryption
   enc = FieldEncryption.from_env()
   encrypted = enc.encrypt("secret")
   decrypted = enc.decrypt(encrypted)
   assert decrypted == "secret"
   print("Encryption OK")
   ```

2. Verify FastAPI app imports:
   ```python
   from src.adapters.api.app import app
   print(f"App title: {app.title}")
   print("FastAPI OK")
   ```

3. Start the application:
   ```bash
   ENCRYPTION_KEY=$(python -c "import os,base64;print(base64.b64encode(os.urandom(32)).decode())") \
   uvicorn src.adapters.api.app:app --host 0.0.0.0 --port 8000
   ```

4. Test health endpoint:
   ```bash
   curl http://localhost:8000/health
   # Should return {"status":"healthy","environment":"development","version":"0.1.0"}
   ```
</verification>

<success_criteria>
- [ ] FieldEncryption encrypts and decrypts strings correctly
- [ ] Encryption key loaded from Docker secrets (with env fallback)
- [ ] Structured logging configured for dev (pretty) and prod (JSON)
- [ ] FastAPI app starts with uvicorn
- [ ] Health endpoint returns 200 with status info
- [ ] OpenAPI documentation available at /docs
- [ ] CORS allows requests from React dev server
- [ ] src/main.py entry point exists and works
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-05-SUMMARY.md` with:
- Security infrastructure implemented
- API structure and endpoints
- Logging configuration
- Commands to start and test the application
</output>
