---
phase: 01-foundation
plan: 03
type: tdd
wave: 3
depends_on: ["01-01", "01-02"]
files_modified:
  - tests/unit/__init__.py
  - tests/unit/domain/__init__.py
  - tests/unit/domain/test_money.py
  - tests/unit/domain/test_entity_id.py
  - tests/conftest.py
autonomous: true

must_haves:
  truths:
    - "Property tests verify Money arithmetic is commutative and associative"
    - "Property tests verify Money precision is preserved through operations"
    - "Tests verify Money rejects operations between different currencies"
    - "Tests verify EntityId generates valid prefixed identifiers"
    - "All tests pass with pytest"
  artifacts:
    - path: "tests/unit/domain/test_money.py"
      provides: "Property-based tests for Money value object"
      contains: "hypothesis"
      min_lines: 50
    - path: "tests/unit/domain/test_entity_id.py"
      provides: "Tests for prefixed entity identifiers"
      contains: "AccountId"
    - path: "tests/conftest.py"
      provides: "Shared pytest fixtures"
  key_links:
    - from: "tests/unit/domain/test_money.py"
      to: "src/domain/model/money.py"
      via: "import and test"
      pattern: "from src.domain.model.money import Money"
---

<objective>
Write comprehensive property-based tests for Money value object using hypothesis, plus standard tests for EntityId. This uses TDD-style verification where tests define the expected behavior.

Purpose: Property-based testing catches edge cases that example-based tests miss. For financial applications, Money arithmetic must be provably correct - commutative, associative, and precision-preserving.

Output: Test suite that verifies Money correctness guarantees and EntityId format compliance.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-foundation/01-CONTEXT.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-02-SUMMARY.md
</context>

<feature>
  <name>Money Arithmetic Property Tests</name>
  <files>tests/unit/domain/test_money.py, src/domain/model/money.py</files>
  <behavior>
    Money arithmetic properties that MUST hold:
    - Commutative: m1 + m2 == m2 + m1
    - Associative: (m1 + m2) + m3 == m1 + (m2 + m3)
    - Identity: m + Money(0) == m
    - Inverse: m + (-m) == Money(0)
    - Precision preserved: No floating point errors after operations

    Cases that MUST fail:
    - Adding USD to EUR raises ValueError
    - Creating Money with invalid currency (2 or 4 letters) raises ValueError
  </behavior>
  <implementation>
    Use hypothesis strategies:
    - st.decimals(min_value=-1_000_000, max_value=1_000_000, places=4, allow_nan=False, allow_infinity=False)
    - Test all arithmetic properties with property-based tests
    - Include edge cases: zero, negative, very small decimals
  </implementation>
</feature>

<tasks>

<task type="auto">
  <name>Task 1: Create test infrastructure and conftest</name>
  <files>
    tests/__init__.py
    tests/unit/__init__.py
    tests/unit/domain/__init__.py
    tests/conftest.py
  </files>
  <action>
Set up test directory structure and shared fixtures:

1. **Create package marker files**:
   - tests/__init__.py (empty)
   - tests/unit/__init__.py (empty)
   - tests/unit/domain/__init__.py (empty)

2. **tests/conftest.py** - Shared pytest fixtures:
   ```python
   import pytest
   from decimal import Decimal
   from hypothesis import settings, Verbosity

   # Configure hypothesis for CI-friendly settings
   settings.register_profile("ci", max_examples=200, deadline=None)
   settings.register_profile("dev", max_examples=50, deadline=None)

   # Fixtures for common test values
   @pytest.fixture
   def usd_100() -> "Money":
       from src.domain.model.money import Money
       return Money(Decimal("100.00"), "USD")

   @pytest.fixture
   def usd_50() -> "Money":
       from src.domain.model.money import Money
       return Money(Decimal("50.00"), "USD")
   ```

Note: Keep conftest minimal for now. More fixtures will be added as needed in later phases.
  </action>
  <verify>
    - `ls tests/unit/domain/` shows __init__.py exists
    - `cat tests/conftest.py | grep "hypothesis"` shows hypothesis config
  </verify>
  <done>
    - Test directory structure exists with proper __init__.py files
    - conftest.py has hypothesis profile configuration
    - Basic Money fixtures available
  </done>
</task>

<task type="auto">
  <name>Task 2: Write Money property-based tests</name>
  <files>
    tests/unit/domain/test_money.py
  </files>
  <action>
Create comprehensive property-based tests for Money following RESEARCH.md examples:

**tests/unit/domain/test_money.py**:

```python
"""Property-based tests for Money value object."""
from decimal import Decimal
from hypothesis import given, strategies as st, assume
import pytest
from src.domain.model.money import Money

# Strategy for valid decimal amounts
money_amounts = st.decimals(
    min_value=Decimal("-1000000"),
    max_value=Decimal("1000000"),
    places=4,
    allow_nan=False,
    allow_infinity=False,
)

class TestMoneyProperties:
    """Property-based tests verifying Money arithmetic laws."""

    @given(a=money_amounts, b=money_amounts)
    def test_addition_is_commutative(self, a: Decimal, b: Decimal):
        """m1 + m2 == m2 + m1"""
        m1 = Money(a, "USD")
        m2 = Money(b, "USD")
        assert m1 + m2 == m2 + m1

    @given(a=money_amounts, b=money_amounts, c=money_amounts)
    def test_addition_is_associative(self, a: Decimal, b: Decimal, c: Decimal):
        """(m1 + m2) + m3 == m1 + (m2 + m3)"""
        m1 = Money(a, "USD")
        m2 = Money(b, "USD")
        m3 = Money(c, "USD")
        assert (m1 + m2) + m3 == m1 + (m2 + m3)

    @given(amount=money_amounts)
    def test_zero_is_additive_identity(self, amount: Decimal):
        """m + 0 == m"""
        m = Money(amount, "USD")
        zero = Money(Decimal("0"), "USD")
        assert m + zero == m
        assert zero + m == m

    @given(amount=money_amounts)
    def test_negation_gives_additive_inverse(self, amount: Decimal):
        """m + (-m) == 0"""
        m = Money(amount, "USD")
        zero = Money(Decimal("0"), "USD")
        assert m + (-m) == zero
        assert m - m == zero

    @given(amount=money_amounts)
    def test_subtraction_is_addition_of_negation(self, amount: Decimal):
        """m1 - m2 == m1 + (-m2)"""
        m1 = Money(amount, "USD")
        m2 = Money(Decimal("50"), "USD")
        assert m1 - m2 == m1 + (-m2)

    @given(amount=money_amounts, factor=st.integers(min_value=-1000, max_value=1000))
    def test_multiplication_by_integer(self, amount: Decimal, factor: int):
        """Money can be multiplied by integers."""
        m = Money(amount, "USD")
        result = m * factor
        assert result.currency == "USD"
        # Verify precision preserved
        expected = Money(amount * factor, "USD")
        assert result == expected

    @given(amount=money_amounts)
    def test_precision_preserved_through_operations(self, amount: Decimal):
        """Operations should not introduce floating-point errors."""
        m = Money(amount, "USD")
        # Double then halve should return original
        doubled = m + m
        halved = Money(doubled.amount / 2, "USD")
        assert m == halved

class TestMoneyValidation:
    """Tests for Money validation rules."""

    def test_rejects_different_currencies_on_add(self):
        """Cannot add USD to EUR."""
        usd = Money(Decimal("100"), "USD")
        eur = Money(Decimal("100"), "EUR")
        with pytest.raises(ValueError, match="currency"):
            _ = usd + eur

    def test_rejects_different_currencies_on_subtract(self):
        """Cannot subtract EUR from USD."""
        usd = Money(Decimal("100"), "USD")
        eur = Money(Decimal("100"), "EUR")
        with pytest.raises(ValueError, match="currency"):
            _ = usd - eur

    def test_rejects_invalid_currency_code_too_short(self):
        """Currency must be 3 letters."""
        with pytest.raises(ValueError, match="currency"):
            Money(Decimal("100"), "US")

    def test_rejects_invalid_currency_code_too_long(self):
        """Currency must be 3 letters."""
        with pytest.raises(ValueError, match="currency"):
            Money(Decimal("100"), "USDD")

    def test_normalizes_precision_to_four_decimals(self):
        """Money should normalize to 4 decimal places."""
        m = Money(Decimal("100.123456789"), "USD")
        # Should be rounded to 4 places
        assert str(m.amount) == "100.1235"  # ROUND_HALF_UP

class TestMoneyComparison:
    """Tests for Money comparison operations."""

    def test_equal_amounts_are_equal(self):
        m1 = Money(Decimal("100.00"), "USD")
        m2 = Money(Decimal("100.00"), "USD")
        assert m1 == m2

    def test_different_amounts_are_not_equal(self):
        m1 = Money(Decimal("100.00"), "USD")
        m2 = Money(Decimal("100.01"), "USD")
        assert m1 != m2

    def test_different_currencies_are_not_equal(self):
        m1 = Money(Decimal("100.00"), "USD")
        m2 = Money(Decimal("100.00"), "EUR")
        assert m1 != m2

    def test_less_than(self):
        m1 = Money(Decimal("50.00"), "USD")
        m2 = Money(Decimal("100.00"), "USD")
        assert m1 < m2
        assert not m2 < m1

    def test_comparison_requires_same_currency(self):
        usd = Money(Decimal("100"), "USD")
        eur = Money(Decimal("50"), "EUR")
        with pytest.raises(ValueError):
            _ = usd < eur

class TestMoneyHelpers:
    """Tests for Money helper methods."""

    def test_is_positive(self):
        assert Money(Decimal("100"), "USD").is_positive()
        assert not Money(Decimal("-100"), "USD").is_positive()
        assert not Money(Decimal("0"), "USD").is_positive()

    def test_is_negative(self):
        assert Money(Decimal("-100"), "USD").is_negative()
        assert not Money(Decimal("100"), "USD").is_negative()
        assert not Money(Decimal("0"), "USD").is_negative()

    def test_is_zero(self):
        assert Money(Decimal("0"), "USD").is_zero()
        assert not Money(Decimal("100"), "USD").is_zero()
        assert not Money(Decimal("-100"), "USD").is_zero()
```

Tests cover:
1. Algebraic properties (commutative, associative, identity, inverse)
2. Precision preservation
3. Currency validation
4. Comparison operations
5. Helper methods
  </action>
  <verify>
    - `pytest tests/unit/domain/test_money.py -v` passes all tests
    - `grep "@given" tests/unit/domain/test_money.py | wc -l` shows multiple property tests
  </verify>
  <done>
    - Property-based tests verify all arithmetic laws
    - Validation tests ensure currency rules enforced
    - Comparison tests verify ordering works correctly
    - All tests pass
  </done>
</task>

<task type="auto">
  <name>Task 3: Write EntityId tests</name>
  <files>
    tests/unit/domain/test_entity_id.py
  </files>
  <action>
Create tests for EntityId value objects:

**tests/unit/domain/test_entity_id.py**:

```python
"""Tests for prefixed entity identifiers."""
import pytest
from src.domain.model.entity_id import (
    AccountId,
    TransactionId,
    UserId,
    CategoryId,
    BudgetId,
)

class TestAccountId:
    """Tests for AccountId."""

    def test_generate_creates_valid_id(self):
        """Generated ID has correct prefix."""
        aid = AccountId.generate()
        assert aid.value.startswith("acct_")
        assert len(aid.value) > 5  # prefix + UUID portion

    def test_from_string_parses_valid_id(self):
        """Can parse a valid account ID string."""
        aid = AccountId.generate()
        parsed = AccountId.from_string(aid.value)
        assert parsed.value == aid.value

    def test_from_string_rejects_wrong_prefix(self):
        """Cannot parse transaction ID as account ID."""
        tid = TransactionId.generate()
        with pytest.raises((ValueError, TypeError)):
            AccountId.from_string(tid.value)

    def test_prefix_property(self):
        """Can extract prefix from ID."""
        aid = AccountId.generate()
        assert aid.prefix == "acct"

    def test_str_returns_value(self):
        """String representation is the ID value."""
        aid = AccountId.generate()
        assert str(aid) == aid.value

    def test_equality(self):
        """Same value means equal IDs."""
        aid1 = AccountId.generate()
        aid2 = AccountId.from_string(aid1.value)
        assert aid1 == aid2

    def test_different_ids_not_equal(self):
        """Different IDs are not equal."""
        aid1 = AccountId.generate()
        aid2 = AccountId.generate()
        assert aid1 != aid2

    def test_immutable(self):
        """Cannot modify ID after creation."""
        aid = AccountId.generate()
        with pytest.raises(AttributeError):
            aid.value = "acct_modified"

class TestTransactionId:
    """Tests for TransactionId."""

    def test_generate_creates_valid_id(self):
        tid = TransactionId.generate()
        assert tid.value.startswith("txn_")

    def test_prefix_property(self):
        tid = TransactionId.generate()
        assert tid.prefix == "txn"

class TestUserId:
    """Tests for UserId."""

    def test_generate_creates_valid_id(self):
        uid = UserId.generate()
        assert uid.value.startswith("user_")

    def test_prefix_property(self):
        uid = UserId.generate()
        assert uid.prefix == "user"

class TestCategoryId:
    """Tests for CategoryId."""

    def test_generate_creates_valid_id(self):
        cid = CategoryId.generate()
        assert cid.value.startswith("cat_")

class TestBudgetId:
    """Tests for BudgetId."""

    def test_generate_creates_valid_id(self):
        bid = BudgetId.generate()
        assert bid.value.startswith("budg_")

class TestEntityIdUniqueness:
    """Tests verifying ID uniqueness."""

    def test_generated_ids_are_unique(self):
        """Each generate() call produces unique ID."""
        ids = [AccountId.generate() for _ in range(100)]
        values = [id.value for id in ids]
        assert len(set(values)) == 100  # All unique

    def test_ids_are_sortable_by_creation_time(self):
        """TypeID uses UUID7 which is time-sortable."""
        import time
        id1 = AccountId.generate()
        time.sleep(0.01)  # Small delay
        id2 = AccountId.generate()
        # Lexicographic sort should match creation order
        assert id1.value < id2.value
```

Tests cover:
1. Prefix correctness for each ID type
2. Parsing and validation
3. Equality and immutability
4. Uniqueness guarantees
5. Time-sortability (UUID7 property)
  </action>
  <verify>
    - `pytest tests/unit/domain/test_entity_id.py -v` passes all tests
    - `grep "def test_" tests/unit/domain/test_entity_id.py | wc -l` shows comprehensive coverage
  </verify>
  <done>
    - All entity ID types tested for correct prefix
    - Parse/validation logic tested
    - Uniqueness and sortability verified
    - All tests pass
  </done>
</task>

</tasks>

<verification>
After completing all tasks, run the full test suite:

```bash
# Run all domain tests
pytest tests/unit/domain/ -v

# Run with coverage
pytest tests/unit/domain/ -v --cov=src/domain --cov-report=term-missing

# Run property tests with more examples (CI profile)
pytest tests/unit/domain/test_money.py -v --hypothesis-profile=ci
```

Expected results:
- All tests pass
- Property tests run with configured number of examples
- No infrastructure imports in domain layer
</verification>

<success_criteria>
- [ ] pytest tests/unit/domain/ passes all tests
- [ ] Property tests verify Money arithmetic laws (commutative, associative, identity, inverse)
- [ ] Property tests verify Money precision preservation
- [ ] Tests verify currency validation (reject mixed currencies, invalid codes)
- [ ] EntityId tests verify prefix correctness and uniqueness
- [ ] Test coverage shows all Money and EntityId code paths exercised
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md` with:
- Test count and coverage metrics
- Property test configuration (hypothesis settings)
- Any edge cases discovered during testing
- Commands to run tests
</output>
