---
phase: 01-foundation
plan: 06
type: execute
wave: 4
depends_on: ["01-03", "01-04", "01-05"]
files_modified:
  - tests/integration/__init__.py
  - tests/integration/test_database.py
  - tests/integration/test_encryption.py
  - tests/integration/conftest.py
autonomous: false

must_haves:
  truths:
    - "Integration tests verify database migrations apply cleanly"
    - "Integration tests verify encryption round-trip works"
    - "Integration tests verify outbox event persistence"
    - "Developer can open devcontainer and run tests successfully"
  artifacts:
    - path: "tests/integration/test_database.py"
      provides: "Database integration tests"
      contains: "alembic"
    - path: "tests/integration/test_encryption.py"
      provides: "Encryption integration tests"
      contains: "FieldEncryption"
    - path: "tests/integration/conftest.py"
      provides: "Integration test fixtures"
      contains: "pytest.fixture"
  key_links:
    - from: "tests/integration/test_database.py"
      to: "alembic"
      via: "runs migrations"
      pattern: "alembic.*upgrade"
    - from: "tests/integration/test_encryption.py"
      to: "src/adapters/security/encryption.py"
      via: "tests encryption service"
      pattern: "from src.adapters.security"
---

<objective>
Create integration tests that verify the full stack works together: database migrations, encryption, and domain event outbox. Includes a checkpoint for human verification of the devcontainer experience.

Purpose: Integration tests catch issues that unit tests miss - connection problems, migration errors, and cross-component wiring. The checkpoint ensures the developer experience works end-to-end.

Output: Passing integration tests and verified devcontainer workflow.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-foundation/01-CONTEXT.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-03-SUMMARY.md
@.planning/phases/01-foundation/01-04-SUMMARY.md
@.planning/phases/01-foundation/01-05-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create integration test fixtures</name>
  <files>
    tests/integration/__init__.py
    tests/integration/conftest.py
  </files>
  <action>
Create integration test infrastructure with database fixtures:

1. **tests/integration/__init__.py** (empty package marker)

2. **tests/integration/conftest.py**:
   ```python
   """Integration test fixtures."""
   import os
   import base64
   import pytest
   from sqlalchemy import create_engine, text
   from sqlalchemy.orm import sessionmaker

   from src.adapters.persistence.orm.base import metadata
   from src.adapters.persistence.orm.mappers import start_mappers, clear_mappers
   from src.adapters.security.encryption import FieldEncryption


   @pytest.fixture(scope="session")
   def database_url():
       """
       Database URL for tests.
       Uses TEST_DATABASE_URL if set, otherwise defaults to test database.
       """
       return os.getenv(
           "TEST_DATABASE_URL",
           "postgresql://postgres:postgres@localhost:5432/finance_test"
       )


   @pytest.fixture(scope="session")
   def engine(database_url):
       """Create SQLAlchemy engine for tests."""
       return create_engine(database_url, echo=False)


   @pytest.fixture(scope="session")
   def setup_database(engine):
       """
       Create all tables for tests.
       Runs once per test session.
       """
       # Start mappers before creating tables
       start_mappers()

       # Drop and recreate all tables
       metadata.drop_all(engine)
       metadata.create_all(engine)

       yield

       # Cleanup after all tests
       metadata.drop_all(engine)
       clear_mappers()


   @pytest.fixture
   def session(engine, setup_database):
       """
       Provide a transactional session for each test.
       Rolls back after each test for isolation.
       """
       connection = engine.connect()
       transaction = connection.begin()
       Session = sessionmaker(bind=connection)
       session = Session()

       yield session

       session.close()
       transaction.rollback()
       connection.close()


   @pytest.fixture
   def encryption_key():
       """Generate encryption key for tests."""
       return FieldEncryption.generate_key()


   @pytest.fixture
   def field_encryption(encryption_key):
       """Provide encryption service for tests."""
       return FieldEncryption(encryption_key)


   @pytest.fixture
   def env_encryption_key(encryption_key, monkeypatch):
       """Set up encryption key in environment."""
       encoded = base64.b64encode(encryption_key).decode()
       monkeypatch.setenv("ENCRYPTION_KEY", encoded)
       return encoded
   ```

Key features:
- Session-scoped database setup (tables created once)
- Transactional tests (each test rolls back)
- Encryption key fixtures for security tests
  </action>
  <verify>
    - `cat tests/integration/conftest.py | grep "fixture"` shows fixtures defined
    - `cat tests/integration/conftest.py | grep "session"` shows session fixture
  </verify>
  <done>
    - Integration test package created
    - Database fixtures with transactional isolation
    - Encryption fixtures for security tests
  </done>
</task>

<task type="auto">
  <name>Task 2: Create database and migration tests</name>
  <files>
    tests/integration/test_database.py
  </files>
  <action>
Create integration tests for database and migrations:

**tests/integration/test_database.py**:
```python
"""Integration tests for database and migrations."""
import json
from datetime import datetime, UTC
import pytest
from sqlalchemy import select, insert, text

from src.adapters.persistence.orm.tables import outbox, users, encrypted_secrets
from src.adapters.persistence.unit_of_work import SqlAlchemyUnitOfWork
from src.domain.events.base import DomainEvent
from src.domain.model.entity_id import UserId


class TestDatabaseTables:
    """Test that database tables exist and work correctly."""

    def test_outbox_table_exists(self, session):
        """Outbox table can be queried."""
        result = session.execute(select(outbox)).fetchall()
        assert result == []  # Empty but queryable

    def test_users_table_exists(self, session):
        """Users table can be queried."""
        result = session.execute(select(users)).fetchall()
        assert result == []

    def test_encrypted_secrets_table_exists(self, session):
        """Encrypted secrets table can be queried."""
        result = session.execute(select(encrypted_secrets)).fetchall()
        assert result == []


class TestOutboxPattern:
    """Test outbox pattern for domain events."""

    def test_can_insert_event_to_outbox(self, session):
        """Events can be inserted into outbox table."""
        session.execute(
            insert(outbox).values(
                event_type="TestEvent",
                aggregate_type="TestAggregate",
                aggregate_id="test_123",
                payload=json.dumps({"key": "value"}),
                created_at=datetime.now(UTC),
            )
        )
        session.commit()

        result = session.execute(
            select(outbox).where(outbox.c.aggregate_id == "test_123")
        ).fetchone()

        assert result is not None
        assert result.event_type == "TestEvent"
        assert result.processed_at is None

    def test_can_mark_event_as_processed(self, session):
        """Events can be marked as processed."""
        # Insert event
        session.execute(
            insert(outbox).values(
                event_type="TestEvent",
                aggregate_type="TestAggregate",
                aggregate_id="test_456",
                payload="{}",
                created_at=datetime.now(UTC),
            )
        )
        session.commit()

        # Mark as processed
        session.execute(
            text(
                "UPDATE outbox SET processed_at = :now WHERE aggregate_id = :id"
            ).bindparams(now=datetime.now(UTC), id="test_456")
        )
        session.commit()

        result = session.execute(
            select(outbox).where(outbox.c.aggregate_id == "test_456")
        ).fetchone()

        assert result.processed_at is not None

    def test_unprocessed_index_filters_correctly(self, session):
        """Partial index on processed_at = NULL works."""
        # Insert processed event
        session.execute(
            insert(outbox).values(
                event_type="ProcessedEvent",
                aggregate_type="Test",
                aggregate_id="processed_1",
                payload="{}",
                created_at=datetime.now(UTC),
                processed_at=datetime.now(UTC),
            )
        )
        # Insert unprocessed event
        session.execute(
            insert(outbox).values(
                event_type="UnprocessedEvent",
                aggregate_type="Test",
                aggregate_id="unprocessed_1",
                payload="{}",
                created_at=datetime.now(UTC),
                processed_at=None,
            )
        )
        session.commit()

        # Query for unprocessed events
        result = session.execute(
            select(outbox).where(outbox.c.processed_at.is_(None))
        ).fetchall()

        assert len(result) == 1
        assert result[0].aggregate_id == "unprocessed_1"


class TestUserTable:
    """Test users table operations."""

    def test_can_insert_user(self, session):
        """Users can be inserted."""
        user_id = UserId.generate()
        session.execute(
            insert(users).values(
                id=user_id.value,
                email="test@example.com",
                email_verified=False,
                created_at=datetime.now(UTC),
                updated_at=datetime.now(UTC),
            )
        )
        session.commit()

        result = session.execute(
            select(users).where(users.c.id == user_id.value)
        ).fetchone()

        assert result is not None
        assert result.email == "test@example.com"
        assert result.id.startswith("user_")

    def test_email_must_be_unique(self, session):
        """Email uniqueness constraint is enforced."""
        from sqlalchemy.exc import IntegrityError

        user_id_1 = UserId.generate()
        user_id_2 = UserId.generate()

        session.execute(
            insert(users).values(
                id=user_id_1.value,
                email="duplicate@example.com",
                email_verified=False,
                created_at=datetime.now(UTC),
                updated_at=datetime.now(UTC),
            )
        )
        session.commit()

        with pytest.raises(IntegrityError):
            session.execute(
                insert(users).values(
                    id=user_id_2.value,
                    email="duplicate@example.com",  # Same email
                    email_verified=False,
                    created_at=datetime.now(UTC),
                    updated_at=datetime.now(UTC),
                )
            )
            session.commit()


class TestEncryptedSecretsTable:
    """Test encrypted secrets storage."""

    def test_can_store_encrypted_secret(self, session, field_encryption):
        """Encrypted secrets can be stored."""
        user_id = UserId.generate()

        # Create user first (FK constraint)
        session.execute(
            insert(users).values(
                id=user_id.value,
                email="secrets@example.com",
                email_verified=False,
                created_at=datetime.now(UTC),
                updated_at=datetime.now(UTC),
            )
        )

        encrypted_value = field_encryption.encrypt("plaid_access_token_xxx")

        session.execute(
            insert(encrypted_secrets).values(
                user_id=user_id.value,
                secret_type="plaid_access_token",
                encrypted_value=encrypted_value,
                created_at=datetime.now(UTC),
                updated_at=datetime.now(UTC),
            )
        )
        session.commit()

        result = session.execute(
            select(encrypted_secrets).where(
                encrypted_secrets.c.user_id == user_id.value
            )
        ).fetchone()

        assert result is not None
        assert result.secret_type == "plaid_access_token"
        # Verify we stored encrypted, not plaintext
        assert result.encrypted_value != "plaid_access_token_xxx"
        # Verify we can decrypt
        decrypted = field_encryption.decrypt(result.encrypted_value)
        assert decrypted == "plaid_access_token_xxx"

    def test_user_secret_type_unique_constraint(self, session, field_encryption):
        """Each user can have only one secret of each type."""
        from sqlalchemy.exc import IntegrityError

        user_id = UserId.generate()

        session.execute(
            insert(users).values(
                id=user_id.value,
                email="unique@example.com",
                email_verified=False,
                created_at=datetime.now(UTC),
                updated_at=datetime.now(UTC),
            )
        )

        # First secret
        session.execute(
            insert(encrypted_secrets).values(
                user_id=user_id.value,
                secret_type="plaid_access_token",
                encrypted_value=field_encryption.encrypt("token1"),
                created_at=datetime.now(UTC),
                updated_at=datetime.now(UTC),
            )
        )
        session.commit()

        # Duplicate should fail
        with pytest.raises(IntegrityError):
            session.execute(
                insert(encrypted_secrets).values(
                    user_id=user_id.value,
                    secret_type="plaid_access_token",  # Same type
                    encrypted_value=field_encryption.encrypt("token2"),
                    created_at=datetime.now(UTC),
                    updated_at=datetime.now(UTC),
                )
            )
            session.commit()
```
  </action>
  <verify>
    - `grep "def test_" tests/integration/test_database.py | wc -l` shows multiple tests
    - `grep "outbox" tests/integration/test_database.py` shows outbox tests
    - `grep "encrypted_secrets" tests/integration/test_database.py` shows encryption tests
  </verify>
  <done>
    - Database table existence tests
    - Outbox pattern tests (insert, mark processed, partial index)
    - User table tests with constraint verification
    - Encrypted secrets integration with encryption service
  </done>
</task>

<task type="auto">
  <name>Task 3: Create encryption integration tests</name>
  <files>
    tests/integration/test_encryption.py
  </files>
  <action>
Create encryption service integration tests:

**tests/integration/test_encryption.py**:
```python
"""Integration tests for field-level encryption."""
import os
import base64
import pytest

from src.adapters.security.encryption import FieldEncryption


class TestFieldEncryptionRoundTrip:
    """Test encryption round-trip scenarios."""

    def test_encrypt_decrypt_simple_string(self, field_encryption):
        """Basic encrypt/decrypt works."""
        plaintext = "my_secret_token"
        encrypted = field_encryption.encrypt(plaintext)
        decrypted = field_encryption.decrypt(encrypted)
        assert decrypted == plaintext

    def test_encrypt_decrypt_unicode(self, field_encryption):
        """Unicode characters preserved through encryption."""
        plaintext = "secret with emoji "
        encrypted = field_encryption.encrypt(plaintext)
        decrypted = field_encryption.decrypt(encrypted)
        assert decrypted == plaintext

    def test_encrypt_decrypt_empty_string(self, field_encryption):
        """Empty strings can be encrypted."""
        plaintext = ""
        encrypted = field_encryption.encrypt(plaintext)
        decrypted = field_encryption.decrypt(encrypted)
        assert decrypted == plaintext

    def test_encrypt_decrypt_long_string(self, field_encryption):
        """Long strings (like JWTs) work."""
        plaintext = "a" * 10000  # 10KB string
        encrypted = field_encryption.encrypt(plaintext)
        decrypted = field_encryption.decrypt(encrypted)
        assert decrypted == plaintext

    def test_same_plaintext_produces_different_ciphertext(self, field_encryption):
        """
        Each encryption uses random nonce.
        Same plaintext should produce different ciphertext.
        """
        plaintext = "repeated_secret"
        encrypted1 = field_encryption.encrypt(plaintext)
        encrypted2 = field_encryption.encrypt(plaintext)

        # Different ciphertext
        assert encrypted1 != encrypted2

        # But both decrypt to same plaintext
        assert field_encryption.decrypt(encrypted1) == plaintext
        assert field_encryption.decrypt(encrypted2) == plaintext


class TestFieldEncryptionSecurity:
    """Test encryption security properties."""

    def test_ciphertext_not_equal_to_plaintext(self, field_encryption):
        """Encrypted value is not the plaintext."""
        plaintext = "obvious_secret"
        encrypted = field_encryption.encrypt(plaintext)
        assert encrypted != plaintext
        assert plaintext not in encrypted

    def test_different_keys_cannot_decrypt(self, field_encryption):
        """Data encrypted with one key cannot be decrypted with another."""
        from cryptography.exceptions import InvalidTag

        plaintext = "secret_data"
        encrypted = field_encryption.encrypt(plaintext)

        # Create new encryptor with different key
        different_key = FieldEncryption.generate_key()
        different_encryptor = FieldEncryption(different_key)

        with pytest.raises(InvalidTag):
            different_encryptor.decrypt(encrypted)

    def test_tampered_ciphertext_fails(self, field_encryption):
        """Modified ciphertext fails authentication."""
        from cryptography.exceptions import InvalidTag

        plaintext = "authentic_data"
        encrypted = field_encryption.encrypt(plaintext)

        # Tamper with the ciphertext
        encrypted_bytes = base64.b64decode(encrypted)
        tampered = encrypted_bytes[:-1] + bytes([encrypted_bytes[-1] ^ 1])
        tampered_encoded = base64.b64encode(tampered).decode()

        with pytest.raises(InvalidTag):
            field_encryption.decrypt(tampered_encoded)


class TestFieldEncryptionKeyLoading:
    """Test key loading from various sources."""

    def test_load_from_environment_variable(self, env_encryption_key):
        """Key can be loaded from environment."""
        encryptor = FieldEncryption.from_env()

        plaintext = "env_secret"
        encrypted = encryptor.encrypt(plaintext)
        decrypted = encryptor.decrypt(encrypted)

        assert decrypted == plaintext

    def test_invalid_key_length_raises(self):
        """Key must be exactly 32 bytes."""
        with pytest.raises(ValueError, match="32 bytes"):
            FieldEncryption(b"too_short")

        with pytest.raises(ValueError, match="32 bytes"):
            FieldEncryption(b"x" * 64)  # Too long

    def test_generate_key_produces_valid_key(self):
        """Generated key is correct length."""
        key = FieldEncryption.generate_key()
        assert len(key) == 32

        # Can be used to create encryptor
        encryptor = FieldEncryption(key)
        encrypted = encryptor.encrypt("test")
        assert encryptor.decrypt(encrypted) == "test"


class TestFieldEncryptionBase64:
    """Test base64 encoding of encrypted values."""

    def test_encrypted_value_is_valid_base64(self, field_encryption):
        """Encrypted values can be stored as text."""
        plaintext = "base64_test"
        encrypted = field_encryption.encrypt(plaintext)

        # Should be valid base64
        decoded = base64.b64decode(encrypted)
        assert len(decoded) > 0

    def test_encrypted_value_is_ascii_safe(self, field_encryption):
        """Encrypted values contain only ASCII characters."""
        plaintext = "ascii_test"
        encrypted = field_encryption.encrypt(plaintext)

        # Should be ASCII-safe for database storage
        encrypted.encode("ascii")  # Should not raise
```
  </action>
  <verify>
    - `grep "def test_" tests/integration/test_encryption.py | wc -l` shows multiple tests
    - `grep "InvalidTag" tests/integration/test_encryption.py` shows security tests
    - `grep "from_env" tests/integration/test_encryption.py` shows key loading tests
  </verify>
  <done>
    - Round-trip encryption tests (simple, unicode, empty, long)
    - Security property tests (different keys, tamper detection)
    - Key loading tests (environment variable)
    - Base64 encoding verification
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 4: Verify devcontainer and full test suite</name>
  <what-built>
    Complete Phase 1 foundation:
    - Devcontainer with Docker Compose (app + PostgreSQL)
    - Domain primitives (Money, EntityId)
    - Property-based tests for Money
    - Persistence infrastructure (SQLAlchemy, migrations)
    - Security (AES-256-GCM encryption)
    - FastAPI skeleton with health endpoint
    - Integration tests
  </what-built>
  <how-to-verify>
    1. **Open in devcontainer:**
       - Open project in VS Code
       - Click "Reopen in Container" when prompted
       - Wait for container to build and start

    2. **Run database migrations:**
       ```bash
       alembic upgrade head
       ```
       Expected: Migration applies without errors

    3. **Run full test suite:**
       ```bash
       pytest -v
       ```
       Expected: All tests pass (unit + integration)

    4. **Start the API:**
       ```bash
       ENCRYPTION_KEY=$(python -c "import os,base64;print(base64.b64encode(os.urandom(32)).decode())") \
       uvicorn src.adapters.api.app:app --host 0.0.0.0 --port 8000 --reload
       ```

    5. **Test health endpoint:**
       ```bash
       curl http://localhost:8000/health
       ```
       Expected: {"status":"healthy","environment":"development","version":"0.1.0"}

    6. **Check OpenAPI docs:**
       - Open http://localhost:8000/docs in browser
       - Should see Swagger UI with health endpoint documented

    7. **Verify architecture enforcement:**
       ```bash
       lint-imports
       ```
       Expected: No architecture violations
  </how-to-verify>
  <resume-signal>
    Type "approved" if all checks pass, or describe any issues encountered.
  </resume-signal>
</task>

</tasks>

<verification>
After all tasks complete:

1. Run full test suite:
   ```bash
   pytest -v --cov=src --cov-report=term-missing
   ```

2. Verify architecture:
   ```bash
   lint-imports
   ```

3. Run pre-commit on all files:
   ```bash
   pre-commit run --all-files
   ```

Expected: All tests pass, no lint errors, no architecture violations.
</verification>

<success_criteria>
- [ ] Integration test fixtures provide transactional database sessions
- [ ] Database tests verify all three tables (outbox, users, encrypted_secrets)
- [ ] Outbox pattern tests verify event persistence and processing
- [ ] Encryption tests verify round-trip and security properties
- [ ] Human verified: devcontainer opens successfully
- [ ] Human verified: migrations apply to fresh database
- [ ] Human verified: full test suite passes
- [ ] Human verified: API health endpoint responds
- [ ] Human verified: OpenAPI docs display correctly
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-06-SUMMARY.md` with:
- Integration test coverage
- Devcontainer verification results
- Any issues found during human verification
- Phase 1 completion status
</output>
