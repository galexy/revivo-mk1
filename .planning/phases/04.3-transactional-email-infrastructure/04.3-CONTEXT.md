# Phase 4.3: Transactional Email Infrastructure - Context

**Gathered:** 2026-02-06
**Status:** Ready for planning

<domain>
## Phase Boundary

Build email sending capability with SMTP adapter, background job queue for async processing, and Mailpit for dev environment. Send verification email on user registration. Integration tests mock the email adapter.

This phase establishes reusable infrastructure for all transactional emails (verification now, password reset later).

</domain>

<decisions>
## Implementation Decisions

### Email Content & Branding
- HTML with plain text fallback for all emails
- Sender identity configurable via environment variables (SMTP_FROM_NAME, SMTP_FROM_EMAIL)
- Minimal branding: logo + clean layout, not heavy styling
- Email templates in separate markup files outside code — research templating solutions (Jinja2-based or specialized email templating libraries)
- Subject lines action-focused (e.g., "Confirm your email to get started")
- Tone: friendly but professional
- Include brief teaser about what user can do after verifying
- Full footer with company info and support link

### Verification Flow UX
- Links valid for 48 hours
- Expired link shows error page with resend button
- Successful verification auto-logs user in and redirects to dashboard (implementation details deferred to UI phase)
- Re-clicking valid link when already verified: treat as success (idempotent)
- Long signed token in URL (existing itsdangerous pattern)
- Email body states expiration time explicitly ("This link expires in 48 hours")
- Resend verification available from login page when user attempts login with unverified account
- Rate limiting: 3 resend requests per hour

### Dev Environment Workflow
- Mailpit on localhost:8025 (separate browser tab)
- Mailpit always-on in Docker Compose (not optional profile)
- App starts even if SMTP unavailable, but logs error for observability
- Endpoints that attempt email send return 500 if email service unavailable
- SMTP configuration via individual env vars (SMTP_HOST, SMTP_PORT, SMTP_USER, SMTP_PASSWORD)
- No EMAIL_ENABLED toggle — always require SMTP config
- Integration tests use mock email adapter (no real SMTP calls)
- Test verification is test-specific (each test decides what to assert)
- No dev preview endpoint — use Mailpit to view sent emails

### Background Job Infrastructure
- Full job queue implementation (not synchronous email sending)
- PostgreSQL-backed job queue (no Redis dependency)
- Separate database for job queue (not same as app database)
- Worker runs in same container as API if library supports (auto-start with API)
- Dead letter queue for permanently failed jobs
- Logging: standard level (job ID, email type, status, retry count) — no PII or email addresses
- Admin visibility via library-provided dashboard UI

### Error Handling & Retries
- Job queue handles retries with backoff (library-provided)
- Failed jobs go to dead letter queue for review
- Registration returns 202 immediately when email job is queued
- If email queuing fails during registration, registration fails (rollback user creation)

### Event Architecture
- Hybrid approach: sync domain events + async job queue for side effects
- Email sending triggered by domain event (UserRegistered) — not direct call from registration service
- Event handler enqueues job to job queue (handler doesn't send email directly)
- Maintains existing UoW-managed event pattern
- Side effects (email, external calls) are async via job queue

### Claude's Discretion
- Specific job queue library choice (research PostgreSQL-backed options: e.g., procrastinate, apscheduler, or similar)
- Email templating library choice (Jinja2-based or specialized)
- Exact retry backoff strategy
- Dashboard port configuration
- Worker concurrency settings

</decisions>

<specifics>
## Specific Ideas

- Research email templating solutions that allow editing templates in markup files outside code
- Job queue must have operational visibility for when jobs consistently fail
- No logging of PII — use job IDs for debugging correlation
- Existing `UserRegistered` event pattern should trigger the email (event-driven)

</specifics>

<deferred>
## Deferred Ideas

- Auto-login JWT delivery mechanism — deferred to UI phase
- Email deliverability (SPF/DKIM/DMARC) — production hardening phase
- Marketing emails / notification preferences — separate capability

</deferred>

---

*Phase: 04.3-transactional-email-infrastructure*
*Context gathered: 2026-02-06*
