---
phase: 10-value-object-orm-mapping
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - libs/domain/domain/model/money.py
  - libs/domain/domain/model/institution.py
  - libs/domain/domain/model/rewards_balance.py
  - apps/api/src/adapters/persistence/orm/mappers.py
  - apps/api/src/adapters/persistence/repositories/account.py
autonomous: true

must_haves:
  truths:
    - "SQLAlchemy composite() maps Money, InstitutionDetails, RewardsBalance to flat DB columns"
    - "_decompose_value_objects before_flush handler is removed"
    - "Manual value object reconstruction in AccountRepository is removed"
    - "Account CRUD integration tests pass (create, read, update, delete with value objects)"
    - "All 444 existing tests pass"
  artifacts:
    - path: "libs/domain/domain/model/money.py"
      provides: "__composite_values__ for SQLAlchemy composite()"
      contains: "__composite_values__"
    - path: "libs/domain/domain/model/institution.py"
      provides: "__composite_values__ for SQLAlchemy composite()"
      contains: "__composite_values__"
    - path: "libs/domain/domain/model/rewards_balance.py"
      provides: "__composite_values__ for SQLAlchemy composite()"
      contains: "__composite_values__"
    - path: "apps/api/src/adapters/persistence/orm/mappers.py"
      provides: "composite() mappings replacing exclude_properties and before_flush handler"
      contains: "composite"
  key_links:
    - from: "apps/api/src/adapters/persistence/orm/mappers.py"
      to: "libs/domain/domain/model/money.py"
      via: "composite(Money, ...)"
      pattern: "composite.*Money"
    - from: "apps/api/src/adapters/persistence/orm/mappers.py"
      to: "apps/api/src/adapters/persistence/orm/tables.py"
      via: "column references in composite()"
---

<objective>
Replace manual value object decomposition/reconstruction with SQLAlchemy composite() mappings for Money, InstitutionDetails, and RewardsBalance on the Account aggregate.

Purpose: Eliminate 20+ type: ignore[attr-defined] comments, remove fragile before_flush event handler, and remove manual reconstruction logic in AccountRepository. composite() is the standard SQLAlchemy solution for mapping Python objects to multiple database columns.
Output: Clean composite() mappings in mappers.py, simplified repository, value objects with __composite_values__().
</objective>

<execution_context>
@/home/developer/.claude/get-shit-done/workflows/execute-plan.md
@/home/developer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@apps/api/src/adapters/persistence/orm/mappers.py
@apps/api/src/adapters/persistence/repositories/account.py
@apps/api/src/adapters/persistence/orm/tables.py
@libs/domain/domain/model/money.py
@libs/domain/domain/model/institution.py
@libs/domain/domain/model/rewards_balance.py

References:
- https://docs.sqlalchemy.org/en/21/orm/composites.html
- composite() requires: (1) constructor accepts flat column values as positional args, (2) __composite_values__() returns flat tuple
- Nullable composites: when all component columns are NULL, SQLAlchemy returns None for the composite attribute
- Frozen dataclass value objects are fine as composite types (composite only SETs the attribute on the parent, not mutates the value object)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add __composite_values__ to value objects</name>
  <files>
    libs/domain/domain/model/money.py
    libs/domain/domain/model/institution.py
    libs/domain/domain/model/rewards_balance.py
  </files>
  <action>
    SQLAlchemy composite() requires each value object to:
    1. Accept flat column values as positional constructor args (already true for all three)
    2. Implement __composite_values__() returning a flat tuple

    Add __composite_values__ to each:

    1. Money (money.py) -- add after __post_init__:
       ```python
       def __composite_values__(self) -> tuple[Decimal, str]:
           """Return flat column values for SQLAlchemy composite() mapping."""
           return (self.amount, self.currency)
       ```

    2. InstitutionDetails (institution.py) -- add after __post_init__:
       ```python
       def __composite_values__(self) -> tuple[str, str | None, str | None, str | None]:
           """Return flat column values for SQLAlchemy composite() mapping."""
           return (self.name, self.website, self.phone, self.notes)
       ```

    3. RewardsBalance (rewards_balance.py) -- add after __post_init__:
       ```python
       def __composite_values__(self) -> tuple[Decimal, str]:
           """Return flat column values for SQLAlchemy composite() mapping."""
           return (self.value, self.unit)
       ```

    These methods are non-breaking additions -- they only add a method that SQLAlchemy will call.
  </action>
  <verify>
    Run `npx nx typecheck domain` -- zero errors.
    Run `npx nx test domain` -- all tests pass.
  </verify>
  <done>
    All three value objects have __composite_values__() for SQLAlchemy composite() support.
  </done>
</task>

<task type="auto">
  <name>Task 2: Replace exclude_properties with composite() and clean up repository</name>
  <files>
    apps/api/src/adapters/persistence/orm/mappers.py
    apps/api/src/adapters/persistence/repositories/account.py
  </files>
  <action>
    This is the core change. Read these references before starting:
    - https://docs.sqlalchemy.org/en/21/orm/composites.html (imperative mapping example)
    - Nullable composites: when ALL component columns are NULL, composite returns None

    **mappers.py changes:**

    1. Add composite import:
       `from sqlalchemy.orm import Session, composite`

    2. Add value object imports at the top of start_mappers() (inside the function to avoid circular imports):
       ```python
       from domain.model.money import Money
       from domain.model.institution import InstitutionDetails
       from domain.model.rewards_balance import RewardsBalance
       ```

    3. Replace the Account mapper_registry.map_imperatively call.
       Old: uses exclude_properties for opening_balance, credit_limit, institution, rewards_balance.
       New: uses properties dict with composite() mappings:
       ```python
       mapper_registry.map_imperatively(
           Account,
           accounts,
           exclude_properties=[
               "_events",  # _events is transient, not persisted
           ],
           properties={
               "opening_balance": composite(
                   Money,
                   accounts.c.opening_balance_amount,
                   accounts.c.opening_balance_currency,
               ),
               "credit_limit": composite(
                   Money,
                   accounts.c.credit_limit_amount,
                   accounts.c.credit_limit_currency,
               ),
               "institution": composite(
                   InstitutionDetails,
                   accounts.c.institution_name,
                   accounts.c.institution_website,
                   accounts.c.institution_phone,
                   accounts.c.institution_notes,
               ),
               "rewards_balance": composite(
                   RewardsBalance,
                   accounts.c.rewards_value,
                   accounts.c.rewards_unit,
               ),
           },
       )
       ```

    4. Remove the entire _decompose_value_objects function (lines 39-91).

    5. Remove the event.listen(Session, "before_flush", _decompose_value_objects) call near the bottom.

    6. In clear_mappers(), remove the event.remove for _decompose_value_objects (the with contextlib.suppress block).
       Also remove the `import contextlib` if no longer needed.

    **account.py (AccountRepository) changes:**

    7. Remove the _reconstruct_value_objects method entirely (lines 192+).
       With composite(), SQLAlchemy automatically:
       - Decomposes value objects to flat columns on write
       - Reconstructs value objects from flat columns on read
       - Returns None when all component columns are NULL (handles nullable credit_limit, institution, rewards_balance)

    8. Remove all calls to self._reconstruct_value_objects(account) from:
       - get() method
       - get_or_raise() (calls get(), so already handled)
       - get_by_user() method (the loop that calls it for each account)
       - get_by_household() method (the loop that calls it for each account)

    9. Remove unused imports from account.py: Decimal, InstitutionDetails, Money, RewardsBalance,
       AccountStatus, AccountSubtype, AccountType (check which are still needed for query filters).
       Keep: select, Session, EntityNotFoundError, Account, AccountId, UserId, HouseholdId.
       Keep AccountStatus, AccountType, AccountSubtype if still used for query filters.

    **IMPORTANT CONSIDERATIONS:**

    - The _reconstruct_value_objects method also reconstructs EntityIds (AccountId, UserId, HouseholdId)
      and enums (AccountType, AccountStatus, AccountSubtype) from strings. These are handled by
      TypeDecorators in tables.py (AccountIdType, UserIdType, etc.), NOT by composite().
      TypeDecorators already convert strings to domain types on load. Verify this works by checking
      that EntityId TypeDecorators have process_result_value methods.
      If the TypeDecorators handle it, the EntityId/enum reconstruction in _reconstruct_value_objects
      is ALSO redundant. But be careful -- if removing the reconstruction breaks tests, keep it.

    - The _events reconstruction (`if not hasattr(account, "_events")`) is handled by the
      exclude_properties for _events, which is still in the mapping. SQLAlchemy will not touch _events.
      But Account.__init__ sets `_events: list = field(default_factory=list)`, so new instances have it.
      For LOADED instances (from DB), _events may not be initialized. Check if this is handled.
      If needed, add a @reconstructor or keep a minimal post-load hook.

    - Test with ALL account types, especially:
      - Checking (has opening_balance, no credit_limit, no rewards_balance)
      - Credit card (has opening_balance + credit_limit)
      - Rewards (has opening_balance + rewards_balance)
      - Account with institution details

    - Run the FULL test suite, not just account tests. The mapper changes affect ALL tests
      that use the database because start_mappers() is called once at app startup.
  </action>
  <verify>
    Run `npx nx typecheck api` -- zero errors (and fewer type: ignore comments than before).
    Run `npx nx test api` -- all 252+ tests pass, including account CRUD tests.
    Grep for `_decompose_value_objects` in mappers.py -- should not exist.
    Grep for `_reconstruct_value_objects` in account.py -- should not exist.
    Grep for `type: ignore\[attr-defined\]` in mappers.py -- should be zero or much reduced.
  </verify>
  <done>
    composite() mappings replace manual decomposition and reconstruction.
    20+ type: ignore[attr-defined] comments eliminated from mappers.py.
    AccountRepository simplified (no manual value object reconstruction).
    All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `npx nx typecheck domain` -- zero errors
2. `npx nx typecheck api` -- zero errors
3. `npx nx test domain` -- all tests pass
4. `npx nx test api` -- all tests pass (especially account CRUD tests)
5. No _decompose_value_objects in codebase
6. No _reconstruct_value_objects in codebase
7. composite() used for Money, InstitutionDetails, RewardsBalance in mappers.py
</verification>

<success_criteria>
- Value objects mapped via SQLAlchemy composite() (not manual event handlers)
- _decompose_value_objects handler removed entirely
- _reconstruct_value_objects in repository removed entirely
- 20+ type: ignore[attr-defined] eliminated from mappers.py
- All 444 existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/10-value-object-orm-mapping/10-01-SUMMARY.md`
</output>
