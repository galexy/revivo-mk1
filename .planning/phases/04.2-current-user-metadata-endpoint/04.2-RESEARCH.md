# Phase 4.2: Current User Metadata Endpoint - Research

**Researched:** 2026-02-06
**Domain:** FastAPI protected endpoint, Pydantic response schemas, SQLAlchemy queries
**Confidence:** HIGH

## Summary

This phase adds a `/auth/me` endpoint that returns the authenticated user's profile metadata with nested household information. The codebase already has all the patterns established: JWT authentication via `get_current_user` dependency, Pydantic response schemas with `model_config = ConfigDict(from_attributes=True)`, and repository methods for loading users and households by ID.

The implementation requires:
1. New Pydantic response schemas for user profile and nested household
2. A new GET endpoint in `auth.py` routes that uses `CurrentUser` dependency
3. Database queries via `AuthService` to load user and household details
4. Careful field selection to avoid leaking sensitive data (password_hash)

**Primary recommendation:** Follow existing protected endpoint patterns from `accounts.py` routes. Use nested Pydantic models for household response. Query user and household in the same service method to avoid N+1.

## Standard Stack

The established libraries/tools for this domain (already in project):

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| FastAPI | current | HTTP endpoints with dependency injection | Project standard |
| Pydantic | v2 | Request/response validation, serialization | Project standard |
| SQLAlchemy | current | ORM for database queries | Project standard |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| PyJWT | current | JWT token validation | Already integrated via `get_current_user` |

**No new dependencies required.** All patterns exist in the codebase.

## Architecture Patterns

### Existing Project Structure (relevant files)
```
src/
├── adapters/
│   └── api/
│       ├── dependencies.py      # get_current_user, CurrentUser dataclass
│       ├── routes/
│       │   └── auth.py          # Add /me endpoint here
│       └── schemas/
│           └── auth.py          # Add UserProfileResponse here
├── application/
│   └── services/
│       └── auth_service.py      # Add get_user_profile method here
└── adapters/
    └── persistence/
        └── repositories/
            ├── user.py          # get_by_id already exists
            └── household.py     # get_by_id already exists
```

### Pattern 1: Protected Endpoint with CurrentUser Dependency
**What:** Inject authenticated user context via FastAPI dependency
**When to use:** Any endpoint that requires authentication
**Example:**
```python
# Source: /workspace/src/adapters/api/routes/accounts.py:125-129
@router.get(
    "/me",
    response_model=UserProfileResponse,
    summary="Get current user profile",
)
async def get_current_user_profile(
    service: AuthServiceDep,
    current_user: CurrentUserDep,
) -> UserProfileResponse:
    ...
```

### Pattern 2: Pydantic Response Schema with Domain Conversion
**What:** Pydantic model with `from_domain` classmethod for conversion
**When to use:** API responses that need to serialize domain objects
**Example:**
```python
# Source: /workspace/src/adapters/api/schemas/auth.py pattern
class HouseholdResponse(BaseModel):
    """Nested household in user profile response."""

    model_config = ConfigDict(from_attributes=True)

    id: str = Field(..., description="Household ID")
    name: str = Field(..., description="Household name")
    is_owner: bool = Field(..., description="Whether user is household owner")
```

### Pattern 3: Service Layer Query Method
**What:** AuthService method that loads user + household in single UoW context
**When to use:** When endpoint needs data from multiple repositories
**Example:**
```python
# Source: pattern from /workspace/src/application/services/auth_service.py
def get_user_profile(
    self,
    user_id: UserId,
) -> UserProfile | None:
    """Load user and household for profile display."""
    with self._uow:
        user = self._uow.users.get_by_id(user_id)
        if user is None:
            return None
        household = self._uow.households.get_by_id(user.household_id)
        # Return domain object or DTO
```

### Anti-Patterns to Avoid
- **Returning password_hash:** Never include in response schema - Pydantic exclude_unset won't help if field exists
- **Separate API calls for household:** Load both user and household in same service method
- **Using CurrentUser.user_id directly in response:** CurrentUser only has IDs - need full User from database for email, display_name

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| JWT extraction | Manual header parsing | `get_current_user` dependency | Already handles token validation, error responses |
| Response serialization | Dict construction | Pydantic model with `from_attributes` | Consistent with other endpoints, automatic validation |
| Auth check | Manual token check | FastAPI Depends() | Framework handles 401 automatically |

**Key insight:** This phase is about wiring existing components together, not building new infrastructure.

## Common Pitfalls

### Pitfall 1: Returning User domain object directly
**What goes wrong:** User domain object has password_hash attribute
**Why it happens:** Tempting to return User directly with Pydantic serialization
**How to avoid:** Create explicit response schema that only includes safe fields
**Warning signs:** Response includes unexpected fields in OpenAPI docs

### Pitfall 2: N+1 queries for household
**What goes wrong:** Endpoint loads user, then makes separate call for household
**Why it happens:** CurrentUser only has household_id, need name from Household table
**How to avoid:** Service method loads both user and household before returning
**Warning signs:** Two database roundtrips for single endpoint

### Pitfall 3: Forgetting is_owner calculation
**What goes wrong:** Response missing is_owner flag for household
**Why it happens:** is_owner is derived from user.role == "owner", not stored on household
**How to avoid:** Calculate is_owner in service layer before returning response
**Warning signs:** Frontend can't determine if user can manage household

### Pitfall 4: Inconsistent field naming
**What goes wrong:** Response uses different naming convention than other endpoints
**Why it happens:** Ad-hoc schema design without checking existing patterns
**How to avoid:** Follow existing schema patterns (snake_case, similar field names)
**Warning signs:** Inconsistent API documentation between endpoints

## Code Examples

Verified patterns from project source code:

### Protected Endpoint Signature
```python
# Source: /workspace/src/adapters/api/routes/accounts.py:119-129
@router.get(
    "/me",
    response_model=UserProfileResponse,
    summary="Get current user profile",
)
async def get_current_user_profile(
    service: Annotated[AuthService, Depends(get_auth_service)],
    current_user: Annotated[CurrentUser, Depends(get_current_user)],
) -> UserProfileResponse:
    """Get authenticated user's profile with household info."""
    result = service.get_user_profile(current_user.user_id)
    if result is None:
        raise HTTPException(status_code=404, detail="User not found")
    return UserProfileResponse.from_domain(result)
```

### Response Schema with Nested Object
```python
# Source: pattern from /workspace/src/adapters/api/schemas/account.py
class HouseholdResponse(BaseModel):
    """Household info in user profile."""

    model_config = ConfigDict(from_attributes=True)

    id: str = Field(..., description="Household ID (hh_xxx format)")
    name: str = Field(..., description="Household display name")
    is_owner: bool = Field(..., description="Whether user owns this household")


class UserProfileResponse(BaseModel):
    """User profile with household info."""

    model_config = ConfigDict(from_attributes=True)

    user_id: str = Field(..., description="User ID (user_xxx format)")
    email: str = Field(..., description="User email address")
    display_name: str = Field(..., description="User display name")
    email_verified: bool = Field(..., description="Whether email is verified")
    household: HouseholdResponse = Field(..., description="User's household")
```

### Service Method Loading Multiple Entities
```python
# Source: pattern from /workspace/src/application/services/auth_service.py:337-351
def get_user_profile(
    self,
    user_id: UserId,
) -> tuple[User, Household] | None:
    """Load user and household for profile endpoint.

    Returns tuple of (User, Household) or None if user not found.
    """
    with self._uow:
        user = self._uow.users.get_by_id(user_id)
        if user is None:
            return None
        household = self._uow.households.get_by_id(user.household_id)
        if household is None:
            return None  # Should not happen if FK constraint enforced
        return (user, household)
```

### 401 Error Response (existing pattern)
```python
# Source: /workspace/src/adapters/api/dependencies.py:109-113
credentials_exception = HTTPException(
    status_code=status.HTTP_401_UNAUTHORIZED,
    detail="Could not validate credentials",
    headers={"WWW-Authenticate": "Bearer"},
)
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Manual JWT parsing | FastAPI OAuth2PasswordBearer | Project start | Standardized auth handling |
| Dict responses | Pydantic models | Project start | Type safety, auto-docs |

**Deprecated/outdated:**
- passlib: Replaced with pwdlib (Python 3.13+ compatibility)
- python-jose: Replaced with PyJWT (CVE-2025-61152)

## Open Questions

### 1. Include timestamps in response?
- What we know: CONTEXT.md leaves this to Claude's discretion
- What's unclear: Whether frontend needs created_at, last_login
- **Recommendation:** Include created_at only. Skip last_login (not currently tracked in users table). Can add later if frontend needs it.

### 2. Field naming for user_id vs id
- What we know: Existing responses use mixed conventions (RegisterResponse has user_id)
- What's unclear: Whether to match RegisterResponse or use just "id"
- **Recommendation:** Use user_id for consistency with RegisterResponse and VerifyEmailResponse. Nested household uses just "id" since context is clear.

## Decision: Claude's Discretion Items

Per CONTEXT.md, these are my recommended choices:

### Timestamps
- **Include:** `created_at` on user (useful for "member since" display)
- **Exclude:** `last_login` (not tracked in current schema, would require separate column)

### Field naming
- User fields: `user_id`, `email`, `display_name`, `email_verified`, `created_at`
- Household fields: `id`, `name`, `is_owner`
- Follows existing RegisterResponse/VerifyEmailResponse patterns

### Error response format
- 401 Unauthorized: Use existing `credentials_exception` pattern from dependencies.py
- 404 Not Found: Return if user somehow deleted (shouldn't happen, but defensive)

## Sources

### Primary (HIGH confidence)
- `/workspace/src/adapters/api/routes/accounts.py` - Protected endpoint patterns
- `/workspace/src/adapters/api/dependencies.py` - CurrentUser injection, get_current_user
- `/workspace/src/adapters/api/schemas/auth.py` - Existing auth response schemas
- `/workspace/src/application/services/auth_service.py` - Service patterns
- `/workspace/src/adapters/persistence/repositories/user.py` - get_by_id method
- `/workspace/src/adapters/persistence/repositories/household.py` - get_by_id method
- `/workspace/src/domain/model/user.py` - User domain model (shows available fields)
- `/workspace/src/domain/model/household.py` - Household domain model

### Secondary (MEDIUM confidence)
- `/workspace/src/adapters/persistence/orm/tables.py` - Database schema (confirms column names)

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - No new dependencies, using existing project patterns
- Architecture: HIGH - Clear patterns established in accounts.py, auth.py
- Pitfalls: HIGH - Identified from existing code analysis

**Research date:** 2026-02-06
**Valid until:** 2026-03-06 (stable, internal codebase patterns)
