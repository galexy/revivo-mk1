---
phase: 04.2-current-user-metadata-endpoint
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/application/services/auth_service.py
  - src/adapters/api/schemas/auth.py
  - src/adapters/api/routes/auth.py
  - tests/integration/api/test_auth_me.py
autonomous: true

must_haves:
  truths:
    - "GET /auth/me with valid JWT returns user profile (user_id, email, display_name, email_verified, created_at)"
    - "GET /auth/me response includes nested household object with id, name, is_owner"
    - "GET /auth/me without JWT returns 401 Unauthorized"
    - "Response does not leak sensitive fields (password_hash)"
  artifacts:
    - path: "src/application/services/auth_service.py"
      provides: "get_user_profile method returning User + Household tuple"
      contains: "def get_user_profile"
    - path: "src/adapters/api/schemas/auth.py"
      provides: "UserProfileResponse and HouseholdResponse schemas"
      contains: "class UserProfileResponse"
    - path: "src/adapters/api/routes/auth.py"
      provides: "GET /auth/me endpoint"
      contains: "@router.get"
    - path: "tests/integration/api/test_auth_me.py"
      provides: "Integration tests for /auth/me endpoint"
      min_lines: 50
  key_links:
    - from: "src/adapters/api/routes/auth.py"
      to: "AuthService.get_user_profile"
      via: "service.get_user_profile(current_user.user_id)"
      pattern: "get_user_profile.*user_id"
    - from: "src/adapters/api/routes/auth.py"
      to: "get_current_user dependency"
      via: "Depends(get_current_user)"
      pattern: "Depends.*get_current_user"
---

<objective>
Add a GET /auth/me endpoint that returns the authenticated user's profile metadata with nested household information.

Purpose: Enable frontend to display user context (welcome message, household info) without additional API calls. Prepares is_owner flag for Phase 25 (Multi-User Households).

Output: Working /auth/me endpoint with integration tests covering success and 401 cases.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/CHECKPOINTS.md

# Phase-specific context
@.planning/phases/04.2-current-user-metadata-endpoint/04.2-CONTEXT.md
@.planning/phases/04.2-current-user-metadata-endpoint/04.2-RESEARCH.md

# Existing patterns to follow
@src/adapters/api/routes/auth.py
@src/adapters/api/schemas/auth.py
@src/adapters/api/dependencies.py
@src/application/services/auth_service.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add UserProfileResponse schema and service method</name>
  <files>
    src/application/services/auth_service.py
    src/adapters/api/schemas/auth.py
  </files>
  <action>
1. In src/application/services/auth_service.py, add a get_user_profile method:
   - Takes user_id: UserId parameter
   - Uses self._uow context manager
   - Loads user via self._uow.users.get_by_id(user_id)
   - If user is None, return None
   - Loads household via self._uow.households.get_by_id(user.household_id)
   - Returns tuple[User, Household] or None

2. In src/adapters/api/schemas/auth.py, add response schemas:
   - HouseholdResponse(BaseModel):
     - model_config = ConfigDict(from_attributes=True)
     - id: str (Household ID, hh_xxx format)
     - name: str (Household display name)
     - is_owner: bool (whether user owns this household)

   - UserProfileResponse(BaseModel):
     - model_config = ConfigDict(from_attributes=True)
     - user_id: str (User ID, user_xxx format)
     - email: str
     - display_name: str
     - email_verified: bool
     - created_at: datetime (for "member since" display)
     - household: HouseholdResponse (nested)

     Add a @classmethod from_domain(cls, user: User, household: Household) -> "UserProfileResponse"
     that constructs the response with is_owner = (user.role == "owner")

Follow existing schema patterns: use Field(..., description="...") for all fields.
Import datetime from datetime module for created_at type.
  </action>
  <verify>
    Run: python -c "from src.adapters.api.schemas.auth import UserProfileResponse, HouseholdResponse; print('Schemas imported OK')"
    Run: python -c "from src.application.services.auth_service import AuthService; print('Service imported OK')"
  </verify>
  <done>
    - UserProfileResponse and HouseholdResponse schemas exist with all required fields
    - AuthService.get_user_profile method exists and returns tuple[User, Household] | None
  </done>
</task>

<task type="auto">
  <name>Task 2: Add GET /auth/me endpoint</name>
  <files>
    src/adapters/api/routes/auth.py
  </files>
  <action>
Add GET /auth/me endpoint to auth.py routes:

1. Import UserProfileResponse from schemas and get_current_user from dependencies

2. Add CurrentUserDep type alias (if not present):
   CurrentUserDep = Annotated[CurrentUser, Depends(get_current_user)]

3. Add endpoint:
   @router.get(
       "/me",
       response_model=UserProfileResponse,
       summary="Get current user profile",
   )
   async def get_current_user_profile(
       service: AuthServiceDep,
       current_user: CurrentUserDep,
   ) -> UserProfileResponse:
       """Get authenticated user's profile with household info.

       Returns user metadata (email, display_name, email_verified, created_at)
       and nested household object (id, name, is_owner flag).

       Raises:
           HTTPException: 404 if user not found (should not happen with valid JWT).
       """
       result = service.get_user_profile(current_user.user_id)
       if result is None:
           raise HTTPException(status_code=404, detail="User not found")

       user, household = result
       return UserProfileResponse.from_domain(user, household)

Note: The 401 case is already handled by get_current_user dependency (returns 401 if JWT invalid/missing).
  </action>
  <verify>
    Run: python -c "from src.adapters.api.routes.auth import router; print([r.path for r in router.routes])"
    Confirm /me appears in the route list
  </verify>
  <done>
    - GET /auth/me endpoint exists in auth router
    - Uses CurrentUser dependency for JWT validation
    - Returns UserProfileResponse with nested HouseholdResponse
  </done>
</task>

<task type="auto">
  <name>Task 3: Add integration tests and verify with running service</name>
  <files>
    tests/integration/api/test_auth_me.py
  </files>
  <action>
Create tests/integration/api/test_auth_me.py with:

1. Imports: pytest, TestClient, app, test fixtures from conftest

2. Test class TestAuthMeEndpoint with:

   test_get_me_returns_user_profile:
   - Create and verify a user (use existing auth fixture pattern)
   - Get access token via login
   - GET /auth/me with Authorization: Bearer {token}
   - Assert 200 status
   - Assert response has user_id, email, display_name, email_verified, created_at
   - Assert response has household object with id, name, is_owner
   - Assert is_owner is True (user created their own household)
   - Assert password_hash NOT in response

   test_get_me_without_token_returns_401:
   - GET /auth/me without Authorization header
   - Assert 401 status
   - Assert response has detail "Could not validate credentials"

   test_get_me_with_invalid_token_returns_401:
   - GET /auth/me with Authorization: Bearer invalid_token
   - Assert 401 status

   test_get_me_email_verified_reflects_user_state:
   - Register user but don't verify email
   - Try to login (should fail with EMAIL_NOT_VERIFIED)
   - Verify email
   - Login successfully
   - GET /auth/me
   - Assert email_verified is True

Follow existing test patterns from tests/integration/api/test_auth.py:
- Use session-scoped database fixtures
- Use TestClient from conftest
- Create helper functions for registration/login flow
  </action>
  <verify>
    Run: pytest tests/integration/api/test_auth_me.py -v
    All tests should pass.

    Per CHECKPOINTS.md, start the actual service and smoke test:
    Run: uvicorn src.main:app --host 0.0.0.0 --port 8000 &
    Run: sleep 2

    Get a token (using existing test user or create one):
    Run: curl -s -X POST http://localhost:8000/auth/register \
      -H "Content-Type: application/json" \
      -d '{"email":"me-test@example.com","password":"Test123!@#","display_name":"Test User"}'

    Verify email (would need token from register response in real flow, skip for smoke test)

    Test 401 without token:
    Run: curl -s -w "%{http_code}" http://localhost:8000/auth/me
    Should return 401

    Kill server:
    Run: pkill -f "uvicorn src.main:app"
  </verify>
  <done>
    - All integration tests pass
    - GET /auth/me with valid JWT returns complete profile
    - GET /auth/me without JWT returns 401
    - Response does not contain password_hash
    - Service starts and responds correctly (per CHECKPOINTS.md)
  </done>
</task>

</tasks>

<verification>
1. All existing tests still pass: pytest tests/ -x -q
2. New tests pass: pytest tests/integration/api/test_auth_me.py -v
3. Service smoke test (per CHECKPOINTS.md):
   - Start service: uvicorn src.main:app --host 0.0.0.0 --port 8000 &
   - GET /auth/me without token returns 401
   - GET /auth/me with valid token returns 200 + profile data
   - Stop service: pkill -f "uvicorn src.main:app"
</verification>

<success_criteria>
1. GET /auth/me with valid JWT returns user profile (user_id, email, display_name, email_verified, created_at)
2. GET /auth/me response includes nested household object with id, name, is_owner
3. GET /auth/me without JWT returns 401 Unauthorized
4. Response does not leak sensitive fields (password_hash not in response)
5. All 408+ existing tests continue to pass
6. Service starts and responds correctly to curl requests (per CHECKPOINTS.md)
</success_criteria>

<output>
After completion, create `.planning/phases/04.2-current-user-metadata-endpoint/04.2-01-SUMMARY.md`
</output>
