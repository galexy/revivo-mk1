---
phase: 02-account-domain
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/domain/model/account_types.py
  - src/domain/model/rewards_balance.py
  - src/domain/model/institution.py
  - src/domain/events/account_events.py
  - tests/unit/domain/test_account_types.py
  - tests/unit/domain/test_rewards_balance.py
  - tests/unit/domain/test_institution.py
autonomous: true

must_haves:
  truths:
    - "AccountType enum has all 7 supported types"
    - "AccountStatus enum has ACTIVE and CLOSED states"
    - "RewardsBalance supports arithmetic with unit validation"
    - "InstitutionDetails validates non-empty name"
    - "Account domain events are defined for lifecycle changes"
  artifacts:
    - path: "src/domain/model/account_types.py"
      provides: "AccountType, AccountStatus, AccountSubtype enums"
      contains: "class AccountType"
    - path: "src/domain/model/rewards_balance.py"
      provides: "RewardsBalance value object"
      contains: "class RewardsBalance"
    - path: "src/domain/model/institution.py"
      provides: "InstitutionDetails value object"
      contains: "class InstitutionDetails"
    - path: "src/domain/events/account_events.py"
      provides: "AccountCreated, AccountUpdated, AccountClosed, AccountReopened, AccountDeleted events"
      contains: "class AccountCreated"
  key_links:
    - from: "src/domain/events/account_events.py"
      to: "src/domain/events/base.py"
      via: "inheritance from DomainEvent"
      pattern: "class Account.*\\(DomainEvent\\)"
---

<objective>
Create supporting types for the Account aggregate: enums, value objects, and domain events.

Purpose: Establish the type system and events that the Account entity will use. These are independent building blocks that must exist before the Account aggregate can be created.
Output: Account type enums, RewardsBalance and InstitutionDetails value objects, account lifecycle domain events, and comprehensive unit tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-account-domain/02-CONTEXT.md
@.planning/phases/02-account-domain/02-RESEARCH.md

# Phase 1 foundations
@src/domain/model/money.py
@src/domain/events/base.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Account Type Enumerations</name>
  <files>src/domain/model/account_types.py, tests/unit/domain/test_account_types.py</files>
  <action>
Create src/domain/model/account_types.py with three StrEnum classes:

1. **AccountType(StrEnum)** - 7 supported account types:
   - CHECKING, SAVINGS, CREDIT_CARD, LOAN, BROKERAGE, IRA, REWARDS
   - Use auto() for values (produces lowercase string values)

2. **AccountStatus(StrEnum)** - Account lifecycle states:
   - ACTIVE, CLOSED
   - Use auto() for values

3. **AccountSubtype(StrEnum)** - Optional subtypes for type-specific logic:
   - IRA subtypes: TRADITIONAL_IRA, ROTH_IRA, SEP_IRA
   - Loan subtypes: MORTGAGE, AUTO_LOAN, PERSONAL_LOAN, LINE_OF_CREDIT
   - Use auto() for values

Follow the StrEnum pattern from 02-RESEARCH.md Pattern 2. Import from `enum` module (Python 3.11+ built-in StrEnum).

Create tests/unit/domain/test_account_types.py with tests for:
- All enum values exist and have string values
- Enum values are comparable as strings
- Enum values serialize to JSON as strings
  </action>
  <verify>
Run: `pytest tests/unit/domain/test_account_types.py -v`
All tests pass. Enums serialize correctly.
  </verify>
  <done>
AccountType has 7 values, AccountStatus has 2 values, AccountSubtype has 7 values. All StrEnum and usable as strings directly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Value Objects (RewardsBalance, InstitutionDetails)</name>
  <files>src/domain/model/rewards_balance.py, src/domain/model/institution.py, tests/unit/domain/test_rewards_balance.py, tests/unit/domain/test_institution.py</files>
  <action>
Create two frozen dataclass value objects following patterns from 02-RESEARCH.md:

**src/domain/model/rewards_balance.py** - RewardsBalance value object:
- Fields: value (Decimal), unit (str)
- Frozen dataclass with slots=True
- __post_init__ validation:
  - Unit cannot be empty/whitespace
  - Normalize value to integer (no decimals for points/miles)
  - Strip and normalize unit string
- Arithmetic methods: __add__, __sub__ (must have same unit)
- __str__ for display: "{value:,} {unit}" (e.g., "50,000 Alaska Miles")
- Follow Pattern 3 from RESEARCH.md

**src/domain/model/institution.py** - InstitutionDetails value object:
- Fields: name (str, required), website (str | None), phone (str | None), notes (str | None)
- Frozen dataclass with slots=True
- __post_init__ validation: name cannot be empty/whitespace
- Follow Pattern 4 from RESEARCH.md

Create comprehensive unit tests:
- tests/unit/domain/test_rewards_balance.py: construction, validation, arithmetic, string representation
- tests/unit/domain/test_institution.py: construction, validation, immutability

Use object.__setattr__ for mutations in __post_init__ (frozen dataclass pattern from Money).
  </action>
  <verify>
Run: `pytest tests/unit/domain/test_rewards_balance.py tests/unit/domain/test_institution.py -v`
All tests pass. Value objects are immutable and validate correctly.
  </verify>
  <done>
RewardsBalance handles points/miles with unit tracking. InstitutionDetails captures financial institution metadata. Both are immutable, validated value objects.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Account Domain Events</name>
  <files>src/domain/events/account_events.py</files>
  <action>
Create src/domain/events/account_events.py with frozen dataclass events inheriting from DomainEvent:

1. **AccountCreated(DomainEvent)** - Emitted when account created
   - Fields: account_name (str), account_type (str)

2. **AccountUpdated(DomainEvent)** - Emitted when account properties change
   - Fields: field (str), old_value (str | None), new_value (str | None)

3. **AccountClosed(DomainEvent)** - Emitted when account closed
   - No additional fields (base class has aggregate_id, aggregate_type, occurred_at)

4. **AccountReopened(DomainEvent)** - Emitted when closed account reopened
   - No additional fields

5. **AccountDeleted(DomainEvent)** - Emitted when account without transactions deleted
   - No additional fields

All events:
- Use @dataclass(frozen=True) decorator
- Inherit from DomainEvent (src/domain/events/base.py)
- Follow Pattern 5 from RESEARCH.md

No separate test file needed - events are simple data classes. They'll be tested via Account aggregate tests.
  </action>
  <verify>
Run: `python -c "from src.domain.events.account_events import AccountCreated, AccountUpdated, AccountClosed, AccountReopened, AccountDeleted; print('Events imported successfully')"`
All events import correctly and inherit from DomainEvent.
  </verify>
  <done>
5 account lifecycle events defined: AccountCreated, AccountUpdated, AccountClosed, AccountReopened, AccountDeleted. All frozen dataclasses extending DomainEvent.
  </done>
</task>

</tasks>

<verification>
Run full domain test suite to ensure no regressions:
```bash
pytest tests/unit/domain/ -v
lint-imports
```

All tests pass. No architecture violations (new domain code has no infrastructure imports).
</verification>

<success_criteria>
- [ ] AccountType enum has 7 values (CHECKING, SAVINGS, CREDIT_CARD, LOAN, BROKERAGE, IRA, REWARDS)
- [ ] AccountStatus enum has 2 values (ACTIVE, CLOSED)
- [ ] AccountSubtype enum has 7 values (3 IRA + 4 loan subtypes)
- [ ] RewardsBalance supports arithmetic with same-unit validation
- [ ] InstitutionDetails validates non-empty name
- [ ] 5 account events defined extending DomainEvent
- [ ] All new unit tests pass
- [ ] lint-imports passes (domain isolation maintained)
</success_criteria>

<output>
After completion, create `.planning/phases/02-account-domain/02-01-SUMMARY.md`
</output>
