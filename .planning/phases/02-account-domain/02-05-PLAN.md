---
phase: 02-account-domain
plan: 05
type: execute
wave: 3
depends_on: ["02-03"]
files_modified:
  - src/adapters/api/schemas/__init__.py
  - src/adapters/api/schemas/account.py
  - src/adapters/api/routes/accounts.py
  - src/adapters/api/app.py
autonomous: true

must_haves:
  truths:
    - "API accepts POST /accounts/{type} to create accounts"
    - "API returns GET /accounts to list user accounts"
    - "API returns GET /accounts/{id} for single account"
    - "API accepts POST /accounts/{id}/close to close account"
    - "API accepts DELETE /accounts/{id} to delete account"
    - "Account numbers are masked in responses (last 4 digits only)"
    - "Current balance equals opening balance (historical balance deferred to Phase 3 when transactions exist)"
  artifacts:
    - path: "src/adapters/api/schemas/account.py"
      provides: "Pydantic request/response schemas"
      contains: "class AccountResponse"
    - path: "src/adapters/api/routes/accounts.py"
      provides: "Account API endpoints"
      contains: "@router."
  key_links:
    - from: "src/adapters/api/routes/accounts.py"
      to: "src/application/services/account_service.py"
      via: "AccountService dependency injection"
      pattern: "AccountService"
    - from: "src/adapters/api/app.py"
      to: "src/adapters/api/routes/accounts.py"
      via: "Router inclusion"
      pattern: "include_router.*accounts"

# Note: ACCT-11 (historical balance over time) is deferred to Phase 3.
# Historical balance requires transactions to exist (balance = opening_balance + sum(transactions)).
# Phase 2 provides current_balance = opening_balance only. Full historical queries come with Phase 3.
---

<objective>
Create REST API endpoints for Account CRUD operations with Pydantic schemas.

Purpose: Expose account functionality via HTTP API. The API layer handles request validation, response formatting, and delegates to the application service.
Output: Account endpoints (create, read, update, delete, close, reopen) with OpenAPI documentation.

Note: Historical balance over time (ACCT-11) is explicitly deferred to Phase 3 when transactions exist. Phase 2 returns current_balance = opening_balance.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-account-domain/02-CONTEXT.md
@.planning/phases/02-account-domain/02-RESEARCH.md

# Existing API structure
@src/adapters/api/app.py
@src/adapters/api/routes/health.py
@src/adapters/api/dependencies.py

# From 02-04 (assumed complete if running in wave)
# @src/application/services/account_service.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Pydantic API Schemas</name>
  <files>src/adapters/api/schemas/__init__.py, src/adapters/api/schemas/account.py</files>
  <action>
**Create src/adapters/api/schemas/__init__.py:**
```python
"""API schemas package."""
from .account import (
    MoneySchema,
    InstitutionSchema,
    RewardsBalanceSchema,
    CreateCheckingAccountRequest,
    CreateSavingsAccountRequest,
    CreateCreditCardAccountRequest,
    CreateLoanAccountRequest,
    CreateBrokerageAccountRequest,
    CreateIRAAccountRequest,
    CreateRewardsAccountRequest,
    UpdateAccountRequest,
    AccountResponse,
    AccountListResponse,
)

__all__ = [
    "MoneySchema",
    "InstitutionSchema",
    "RewardsBalanceSchema",
    "CreateCheckingAccountRequest",
    "CreateSavingsAccountRequest",
    "CreateCreditCardAccountRequest",
    "CreateLoanAccountRequest",
    "CreateBrokerageAccountRequest",
    "CreateIRAAccountRequest",
    "CreateRewardsAccountRequest",
    "UpdateAccountRequest",
    "AccountResponse",
    "AccountListResponse",
]
```

**Create src/adapters/api/schemas/account.py:**

```python
"""Pydantic schemas for Account API."""
from datetime import datetime
from decimal import Decimal
from typing import Annotated

from pydantic import BaseModel, Field, field_validator

from src.domain.model.account_types import AccountType, AccountStatus, AccountSubtype


class MoneySchema(BaseModel):
    """Money representation for API."""
    amount: Decimal
    currency: str = Field(min_length=3, max_length=3, pattern="^[A-Z]{3}$")

    model_config = {"json_schema_extra": {"examples": [{"amount": "1000.00", "currency": "USD"}]}}


class InstitutionSchema(BaseModel):
    """Institution details for API."""
    name: str = Field(min_length=1, max_length=255)
    website: str | None = Field(default=None, max_length=500)
    phone: str | None = Field(default=None, max_length=50)
    notes: str | None = None


class RewardsBalanceSchema(BaseModel):
    """Rewards balance for API."""
    value: Decimal
    unit: str = Field(min_length=1, max_length=100)

    model_config = {"json_schema_extra": {"examples": [{"value": "50000", "unit": "Alaska Miles"}]}}


# Request schemas - one per account type

class CreateCheckingAccountRequest(BaseModel):
    """Request to create a checking account."""
    name: str = Field(min_length=1, max_length=255)
    opening_balance: MoneySchema
    institution: InstitutionSchema | None = None
    opening_date: datetime | None = None
    notes: str | None = None


class CreateSavingsAccountRequest(BaseModel):
    """Request to create a savings account."""
    name: str = Field(min_length=1, max_length=255)
    opening_balance: MoneySchema
    institution: InstitutionSchema | None = None
    opening_date: datetime | None = None
    notes: str | None = None


class CreateCreditCardAccountRequest(BaseModel):
    """Request to create a credit card account."""
    name: str = Field(min_length=1, max_length=255)
    opening_balance: MoneySchema
    credit_limit: MoneySchema
    institution: InstitutionSchema | None = None
    opening_date: datetime | None = None
    notes: str | None = None


class CreateLoanAccountRequest(BaseModel):
    """Request to create a loan account."""
    name: str = Field(min_length=1, max_length=255)
    opening_balance: MoneySchema
    subtype: AccountSubtype | None = None
    apr: Decimal | None = Field(default=None, ge=0, le=1)  # 0.0 to 1.0
    term_months: int | None = Field(default=None, ge=1)
    due_date: datetime | None = None
    institution: InstitutionSchema | None = None
    opening_date: datetime | None = None
    notes: str | None = None


class CreateBrokerageAccountRequest(BaseModel):
    """Request to create a brokerage account."""
    name: str = Field(min_length=1, max_length=255)
    opening_balance: MoneySchema
    institution: InstitutionSchema | None = None
    opening_date: datetime | None = None
    notes: str | None = None


class CreateIRAAccountRequest(BaseModel):
    """Request to create an IRA account."""
    name: str = Field(min_length=1, max_length=255)
    opening_balance: MoneySchema
    subtype: AccountSubtype | None = None
    institution: InstitutionSchema | None = None
    opening_date: datetime | None = None
    notes: str | None = None


class CreateRewardsAccountRequest(BaseModel):
    """Request to create a rewards/miles account."""
    name: str = Field(min_length=1, max_length=255)
    rewards_balance: RewardsBalanceSchema
    institution: InstitutionSchema | None = None
    opening_date: datetime | None = None
    notes: str | None = None


class UpdateAccountRequest(BaseModel):
    """Request to update an account."""
    name: str | None = Field(default=None, min_length=1, max_length=255)
    notes: str | None = None
    institution: InstitutionSchema | None = None


# Response schemas

class AccountResponse(BaseModel):
    """Account response (masks sensitive data)."""
    id: str
    name: str
    account_type: AccountType
    status: AccountStatus
    subtype: AccountSubtype | None = None
    opening_balance: MoneySchema
    opening_date: datetime
    credit_limit: MoneySchema | None = None
    rewards_balance: RewardsBalanceSchema | None = None
    apr: Decimal | None = None
    term_months: int | None = None
    due_date: datetime | None = None
    institution: InstitutionSchema | None = None
    account_number_last4: str | None = None  # Masked!
    closing_date: datetime | None = None
    notes: str | None = None
    sort_order: int
    created_at: datetime
    updated_at: datetime

    model_config = {"from_attributes": True}

    @classmethod
    def from_domain(cls, account) -> "AccountResponse":
        """Convert domain Account to response schema."""
        return cls(
            id=str(account.id),
            name=account.name,
            account_type=account.account_type,
            status=account.status,
            subtype=account.subtype,
            opening_balance=MoneySchema(
                amount=account.opening_balance.amount,
                currency=account.opening_balance.currency,
            ) if account.opening_balance else None,
            opening_date=account.opening_date,
            credit_limit=MoneySchema(
                amount=account.credit_limit.amount,
                currency=account.credit_limit.currency,
            ) if account.credit_limit else None,
            rewards_balance=RewardsBalanceSchema(
                value=account.rewards_balance.value,
                unit=account.rewards_balance.unit,
            ) if account.rewards_balance else None,
            apr=account.apr,
            term_months=account.term_months,
            due_date=account.due_date,
            institution=InstitutionSchema(
                name=account.institution.name,
                website=account.institution.website,
                phone=account.institution.phone,
                notes=account.institution.notes,
            ) if account.institution else None,
            account_number_last4=account.encrypted_account_number[-4:] if account.encrypted_account_number else None,
            closing_date=account.closing_date,
            notes=account.notes,
            sort_order=account.sort_order,
            created_at=account.created_at,
            updated_at=account.updated_at,
        )


class AccountListResponse(BaseModel):
    """List of accounts response."""
    accounts: list[AccountResponse]
    count: int
```
  </action>
  <verify>
Run: `python -c "from src.adapters.api.schemas.account import AccountResponse, CreateCheckingAccountRequest; print('Schemas imported')"`
All schemas import correctly.
  </verify>
  <done>
Pydantic schemas created for all account types, with proper validation and response masking.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Account API Routes</name>
  <files>src/adapters/api/routes/accounts.py</files>
  <action>
Create src/adapters/api/routes/accounts.py with FastAPI router:

```python
"""Account API routes."""
from decimal import Decimal
from typing import Annotated

from fastapi import APIRouter, Depends, HTTPException, Query, status

from src.adapters.api.schemas.account import (
    CreateCheckingAccountRequest,
    CreateSavingsAccountRequest,
    CreateCreditCardAccountRequest,
    CreateLoanAccountRequest,
    CreateBrokerageAccountRequest,
    CreateIRAAccountRequest,
    CreateRewardsAccountRequest,
    UpdateAccountRequest,
    AccountResponse,
    AccountListResponse,
)
from src.application.services.account_service import AccountService, AccountError
from src.domain.model.entity_id import AccountId, UserId
from src.domain.model.money import Money
from src.domain.model.account_types import AccountType, AccountStatus
from src.domain.model.rewards_balance import RewardsBalance
from src.domain.model.institution import InstitutionDetails
from src.adapters.persistence.unit_of_work import SqlAlchemyUnitOfWork
from src.adapters.persistence.database import get_async_session

router = APIRouter(prefix="/accounts", tags=["accounts"])


# Dependency to get AccountService
async def get_account_service():
    """Get AccountService with UoW dependency."""
    # For now, create sync UoW. In production, use async session.
    # This is a simplified approach - full async support in Phase 4.
    from src.adapters.persistence.database import sync_session_factory
    session = sync_session_factory()
    uow = SqlAlchemyUnitOfWork(session)
    try:
        yield AccountService(uow)
    finally:
        session.close()


# Placeholder for user ID extraction from auth (Phase 4)
def get_current_user_id() -> UserId:
    """Get current user ID from auth context.

    TODO: Implement proper auth in Phase 4.
    For now, return a placeholder user ID.
    """
    return UserId.from_string("user_01h455vb4pex5vsknk084sn02q")


# Helper to convert request to domain objects
def money_from_schema(schema) -> Money:
    """Convert MoneySchema to Money domain object."""
    return Money(Decimal(str(schema.amount)), schema.currency)


def institution_from_schema(schema) -> InstitutionDetails | None:
    """Convert InstitutionSchema to InstitutionDetails or None."""
    if schema is None:
        return None
    return InstitutionDetails(
        name=schema.name,
        website=schema.website,
        phone=schema.phone,
        notes=schema.notes,
    )


def rewards_from_schema(schema) -> RewardsBalance:
    """Convert RewardsBalanceSchema to RewardsBalance."""
    return RewardsBalance(Decimal(str(schema.value)), schema.unit)


def handle_result(result):
    """Convert service result to response or raise HTTPException."""
    if isinstance(result, AccountError):
        status_code = {
            "ACCOUNT_NOT_FOUND": status.HTTP_404_NOT_FOUND,
            "VALIDATION_ERROR": status.HTTP_400_BAD_REQUEST,
            "INVALID_STATE": status.HTTP_409_CONFLICT,
            "HAS_TRANSACTIONS": status.HTTP_409_CONFLICT,
        }.get(result.code, status.HTTP_400_BAD_REQUEST)
        raise HTTPException(status_code=status_code, detail=result.message)
    return result


# CREATE endpoints

@router.post("/checking", response_model=AccountResponse, status_code=status.HTTP_201_CREATED)
async def create_checking_account(
    request: CreateCheckingAccountRequest,
    service: Annotated[AccountService, Depends(get_account_service)],
    user_id: Annotated[UserId, Depends(get_current_user_id)],
):
    """Create a new checking account."""
    result = service.create_checking_account(
        user_id=user_id,
        name=request.name,
        opening_balance=money_from_schema(request.opening_balance),
        institution_name=request.institution.name if request.institution else None,
        opening_date=request.opening_date,
        notes=request.notes,
    )
    account = handle_result(result)
    return AccountResponse.from_domain(account)


@router.post("/savings", response_model=AccountResponse, status_code=status.HTTP_201_CREATED)
async def create_savings_account(
    request: CreateSavingsAccountRequest,
    service: Annotated[AccountService, Depends(get_account_service)],
    user_id: Annotated[UserId, Depends(get_current_user_id)],
):
    """Create a new savings account."""
    result = service.create_savings_account(
        user_id=user_id,
        name=request.name,
        opening_balance=money_from_schema(request.opening_balance),
        institution_name=request.institution.name if request.institution else None,
        opening_date=request.opening_date,
        notes=request.notes,
    )
    account = handle_result(result)
    return AccountResponse.from_domain(account)


@router.post("/credit-card", response_model=AccountResponse, status_code=status.HTTP_201_CREATED)
async def create_credit_card_account(
    request: CreateCreditCardAccountRequest,
    service: Annotated[AccountService, Depends(get_account_service)],
    user_id: Annotated[UserId, Depends(get_current_user_id)],
):
    """Create a new credit card account."""
    result = service.create_credit_card_account(
        user_id=user_id,
        name=request.name,
        opening_balance=money_from_schema(request.opening_balance),
        credit_limit=money_from_schema(request.credit_limit),
        institution_name=request.institution.name if request.institution else None,
        opening_date=request.opening_date,
        notes=request.notes,
    )
    account = handle_result(result)
    return AccountResponse.from_domain(account)


@router.post("/loan", response_model=AccountResponse, status_code=status.HTTP_201_CREATED)
async def create_loan_account(
    request: CreateLoanAccountRequest,
    service: Annotated[AccountService, Depends(get_account_service)],
    user_id: Annotated[UserId, Depends(get_current_user_id)],
):
    """Create a new loan account."""
    result = service.create_loan_account(
        user_id=user_id,
        name=request.name,
        opening_balance=money_from_schema(request.opening_balance),
        subtype=request.subtype,
        apr=request.apr,
        term_months=request.term_months,
        due_date=request.due_date,
        institution_name=request.institution.name if request.institution else None,
        opening_date=request.opening_date,
        notes=request.notes,
    )
    account = handle_result(result)
    return AccountResponse.from_domain(account)


@router.post("/brokerage", response_model=AccountResponse, status_code=status.HTTP_201_CREATED)
async def create_brokerage_account(
    request: CreateBrokerageAccountRequest,
    service: Annotated[AccountService, Depends(get_account_service)],
    user_id: Annotated[UserId, Depends(get_current_user_id)],
):
    """Create a new brokerage account."""
    result = service.create_brokerage_account(
        user_id=user_id,
        name=request.name,
        opening_balance=money_from_schema(request.opening_balance),
        institution_name=request.institution.name if request.institution else None,
        opening_date=request.opening_date,
        notes=request.notes,
    )
    account = handle_result(result)
    return AccountResponse.from_domain(account)


@router.post("/ira", response_model=AccountResponse, status_code=status.HTTP_201_CREATED)
async def create_ira_account(
    request: CreateIRAAccountRequest,
    service: Annotated[AccountService, Depends(get_account_service)],
    user_id: Annotated[UserId, Depends(get_current_user_id)],
):
    """Create a new IRA account."""
    result = service.create_ira_account(
        user_id=user_id,
        name=request.name,
        opening_balance=money_from_schema(request.opening_balance),
        subtype=request.subtype,
        institution_name=request.institution.name if request.institution else None,
        opening_date=request.opening_date,
        notes=request.notes,
    )
    account = handle_result(result)
    return AccountResponse.from_domain(account)


@router.post("/rewards", response_model=AccountResponse, status_code=status.HTTP_201_CREATED)
async def create_rewards_account(
    request: CreateRewardsAccountRequest,
    service: Annotated[AccountService, Depends(get_account_service)],
    user_id: Annotated[UserId, Depends(get_current_user_id)],
):
    """Create a new rewards/miles account."""
    result = service.create_rewards_account(
        user_id=user_id,
        name=request.name,
        rewards_balance=rewards_from_schema(request.rewards_balance),
        institution_name=request.institution.name if request.institution else None,
        opening_date=request.opening_date,
        notes=request.notes,
    )
    account = handle_result(result)
    return AccountResponse.from_domain(account)


# READ endpoints

@router.get("", response_model=AccountListResponse)
async def list_accounts(
    service: Annotated[AccountService, Depends(get_account_service)],
    user_id: Annotated[UserId, Depends(get_current_user_id)],
    status_filter: Annotated[AccountStatus | None, Query(alias="status")] = None,
    type_filter: Annotated[AccountType | None, Query(alias="type")] = None,
):
    """List all accounts for current user."""
    accounts = service.get_user_accounts(
        user_id=user_id,
        status=status_filter,
        account_type=type_filter,
    )
    return AccountListResponse(
        accounts=[AccountResponse.from_domain(a) for a in accounts],
        count=len(accounts),
    )


@router.get("/{account_id}", response_model=AccountResponse)
async def get_account(
    account_id: str,
    service: Annotated[AccountService, Depends(get_account_service)],
):
    """Get a single account by ID."""
    try:
        aid = AccountId.from_string(account_id)
    except ValueError:
        raise HTTPException(status_code=400, detail="Invalid account ID format")

    result = service.get_account(aid)
    account = handle_result(result)
    return AccountResponse.from_domain(account)


# UPDATE endpoint

@router.patch("/{account_id}", response_model=AccountResponse)
async def update_account(
    account_id: str,
    request: UpdateAccountRequest,
    service: Annotated[AccountService, Depends(get_account_service)],
    user_id: Annotated[UserId, Depends(get_current_user_id)],
):
    """Update account properties."""
    try:
        aid = AccountId.from_string(account_id)
    except ValueError:
        raise HTTPException(status_code=400, detail="Invalid account ID format")

    # Update name if provided
    if request.name is not None:
        result = service.update_account_name(aid, request.name, updated_by=user_id)
        account = handle_result(result)
        return AccountResponse.from_domain(account)

    # If nothing to update, just return the account
    result = service.get_account(aid)
    account = handle_result(result)
    return AccountResponse.from_domain(account)


# LIFECYCLE endpoints

@router.post("/{account_id}/close", response_model=AccountResponse)
async def close_account(
    account_id: str,
    service: Annotated[AccountService, Depends(get_account_service)],
    user_id: Annotated[UserId, Depends(get_current_user_id)],
):
    """Close an account."""
    try:
        aid = AccountId.from_string(account_id)
    except ValueError:
        raise HTTPException(status_code=400, detail="Invalid account ID format")

    result = service.close_account(aid, closed_by=user_id)
    account = handle_result(result)
    return AccountResponse.from_domain(account)


@router.post("/{account_id}/reopen", response_model=AccountResponse)
async def reopen_account(
    account_id: str,
    service: Annotated[AccountService, Depends(get_account_service)],
    user_id: Annotated[UserId, Depends(get_current_user_id)],
):
    """Reopen a closed account."""
    try:
        aid = AccountId.from_string(account_id)
    except ValueError:
        raise HTTPException(status_code=400, detail="Invalid account ID format")

    result = service.reopen_account(aid, reopened_by=user_id)
    account = handle_result(result)
    return AccountResponse.from_domain(account)


@router.delete("/{account_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_account(
    account_id: str,
    service: Annotated[AccountService, Depends(get_account_service)],
):
    """Delete an account (only if no transactions exist)."""
    try:
        aid = AccountId.from_string(account_id)
    except ValueError:
        raise HTTPException(status_code=400, detail="Invalid account ID format")

    result = service.delete_account(aid)
    if result is not None:  # Error
        handle_result(result)
    # Success returns None, FastAPI returns 204 No Content
```
  </action>
  <verify>
Run: `python -c "from src.adapters.api.routes.accounts import router; print('Routes imported')"`
Routes import correctly.
  </verify>
  <done>
Account API routes created with endpoints for all CRUD operations plus close/reopen.
  </done>
</task>

<task type="auto">
  <name>Task 3: Register Account Routes in App</name>
  <files>src/adapters/api/app.py</files>
  <action>
Update src/adapters/api/app.py to include the accounts router:

1. Add import at top (after other route imports):
```python
from src.adapters.api.routes.accounts import router as accounts_router
```

2. Add router to app (after health router):
```python
app.include_router(accounts_router)
```

The accounts router has prefix="/accounts" and tags=["accounts"] already set, so it will appear correctly in OpenAPI docs.

3. **Verify mappers are started in lifespan event.** The app.py lifespan should call `start_mappers()`. Check that this exists:
```python
from contextlib import asynccontextmanager

@asynccontextmanager
async def lifespan(app: FastAPI):
    # Startup: start ORM mappers
    from src.adapters.persistence.orm.mappers import start_mappers
    start_mappers()
    yield
    # Shutdown: nothing needed

app = FastAPI(lifespan=lifespan, ...)
```

If lifespan doesn't exist or doesn't call start_mappers(), add it.
  </action>
  <verify>
Run verification commands to confirm:
```bash
# Verify app imports and routes registered
python -c "
from src.adapters.api.app import app
from fastapi.routing import APIRoute
routes = [r for r in app.routes if isinstance(r, APIRoute)]
account_routes = [r.path for r in routes if 'account' in r.path]
print(f'Account routes found: {len(account_routes)}')
assert len(account_routes) >= 10, f'Expected 10+ account routes, found {len(account_routes)}'
assert '/accounts/checking' in account_routes, 'Missing /accounts/checking route'
assert '/accounts/{account_id}' in account_routes, 'Missing /accounts/{account_id} route'
print('All account routes registered successfully')
"

# Verify mappers start correctly via lifespan simulation
python -c "
from src.adapters.persistence.orm.mappers import start_mappers, _mappers_started
start_mappers()
assert _mappers_started, 'Mappers not started'
print('Mappers started successfully')
"
```
Both verifications pass.
  </verify>
  <done>
Account routes registered in FastAPI app with proper lifespan handling for ORM mappers. All 14 endpoints visible and verified.
  </done>
</task>

</tasks>

<verification>
Verify API works end-to-end:
```bash
# Run lint-imports
lint-imports

# Comprehensive route verification
python -c "
from src.adapters.api.app import app
from fastapi.routing import APIRoute

routes = [r for r in app.routes if isinstance(r, APIRoute)]
account_routes = [r.path for r in routes if 'account' in r.path]

print(f'Total account routes: {len(account_routes)}')
for route in sorted(account_routes):
    print(f'  {route}')

# Verify all expected routes exist
expected_routes = [
    '/accounts/checking',
    '/accounts/savings',
    '/accounts/credit-card',
    '/accounts/loan',
    '/accounts/brokerage',
    '/accounts/ira',
    '/accounts/rewards',
    '/accounts',
    '/accounts/{account_id}',
    '/accounts/{account_id}/close',
    '/accounts/{account_id}/reopen',
]

for expected in expected_routes:
    assert expected in account_routes, f'Missing route: {expected}'

print('All expected routes registered')
"
```
</verification>

<success_criteria>
- [ ] Pydantic schemas for all 7 account types (create requests)
- [ ] AccountResponse with masked account_number_last4
- [ ] POST /accounts/{type} endpoints for all 7 types
- [ ] GET /accounts with optional status and type filters
- [ ] GET /accounts/{id} returns single account
- [ ] PATCH /accounts/{id} updates account
- [ ] POST /accounts/{id}/close closes account
- [ ] POST /accounts/{id}/reopen reopens account
- [ ] DELETE /accounts/{id} deletes account (if no transactions)
- [ ] Routes registered in app.py (verified: 10+ routes containing 'account')
- [ ] Route registration verified: /accounts/checking exists
- [ ] Mappers started via lifespan (verified: _mappers_started is True)
- [ ] Proper HTTP status codes (201, 400, 404, 409)
- [ ] lint-imports passes
</success_criteria>

<output>
After completion, create `.planning/phases/02-account-domain/02-05-SUMMARY.md`
</output>
