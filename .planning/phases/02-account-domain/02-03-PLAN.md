---
phase: 02-account-domain
plan: 03
type: execute
wave: 2
depends_on: ["02-01", "02-02"]
files_modified:
  - src/adapters/persistence/orm/tables.py
  - alembic/versions/002_create_accounts_table.py
  - src/adapters/persistence/orm/mappers.py
  - src/adapters/persistence/repositories/__init__.py
  - src/adapters/persistence/repositories/account.py
  - src/adapters/persistence/unit_of_work.py
autonomous: true

must_haves:
  truths:
    - "accounts table exists in database with all required columns"
    - "Alembic migration applies cleanly to fresh database"
    - "Account entity can be persisted and retrieved via repository"
    - "Value objects (Money, InstitutionDetails, RewardsBalance) map correctly"
    - "UnitOfWork provides access to account repository"
  artifacts:
    - path: "src/adapters/persistence/orm/tables.py"
      provides: "accounts table definition"
      contains: 'accounts = Table('
    - path: "alembic/versions/002_create_accounts_table.py"
      provides: "Migration for accounts table"
      contains: "def upgrade"
    - path: "src/adapters/persistence/repositories/account.py"
      provides: "SqlAlchemyAccountRepository implementation"
      contains: "class SqlAlchemyAccountRepository"
    - path: "src/adapters/persistence/orm/mappers.py"
      provides: "Account imperative mapping"
      contains: "mapper_registry.map_imperatively"
  key_links:
    - from: "src/adapters/persistence/repositories/account.py"
      to: "src/domain/model/account.py"
      via: "Account entity operations"
      pattern: "from src.domain.model.account import Account"
    - from: "src/adapters/persistence/orm/mappers.py"
      to: "src/adapters/persistence/orm/tables.py"
      via: "Table to entity mapping"
      pattern: "from .tables import accounts"
---

<objective>
Implement persistence layer for Account aggregate: database table, migration, imperative mapper, and repository.

Purpose: Enable Account entities to be stored and retrieved from PostgreSQL. This bridges the domain layer with the database following Data Mapper pattern.
Output: accounts table with migration, SQLAlchemy imperative mapping, and SqlAlchemyAccountRepository implementation.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-account-domain/02-CONTEXT.md
@.planning/phases/02-account-domain/02-RESEARCH.md

# Phase 1 persistence infrastructure
@src/adapters/persistence/orm/tables.py
@src/adapters/persistence/orm/mappers.py
@src/adapters/persistence/orm/base.py
@src/adapters/persistence/unit_of_work.py

# Domain entities (from 02-01 and 02-02)
# @src/domain/model/account.py
# @src/domain/model/account_types.py
# @src/domain/model/rewards_balance.py
# @src/domain/model/institution.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add accounts Table Definition and Migration</name>
  <files>src/adapters/persistence/orm/tables.py, alembic/versions/002_create_accounts_table.py</files>
  <action>
**Update src/adapters/persistence/orm/tables.py:**

Add imports at top:
```python
from sqlalchemy import Numeric, Integer, Text
```

Add accounts table definition after encrypted_secrets table (follow Pattern 7 from RESEARCH.md):

```python
# Accounts table with single table inheritance (type discriminator)
accounts = Table(
    "accounts",
    metadata,
    # Identity
    Column("id", String(36), primary_key=True),  # acct_xxx
    Column("user_id", String(36), ForeignKey("users.id"), nullable=False),

    # Core fields
    Column("name", String(255), nullable=False),
    Column("account_type", String(50), nullable=False),  # Discriminator
    Column("status", String(20), nullable=False, default="active"),
    Column("subtype", String(50), nullable=True),

    # Balance tracking
    Column("opening_balance_amount", Numeric(19, 4), nullable=False),
    Column("opening_balance_currency", String(3), nullable=False),
    Column("opening_date", DateTime(timezone=True), nullable=False),

    # Type-specific fields (nullable for types that don't use them)
    Column("credit_limit_amount", Numeric(19, 4), nullable=True),
    Column("credit_limit_currency", String(3), nullable=True),
    Column("apr", Numeric(5, 4), nullable=True),  # e.g., 0.1999 for 19.99%
    Column("term_months", Integer, nullable=True),
    Column("due_date", DateTime(timezone=True), nullable=True),

    # Rewards-specific
    Column("rewards_value", Numeric(19, 0), nullable=True),
    Column("rewards_unit", String(100), nullable=True),

    # Institution
    Column("institution_name", String(255), nullable=True),
    Column("institution_website", String(500), nullable=True),
    Column("institution_phone", String(50), nullable=True),
    Column("institution_notes", Text, nullable=True),

    # Encrypted account number (AES-256-GCM via FieldEncryption)
    Column("encrypted_account_number", Text, nullable=True),

    # Lifecycle
    Column("closing_date", DateTime(timezone=True), nullable=True),
    Column("notes", Text, nullable=True),
    Column("sort_order", Integer, nullable=False, default=0),

    # Audit
    Column("created_at", DateTime(timezone=True), nullable=False),
    Column("updated_at", DateTime(timezone=True), nullable=False),
    Column("created_by", String(36), nullable=True),
    Column("updated_by", String(36), nullable=True),

    # Indexes
    Index("ix_accounts_user_id", "user_id"),
    Index("ix_accounts_user_type", "user_id", "account_type"),
    Index("ix_accounts_user_status", "user_id", "status"),
)
```

**Create alembic/versions/002_create_accounts_table.py:**

Generate with: `alembic revision -m "create_accounts_table"` then edit to match table definition.

Migration should:
- Create accounts table with all columns
- Create indexes: ix_accounts_user_id, ix_accounts_user_type, ix_accounts_user_status
- Foreign key to users.id
- downgrade() drops the table

Use revision number format matching existing migrations (check 001_*.py for pattern).
  </action>
  <verify>
Run:
```bash
alembic upgrade head
alembic downgrade -1
alembic upgrade head
```
Migration applies and rolls back cleanly.
  </verify>
  <done>
accounts table defined in tables.py with all columns for Account aggregate. Migration 002 created and applies cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Account Imperative Mapping</name>
  <files>src/adapters/persistence/orm/mappers.py</files>
  <action>
Update src/adapters/persistence/orm/mappers.py to add Account entity mapping.

Add at top of file (after existing imports):
```python
from sqlalchemy.orm import composite
```

Inside start_mappers() function, add Account mapping after the `if _mappers_started: return` check:

```python
    # Account aggregate mapping
    from src.domain.model.account import Account
    from src.domain.model.entity_id import AccountId, UserId
    from src.domain.model.money import Money
    from src.domain.model.account_types import AccountType, AccountStatus, AccountSubtype
    from src.domain.model.rewards_balance import RewardsBalance
    from src.domain.model.institution import InstitutionDetails
    from .tables import accounts

    mapper_registry.map_imperatively(
        Account,
        accounts,
        properties={
            # Map _events as excluded (transient, not persisted)
        },
        exclude_properties=["_events"],
    )
```

**IMPORTANT:** SQLAlchemy's imperative mapping with composite() for value objects can be complex. For Phase 2, use a simpler approach:

1. Let SQLAlchemy map primitive columns directly to Account fields
2. Handle value object reconstruction in the repository layer (not in mapper)
3. The Account dataclass fields that are value objects will be set via repository when loading

The mapper maps:
- id -> accounts.c.id (will be string, convert to AccountId in repo)
- user_id -> accounts.c.user_id (will be string, convert to UserId in repo)
- All primitive fields map directly
- Value objects (Money, InstitutionDetails, RewardsBalance) handled in repository

This avoids complex composite() mappings that can cause issues with nullable values.
  </action>
  <verify>
Run: `python -c "from src.adapters.persistence.orm.mappers import start_mappers; start_mappers(); print('Mappers registered')"`
Mapping registers without errors.
  </verify>
  <done>
Account entity mapped to accounts table. Value object handling delegated to repository layer for simplicity.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create SqlAlchemyAccountRepository</name>
  <files>src/adapters/persistence/repositories/__init__.py, src/adapters/persistence/repositories/account.py, src/adapters/persistence/unit_of_work.py</files>
  <action>
**Create src/adapters/persistence/repositories/__init__.py:**
```python
"""Persistence repositories package."""
from .account import SqlAlchemyAccountRepository

__all__ = ["SqlAlchemyAccountRepository"]
```

**Create src/adapters/persistence/repositories/account.py:**

Implement SqlAlchemyAccountRepository that:
1. Handles conversion between domain value objects and database primitives
2. Implements AccountRepository protocol methods

```python
from datetime import datetime
from decimal import Decimal
from sqlalchemy import select
from sqlalchemy.orm import Session

from src.domain.model.account import Account
from src.domain.model.entity_id import AccountId, UserId
from src.domain.model.money import Money
from src.domain.model.account_types import AccountType, AccountStatus, AccountSubtype
from src.domain.model.rewards_balance import RewardsBalance
from src.domain.model.institution import InstitutionDetails
from src.domain.exceptions import EntityNotFoundError


class SqlAlchemyAccountRepository:
    """SQLAlchemy implementation of AccountRepository.

    Handles value object reconstruction when loading from database.
    """

    def __init__(self, session: Session):
        self._session = session

    def add(self, account: Account) -> None:
        """Add account - convert value objects to primitives for storage."""
        self._session.add(account)

    def get(self, account_id: AccountId) -> Account | None:
        """Get account by ID."""
        account = self._session.get(Account, str(account_id))
        if account:
            self._reconstruct_value_objects(account)
        return account

    def get_or_raise(self, account_id: AccountId) -> Account:
        """Get account by ID, raise if not found."""
        account = self.get(account_id)
        if account is None:
            raise EntityNotFoundError(
                "Account not found",
                context={"account_id": str(account_id)},
            )
        return account

    def get_by_user(
        self,
        user_id: UserId,
        status: AccountStatus | None = None,
        account_type: AccountType | None = None,
    ) -> list[Account]:
        """Get all accounts for a user with optional filters."""
        # Build query - note: SQLAlchemy stores enums as strings
        stmt = select(Account).where(Account.user_id == str(user_id))

        if status is not None:
            stmt = stmt.where(Account.status == status.value)
        if account_type is not None:
            stmt = stmt.where(Account.account_type == account_type.value)

        stmt = stmt.order_by(Account.sort_order, Account.name)

        result = self._session.execute(stmt)
        accounts = list(result.scalars().all())

        for account in accounts:
            self._reconstruct_value_objects(account)

        return accounts

    def delete(self, account: Account) -> None:
        """Delete account from session."""
        self._session.delete(account)

    def has_transactions(self, account_id: AccountId) -> bool:
        """Check if account has transactions.

        Note: Transactions table added in Phase 3.
        For now, always returns False (can be deleted).
        TODO: Implement in Phase 3 when transactions table exists.
        """
        return False

    def _reconstruct_value_objects(self, account: Account) -> None:
        """Reconstruct value objects from database primitives.

        SQLAlchemy loads primitives. We convert them back to value objects.
        Uses object.__setattr__ because Account has slots=True.
        """
        # AccountId and UserId
        if isinstance(account.id, str):
            object.__setattr__(account, "id", AccountId.from_string(account.id))
        if isinstance(account.user_id, str):
            object.__setattr__(account, "user_id", UserId.from_string(account.user_id))

        # AccountType and AccountStatus (stored as strings)
        if isinstance(account.account_type, str):
            object.__setattr__(account, "account_type", AccountType(account.account_type))
        if isinstance(account.status, str):
            object.__setattr__(account, "status", AccountStatus(account.status))
        if account.subtype and isinstance(account.subtype, str):
            object.__setattr__(account, "subtype", AccountSubtype(account.subtype))

        # Ensure _events list exists (transient, not loaded from DB)
        if not hasattr(account, "_events") or account._events is None:
            object.__setattr__(account, "_events", [])
```

**Update src/adapters/persistence/unit_of_work.py:**

Add accounts property to SqlAlchemyUnitOfWork class:

1. Import SqlAlchemyAccountRepository at top
2. Add `_accounts: SqlAlchemyAccountRepository | None = None` attribute
3. Add property:
```python
@property
def accounts(self) -> SqlAlchemyAccountRepository:
    if self._accounts is None:
        self._accounts = SqlAlchemyAccountRepository(self._session)
    return self._accounts
```

NOTE: The current UnitOfWork may need to be updated. Check existing implementation and add accounts repository access.
  </action>
  <verify>
Run:
```bash
python -c "
from src.adapters.persistence.repositories.account import SqlAlchemyAccountRepository
from src.adapters.persistence.unit_of_work import SqlAlchemyUnitOfWork
print('Repository and UoW imports successful')
"
```
Imports work correctly.
  </verify>
  <done>
SqlAlchemyAccountRepository implemented with value object reconstruction. UnitOfWork updated with accounts property.
  </done>
</task>

</tasks>

<verification>
Run migration and verify database state:
```bash
# Apply migration
alembic upgrade head

# Verify table exists
python -c "
from src.adapters.persistence.database import sync_engine
from sqlalchemy import inspect
inspector = inspect(sync_engine)
tables = inspector.get_table_names()
print('Tables:', tables)
assert 'accounts' in tables, 'accounts table missing'
print('accounts table verified')
"

# Run lint-imports
lint-imports
```
</verification>

<success_criteria>
- [ ] accounts table defined with all columns per RESEARCH.md Pattern 7
- [ ] Migration 002 applies cleanly
- [ ] Indexes created: ix_accounts_user_id, ix_accounts_user_type, ix_accounts_user_status
- [ ] Account imperative mapping registered without errors
- [ ] SqlAlchemyAccountRepository implements all protocol methods
- [ ] Value object reconstruction works (AccountId, UserId, enums)
- [ ] UnitOfWork.accounts property returns repository
- [ ] has_transactions returns False (placeholder for Phase 3)
- [ ] lint-imports passes
</success_criteria>

<output>
After completion, create `.planning/phases/02-account-domain/02-03-SUMMARY.md`
</output>
