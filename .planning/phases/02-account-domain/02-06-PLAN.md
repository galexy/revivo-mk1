---
phase: 02-account-domain
plan: 06
type: execute
wave: 4
depends_on: ["02-03", "02-04", "02-05"]
files_modified:
  - tests/integration/test_account_repository.py
  - tests/integration/test_account_api.py
autonomous: false

must_haves:
  truths:
    - "Account can be persisted and retrieved from database"
    - "Account value objects reconstruct correctly on load"
    - "API endpoints accept requests and return proper responses"
    - "All Phase 2 tests pass"
    - "Human verified account creation through API"
  artifacts:
    - path: "tests/integration/test_account_repository.py"
      provides: "Repository integration tests"
      contains: "def test_"
    - path: "tests/integration/test_account_api.py"
      provides: "API integration tests"
      contains: "def test_"
  key_links:
    - from: "tests/integration/test_account_repository.py"
      to: "src/adapters/persistence/repositories/account.py"
      via: "Repository under test"
      pattern: "SqlAlchemyAccountRepository"
---

<objective>
Create integration tests for Account repository and API, then verify Phase 2 is complete.

Purpose: Integration tests verify the full stack works together. Human verification confirms the API is usable and behaves correctly.
Output: Repository and API integration tests, verified Phase 2 completion.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-account-domain/02-CONTEXT.md
@.planning/phases/02-account-domain/02-RESEARCH.md

# Phase 1 test infrastructure
@tests/integration/conftest.py

# Prior summaries
# @.planning/phases/02-account-domain/02-03-SUMMARY.md
# @.planning/phases/02-account-domain/02-04-SUMMARY.md
# @.planning/phases/02-account-domain/02-05-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Account Repository Integration Tests</name>
  <files>tests/integration/test_account_repository.py</files>
  <action>
Create tests/integration/test_account_repository.py with database integration tests:

```python
"""Integration tests for Account repository."""
from decimal import Decimal
import pytest

from src.domain.model.account import Account
from src.domain.model.entity_id import AccountId, UserId
from src.domain.model.money import Money
from src.domain.model.account_types import AccountType, AccountStatus, AccountSubtype
from src.domain.model.rewards_balance import RewardsBalance
from src.domain.model.institution import InstitutionDetails
from src.adapters.persistence.repositories.account import SqlAlchemyAccountRepository
from src.adapters.persistence.orm.mappers import start_mappers


@pytest.fixture(scope="module", autouse=True)
def setup_mappers():
    """Ensure mappers are registered before tests."""
    start_mappers()


@pytest.fixture
def user_id(db_session):
    """Create a test user and return ID."""
    from src.adapters.persistence.orm.tables import users
    uid = UserId.generate()
    db_session.execute(
        users.insert().values(
            id=str(uid),
            email=f"test-{uid}@example.com",
            email_verified=True,
        )
    )
    db_session.commit()
    return uid


@pytest.fixture
def repository(db_session):
    """Create repository with test session."""
    return SqlAlchemyAccountRepository(db_session)


@pytest.fixture
def usd_balance():
    return Money(Decimal("1000.00"), "USD")


class TestAccountPersistence:
    """Test Account CRUD operations."""

    def test_add_and_get_checking_account(self, repository, db_session, user_id, usd_balance):
        """Can persist and retrieve a checking account."""
        account = Account.create_checking(
            user_id=user_id,
            name="Test Checking",
            opening_balance=usd_balance,
        )
        account.clear_events()

        repository.add(account)
        db_session.commit()

        # Clear session cache to force database read
        db_session.expire_all()

        loaded = repository.get(account.id)

        assert loaded is not None
        assert loaded.id == account.id
        assert loaded.name == "Test Checking"
        assert loaded.account_type == AccountType.CHECKING
        assert loaded.status == AccountStatus.ACTIVE
        assert loaded.opening_balance.amount == usd_balance.amount
        assert loaded.opening_balance.currency == usd_balance.currency

    def test_add_credit_card_with_limit(self, repository, db_session, user_id, usd_balance):
        """Can persist credit card with credit limit."""
        credit_limit = Money(Decimal("5000.00"), "USD")
        account = Account.create_credit_card(
            user_id=user_id,
            name="Visa Card",
            opening_balance=usd_balance,
            credit_limit=credit_limit,
        )
        account.clear_events()

        repository.add(account)
        db_session.commit()
        db_session.expire_all()

        loaded = repository.get(account.id)

        assert loaded is not None
        assert loaded.account_type == AccountType.CREDIT_CARD
        assert loaded.credit_limit is not None
        assert loaded.credit_limit.amount == credit_limit.amount

    def test_add_loan_with_details(self, repository, db_session, user_id, usd_balance):
        """Can persist loan with APR, term, subtype."""
        account = Account.create_loan(
            user_id=user_id,
            name="Mortgage",
            opening_balance=usd_balance,
            subtype=AccountSubtype.MORTGAGE,
            apr=Decimal("0.0599"),
            term_months=360,
        )
        account.clear_events()

        repository.add(account)
        db_session.commit()
        db_session.expire_all()

        loaded = repository.get(account.id)

        assert loaded is not None
        assert loaded.account_type == AccountType.LOAN
        assert loaded.subtype == AccountSubtype.MORTGAGE
        assert loaded.apr == Decimal("0.0599")
        assert loaded.term_months == 360

    def test_add_rewards_account(self, repository, db_session, user_id):
        """Can persist rewards account with RewardsBalance."""
        rewards = RewardsBalance(Decimal("50000"), "Alaska Miles")
        account = Account.create_rewards(
            user_id=user_id,
            name="Alaska Airlines",
            rewards_balance=rewards,
        )
        account.clear_events()

        repository.add(account)
        db_session.commit()
        db_session.expire_all()

        loaded = repository.get(account.id)

        assert loaded is not None
        assert loaded.account_type == AccountType.REWARDS
        assert loaded.rewards_balance is not None
        assert loaded.rewards_balance.value == Decimal("50000")
        assert loaded.rewards_balance.unit == "Alaska Miles"

    def test_add_account_with_institution(self, repository, db_session, user_id, usd_balance):
        """Can persist account with institution details."""
        institution = InstitutionDetails(
            name="Chase Bank",
            website="https://chase.com",
            phone="800-935-9935",
        )
        account = Account.create_checking(
            user_id=user_id,
            name="Chase Checking",
            opening_balance=usd_balance,
            institution=institution,
        )
        account.clear_events()

        repository.add(account)
        db_session.commit()
        db_session.expire_all()

        loaded = repository.get(account.id)

        assert loaded is not None
        assert loaded.institution is not None
        assert loaded.institution.name == "Chase Bank"
        assert loaded.institution.website == "https://chase.com"

    def test_get_nonexistent_returns_none(self, repository):
        """Getting nonexistent account returns None."""
        fake_id = AccountId.generate()
        result = repository.get(fake_id)
        assert result is None

    def test_get_or_raise_not_found(self, repository):
        """get_or_raise raises EntityNotFoundError."""
        from src.domain.exceptions import EntityNotFoundError

        fake_id = AccountId.generate()
        with pytest.raises(EntityNotFoundError):
            repository.get_or_raise(fake_id)

    def test_get_by_user(self, repository, db_session, user_id, usd_balance):
        """Can get all accounts for a user."""
        # Create multiple accounts
        checking = Account.create_checking(user_id, "Checking", usd_balance)
        savings = Account.create_savings(user_id, "Savings", usd_balance)
        checking.clear_events()
        savings.clear_events()

        repository.add(checking)
        repository.add(savings)
        db_session.commit()

        accounts = repository.get_by_user(user_id)

        assert len(accounts) == 2
        account_types = {a.account_type for a in accounts}
        assert AccountType.CHECKING in account_types
        assert AccountType.SAVINGS in account_types

    def test_get_by_user_with_type_filter(self, repository, db_session, user_id, usd_balance):
        """Can filter accounts by type."""
        checking = Account.create_checking(user_id, "Checking", usd_balance)
        savings = Account.create_savings(user_id, "Savings", usd_balance)
        checking.clear_events()
        savings.clear_events()

        repository.add(checking)
        repository.add(savings)
        db_session.commit()

        accounts = repository.get_by_user(user_id, account_type=AccountType.CHECKING)

        assert len(accounts) == 1
        assert accounts[0].account_type == AccountType.CHECKING

    def test_get_by_user_with_status_filter(self, repository, db_session, user_id, usd_balance):
        """Can filter accounts by status."""
        active = Account.create_checking(user_id, "Active", usd_balance)
        closed = Account.create_savings(user_id, "Closed", usd_balance)
        closed.close()
        active.clear_events()
        closed.clear_events()

        repository.add(active)
        repository.add(closed)
        db_session.commit()

        active_accounts = repository.get_by_user(user_id, status=AccountStatus.ACTIVE)
        closed_accounts = repository.get_by_user(user_id, status=AccountStatus.CLOSED)

        assert len(active_accounts) == 1
        assert len(closed_accounts) == 1

    def test_delete_account(self, repository, db_session, user_id, usd_balance):
        """Can delete an account."""
        account = Account.create_checking(user_id, "Delete Me", usd_balance)
        account.clear_events()

        repository.add(account)
        db_session.commit()

        # Verify it exists
        assert repository.get(account.id) is not None

        repository.delete(account)
        db_session.commit()

        # Verify it's gone
        assert repository.get(account.id) is None

    def test_has_transactions_returns_false(self, repository, user_id, usd_balance):
        """has_transactions returns False (placeholder until Phase 3)."""
        account_id = AccountId.generate()
        assert repository.has_transactions(account_id) is False


class TestAccountUpdate:
    """Test account update operations via repository."""

    def test_update_persists(self, repository, db_session, user_id, usd_balance):
        """Changes to loaded account persist on commit."""
        account = Account.create_checking(user_id, "Original", usd_balance)
        account.clear_events()

        repository.add(account)
        db_session.commit()

        # Load and modify
        loaded = repository.get(account.id)
        loaded.update_name("Updated", updated_by=user_id)
        loaded.clear_events()
        db_session.commit()

        # Reload and verify
        db_session.expire_all()
        reloaded = repository.get(account.id)
        assert reloaded.name == "Updated"

    def test_close_persists(self, repository, db_session, user_id, usd_balance):
        """Closing an account persists status change."""
        account = Account.create_checking(user_id, "Test", usd_balance)
        account.clear_events()

        repository.add(account)
        db_session.commit()

        loaded = repository.get(account.id)
        loaded.close()
        loaded.clear_events()
        db_session.commit()

        db_session.expire_all()
        reloaded = repository.get(account.id)
        assert reloaded.status == AccountStatus.CLOSED
        assert reloaded.closing_date is not None
```
  </action>
  <verify>
Run: `pytest tests/integration/test_account_repository.py -v`
All integration tests pass.
  </verify>
  <done>
Account repository integration tests created covering all CRUD operations and value object reconstruction.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Account API Integration Tests</name>
  <files>tests/integration/test_account_api.py</files>
  <action>
Create tests/integration/test_account_api.py with API integration tests:

```python
"""Integration tests for Account API endpoints."""
from decimal import Decimal
import pytest
from fastapi.testclient import TestClient

from src.adapters.api.app import app
from src.adapters.persistence.orm.mappers import start_mappers


@pytest.fixture(scope="module", autouse=True)
def setup_mappers():
    """Ensure mappers are registered before tests."""
    start_mappers()


@pytest.fixture
def client():
    """Create test client."""
    return TestClient(app)


@pytest.fixture
def test_user(db_session):
    """Create test user for API calls."""
    from src.adapters.persistence.orm.tables import users
    from src.domain.model.entity_id import UserId

    # Use the placeholder user ID that the API uses
    uid = "user_01h455vb4pex5vsknk084sn02q"
    db_session.execute(
        users.insert().values(
            id=uid,
            email="test@example.com",
            email_verified=True,
        )
    )
    db_session.commit()
    return uid


class TestCreateEndpoints:
    """Test account creation endpoints."""

    def test_create_checking_account(self, client, test_user):
        """POST /accounts/checking creates account."""
        response = client.post(
            "/accounts/checking",
            json={
                "name": "My Checking",
                "opening_balance": {"amount": "1000.00", "currency": "USD"},
            },
        )

        assert response.status_code == 201
        data = response.json()
        assert data["name"] == "My Checking"
        assert data["account_type"] == "checking"
        assert data["status"] == "active"
        assert "id" in data
        assert data["id"].startswith("acct_")

    def test_create_credit_card_account(self, client, test_user):
        """POST /accounts/credit-card creates credit card."""
        response = client.post(
            "/accounts/credit-card",
            json={
                "name": "Visa Card",
                "opening_balance": {"amount": "500.00", "currency": "USD"},
                "credit_limit": {"amount": "5000.00", "currency": "USD"},
            },
        )

        assert response.status_code == 201
        data = response.json()
        assert data["account_type"] == "credit_card"
        assert data["credit_limit"]["amount"] == "5000.0000"

    def test_create_loan_account(self, client, test_user):
        """POST /accounts/loan creates loan with details."""
        response = client.post(
            "/accounts/loan",
            json={
                "name": "Mortgage",
                "opening_balance": {"amount": "300000.00", "currency": "USD"},
                "subtype": "mortgage",
                "apr": "0.0599",
                "term_months": 360,
            },
        )

        assert response.status_code == 201
        data = response.json()
        assert data["account_type"] == "loan"
        assert data["subtype"] == "mortgage"
        assert data["apr"] == "0.0599"
        assert data["term_months"] == 360

    def test_create_rewards_account(self, client, test_user):
        """POST /accounts/rewards creates rewards account."""
        response = client.post(
            "/accounts/rewards",
            json={
                "name": "Alaska Miles",
                "rewards_balance": {"value": "50000", "unit": "Alaska Miles"},
            },
        )

        assert response.status_code == 201
        data = response.json()
        assert data["account_type"] == "rewards"
        assert data["rewards_balance"]["value"] == "50000"
        assert data["rewards_balance"]["unit"] == "Alaska Miles"

    def test_create_account_validation_error(self, client, test_user):
        """Invalid request returns 422."""
        response = client.post(
            "/accounts/checking",
            json={
                "name": "",  # Empty name invalid
                "opening_balance": {"amount": "1000", "currency": "USD"},
            },
        )

        assert response.status_code == 422


class TestReadEndpoints:
    """Test account read endpoints."""

    def test_list_accounts(self, client, test_user):
        """GET /accounts returns account list."""
        # Create an account first
        client.post(
            "/accounts/checking",
            json={
                "name": "List Test",
                "opening_balance": {"amount": "100", "currency": "USD"},
            },
        )

        response = client.get("/accounts")

        assert response.status_code == 200
        data = response.json()
        assert "accounts" in data
        assert "count" in data
        assert data["count"] >= 1

    def test_list_accounts_with_filter(self, client, test_user):
        """GET /accounts?type=checking filters by type."""
        response = client.get("/accounts", params={"type": "checking"})

        assert response.status_code == 200
        data = response.json()
        for account in data["accounts"]:
            assert account["account_type"] == "checking"

    def test_get_single_account(self, client, test_user):
        """GET /accounts/{id} returns single account."""
        # Create account
        create_response = client.post(
            "/accounts/savings",
            json={
                "name": "Get Test",
                "opening_balance": {"amount": "500", "currency": "USD"},
            },
        )
        account_id = create_response.json()["id"]

        response = client.get(f"/accounts/{account_id}")

        assert response.status_code == 200
        assert response.json()["id"] == account_id

    def test_get_nonexistent_account(self, client, test_user):
        """GET /accounts/{id} returns 404 for nonexistent."""
        response = client.get("/accounts/acct_01h455vb4pex5vsknk084sn02q")

        assert response.status_code == 404

    def test_get_invalid_id_format(self, client, test_user):
        """GET /accounts/{id} returns 400 for invalid ID."""
        response = client.get("/accounts/invalid-id")

        assert response.status_code == 400


class TestLifecycleEndpoints:
    """Test account lifecycle endpoints."""

    def test_close_account(self, client, test_user):
        """POST /accounts/{id}/close closes account."""
        # Create account
        create_response = client.post(
            "/accounts/checking",
            json={
                "name": "Close Test",
                "opening_balance": {"amount": "100", "currency": "USD"},
            },
        )
        account_id = create_response.json()["id"]

        response = client.post(f"/accounts/{account_id}/close")

        assert response.status_code == 200
        assert response.json()["status"] == "closed"
        assert response.json()["closing_date"] is not None

    def test_close_already_closed(self, client, test_user):
        """POST /accounts/{id}/close on closed returns 409."""
        # Create and close
        create_response = client.post(
            "/accounts/checking",
            json={
                "name": "Already Closed",
                "opening_balance": {"amount": "100", "currency": "USD"},
            },
        )
        account_id = create_response.json()["id"]
        client.post(f"/accounts/{account_id}/close")

        # Try to close again
        response = client.post(f"/accounts/{account_id}/close")

        assert response.status_code == 409

    def test_reopen_account(self, client, test_user):
        """POST /accounts/{id}/reopen reopens closed account."""
        # Create and close
        create_response = client.post(
            "/accounts/checking",
            json={
                "name": "Reopen Test",
                "opening_balance": {"amount": "100", "currency": "USD"},
            },
        )
        account_id = create_response.json()["id"]
        client.post(f"/accounts/{account_id}/close")

        response = client.post(f"/accounts/{account_id}/reopen")

        assert response.status_code == 200
        assert response.json()["status"] == "active"
        assert response.json()["closing_date"] is None

    def test_delete_account(self, client, test_user):
        """DELETE /accounts/{id} deletes account."""
        # Create account
        create_response = client.post(
            "/accounts/checking",
            json={
                "name": "Delete Test",
                "opening_balance": {"amount": "100", "currency": "USD"},
            },
        )
        account_id = create_response.json()["id"]

        response = client.delete(f"/accounts/{account_id}")

        assert response.status_code == 204

        # Verify it's gone
        get_response = client.get(f"/accounts/{account_id}")
        assert get_response.status_code == 404


class TestUpdateEndpoints:
    """Test account update endpoints."""

    def test_update_name(self, client, test_user):
        """PATCH /accounts/{id} updates account name."""
        # Create account
        create_response = client.post(
            "/accounts/checking",
            json={
                "name": "Original Name",
                "opening_balance": {"amount": "100", "currency": "USD"},
            },
        )
        account_id = create_response.json()["id"]

        response = client.patch(
            f"/accounts/{account_id}",
            json={"name": "New Name"},
        )

        assert response.status_code == 200
        assert response.json()["name"] == "New Name"
```
  </action>
  <verify>
Run: `pytest tests/integration/test_account_api.py -v`
All API integration tests pass.
  </verify>
  <done>
Account API integration tests created covering all endpoints with proper assertions.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete Phase 2 Account Domain implementation:
- Account aggregate with 7 account types
- Domain events for lifecycle changes
- SQLAlchemy persistence with migrations
- AccountService for use case orchestration
- REST API endpoints with OpenAPI documentation
- Integration tests for repository and API
  </what-built>
  <how-to-verify>
1. **Run full test suite:**
   ```bash
   pytest -v
   ```
   All tests should pass (Phase 1 + Phase 2 tests).

2. **Apply migrations:**
   ```bash
   alembic upgrade head
   ```
   Migration 002 should apply cleanly.

3. **Start API and test manually:**
   ```bash
   # In another terminal or background
   uvicorn src.adapters.api.app:app --reload

   # Create a checking account
   curl -X POST http://localhost:8000/accounts/checking \
     -H "Content-Type: application/json" \
     -d '{"name": "My Checking", "opening_balance": {"amount": "1000", "currency": "USD"}}'

   # List accounts
   curl http://localhost:8000/accounts

   # Check OpenAPI docs
   open http://localhost:8000/docs
   ```

4. **Verify architecture:**
   ```bash
   lint-imports
   ```
   Should pass with no violations.

5. **Verify Phase 2 success criteria from ROADMAP.md:**
   - [ ] Can create checking, savings, credit card, loan, brokerage, IRA, and rewards accounts
   - [ ] Can edit account name
   - [ ] Can delete account (no transactions guard works)
   - [ ] Can view accounts
   - [ ] Historical balance tracking ready (balance = opening_balance + transactions, Phase 3)
  </how-to-verify>
  <resume-signal>
Type "approved" to mark Phase 2 complete, or describe any issues found.
  </resume-signal>
</task>

</tasks>

<verification>
Phase 2 complete when:
```bash
# All tests pass
pytest -v

# Migrations apply
alembic upgrade head

# Architecture maintained
lint-imports

# API responds
curl http://localhost:8000/accounts
```
</verification>

<success_criteria>
- [ ] Repository integration tests pass (~15 tests)
- [ ] API integration tests pass (~15 tests)
- [ ] Full test suite passes (Phase 1 + Phase 2)
- [ ] Migration 002 applies cleanly
- [ ] API endpoints respond correctly
- [ ] OpenAPI docs show all account endpoints
- [ ] lint-imports passes
- [ ] Human verified API works end-to-end
</success_criteria>

<output>
After completion, create `.planning/phases/02-account-domain/02-06-SUMMARY.md`
</output>
