---
phase: 02-account-domain
plan: 04
type: execute
wave: 3
depends_on: ["02-03"]
files_modified:
  - src/application/__init__.py
  - src/application/services/__init__.py
  - src/application/services/account_service.py
  - tests/unit/application/__init__.py
  - tests/unit/application/test_account_service.py
autonomous: true

must_haves:
  truths:
    - "AccountService can create accounts of all types"
    - "AccountService can close and reopen accounts"
    - "AccountService can delete accounts without transactions"
    - "AccountService prevents deletion of accounts with transactions"
    - "AccountService collects and commits domain events"
  artifacts:
    - path: "src/application/services/account_service.py"
      provides: "Account use case orchestration"
      contains: "class AccountService"
      min_lines: 80
    - path: "tests/unit/application/test_account_service.py"
      provides: "AccountService unit tests with mock UoW"
      contains: "def test_"
  key_links:
    - from: "src/application/services/account_service.py"
      to: "src/domain/ports/unit_of_work.py"
      via: "UnitOfWork dependency injection"
      pattern: "def __init__.*uow.*UnitOfWork"
    - from: "src/application/services/account_service.py"
      to: "src/domain/model/account.py"
      via: "Account factory method calls"
      pattern: "Account\\.create_"
---

<objective>
Create AccountService application service for use case orchestration.

Purpose: The application service layer coordinates domain operations, transaction boundaries, and event collection. It's the entry point for all account-related use cases.
Output: AccountService with methods for create, update, close, reopen, delete operations and comprehensive unit tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-account-domain/02-CONTEXT.md
@.planning/phases/02-account-domain/02-RESEARCH.md

# Domain layer
# @src/domain/model/account.py
# @src/domain/ports/unit_of_work.py
# @src/domain/ports/account_repository.py

# Prior plan summaries (if running after 02-03)
# @.planning/phases/02-account-domain/02-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Application Layer Package Structure</name>
  <files>src/application/__init__.py, src/application/services/__init__.py</files>
  <action>
Create the application layer package structure:

**src/application/__init__.py:**
```python
"""Application layer - use case orchestration.

The application layer coordinates domain operations and handles:
- Transaction boundaries via Unit of Work
- Domain event collection
- Cross-aggregate coordination
- DTO mapping between API and domain

Application services are the entry points for use cases.
They depend on domain ports (protocols) and are injected with
concrete implementations at runtime.
"""
```

**src/application/services/__init__.py:**
```python
"""Application services package."""
from .account_service import AccountService

__all__ = ["AccountService"]
```
  </action>
  <verify>
Run: `python -c "import src.application; import src.application.services; print('Application packages created')"`
Packages import without errors.
  </verify>
  <done>
Application layer package structure created with proper __init__.py files.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create AccountService</name>
  <files>src/application/services/account_service.py</files>
  <action>
Create src/application/services/account_service.py following the pattern from 02-RESEARCH.md:

```python
"""Account application service for use case orchestration."""
from dataclasses import dataclass
from datetime import datetime
from decimal import Decimal
from typing import TYPE_CHECKING

from src.domain.model.account import Account
from src.domain.model.entity_id import AccountId, UserId
from src.domain.model.money import Money
from src.domain.model.account_types import AccountType, AccountStatus, AccountSubtype
from src.domain.model.rewards_balance import RewardsBalance
from src.domain.model.institution import InstitutionDetails
from src.domain.events.account_events import AccountDeleted

if TYPE_CHECKING:
    from src.domain.ports.unit_of_work import UnitOfWork


@dataclass(frozen=True)
class AccountError:
    """Application-level error for account operations."""
    code: str
    message: str


class AccountService:
    """Application service for account use cases.

    Coordinates domain operations within transaction boundaries.
    Collects and persists domain events via outbox pattern.
    """

    def __init__(self, uow: "UnitOfWork"):
        self._uow = uow

    # CREATE methods - one per account type

    def create_checking_account(
        self,
        user_id: UserId,
        name: str,
        opening_balance: Money,
        institution_name: str | None = None,
        opening_date: datetime | None = None,
        notes: str | None = None,
    ) -> Account | AccountError:
        """Create a new checking account."""
        with self._uow:
            institution = InstitutionDetails(name=institution_name) if institution_name else None
            account = Account.create_checking(
                user_id=user_id,
                name=name,
                opening_balance=opening_balance,
                institution=institution,
                opening_date=opening_date,
                notes=notes,
            )
            self._uow.accounts.add(account)
            self._uow.collect_events(account.events)
            self._uow.commit()
            return account

    def create_savings_account(
        self,
        user_id: UserId,
        name: str,
        opening_balance: Money,
        institution_name: str | None = None,
        opening_date: datetime | None = None,
        notes: str | None = None,
    ) -> Account | AccountError:
        """Create a new savings account."""
        with self._uow:
            institution = InstitutionDetails(name=institution_name) if institution_name else None
            account = Account.create_savings(
                user_id=user_id,
                name=name,
                opening_balance=opening_balance,
                institution=institution,
                opening_date=opening_date,
                notes=notes,
            )
            self._uow.accounts.add(account)
            self._uow.collect_events(account.events)
            self._uow.commit()
            return account

    def create_credit_card_account(
        self,
        user_id: UserId,
        name: str,
        opening_balance: Money,
        credit_limit: Money,
        institution_name: str | None = None,
        opening_date: datetime | None = None,
        notes: str | None = None,
    ) -> Account | AccountError:
        """Create a new credit card account."""
        try:
            with self._uow:
                institution = InstitutionDetails(name=institution_name) if institution_name else None
                account = Account.create_credit_card(
                    user_id=user_id,
                    name=name,
                    opening_balance=opening_balance,
                    credit_limit=credit_limit,
                    institution=institution,
                    opening_date=opening_date,
                    notes=notes,
                )
                self._uow.accounts.add(account)
                self._uow.collect_events(account.events)
                self._uow.commit()
                return account
        except ValueError as e:
            return AccountError(code="VALIDATION_ERROR", message=str(e))

    def create_loan_account(
        self,
        user_id: UserId,
        name: str,
        opening_balance: Money,
        subtype: AccountSubtype | None = None,
        apr: Decimal | None = None,
        term_months: int | None = None,
        due_date: datetime | None = None,
        institution_name: str | None = None,
        opening_date: datetime | None = None,
        notes: str | None = None,
    ) -> Account | AccountError:
        """Create a new loan account."""
        with self._uow:
            institution = InstitutionDetails(name=institution_name) if institution_name else None
            account = Account.create_loan(
                user_id=user_id,
                name=name,
                opening_balance=opening_balance,
                subtype=subtype,
                apr=apr,
                term_months=term_months,
                due_date=due_date,
                institution=institution,
                opening_date=opening_date,
                notes=notes,
            )
            self._uow.accounts.add(account)
            self._uow.collect_events(account.events)
            self._uow.commit()
            return account

    def create_brokerage_account(
        self,
        user_id: UserId,
        name: str,
        opening_balance: Money,
        institution_name: str | None = None,
        opening_date: datetime | None = None,
        notes: str | None = None,
    ) -> Account | AccountError:
        """Create a new brokerage account."""
        with self._uow:
            institution = InstitutionDetails(name=institution_name) if institution_name else None
            account = Account.create_brokerage(
                user_id=user_id,
                name=name,
                opening_balance=opening_balance,
                institution=institution,
                opening_date=opening_date,
                notes=notes,
            )
            self._uow.accounts.add(account)
            self._uow.collect_events(account.events)
            self._uow.commit()
            return account

    def create_ira_account(
        self,
        user_id: UserId,
        name: str,
        opening_balance: Money,
        subtype: AccountSubtype | None = None,
        institution_name: str | None = None,
        opening_date: datetime | None = None,
        notes: str | None = None,
    ) -> Account | AccountError:
        """Create a new IRA account."""
        with self._uow:
            institution = InstitutionDetails(name=institution_name) if institution_name else None
            account = Account.create_ira(
                user_id=user_id,
                name=name,
                opening_balance=opening_balance,
                subtype=subtype,
                institution=institution,
                opening_date=opening_date,
                notes=notes,
            )
            self._uow.accounts.add(account)
            self._uow.collect_events(account.events)
            self._uow.commit()
            return account

    def create_rewards_account(
        self,
        user_id: UserId,
        name: str,
        rewards_balance: RewardsBalance,
        institution_name: str | None = None,
        opening_date: datetime | None = None,
        notes: str | None = None,
    ) -> Account | AccountError:
        """Create a new rewards/miles account."""
        with self._uow:
            institution = InstitutionDetails(name=institution_name) if institution_name else None
            account = Account.create_rewards(
                user_id=user_id,
                name=name,
                rewards_balance=rewards_balance,
                institution=institution,
                opening_date=opening_date,
                notes=notes,
            )
            self._uow.accounts.add(account)
            self._uow.collect_events(account.events)
            self._uow.commit()
            return account

    # READ methods

    def get_account(self, account_id: AccountId) -> Account | AccountError:
        """Get account by ID."""
        with self._uow:
            account = self._uow.accounts.get(account_id)
            if account is None:
                return AccountError(
                    code="ACCOUNT_NOT_FOUND",
                    message=f"Account {account_id} not found",
                )
            return account

    def get_user_accounts(
        self,
        user_id: UserId,
        status: AccountStatus | None = None,
        account_type: AccountType | None = None,
    ) -> list[Account]:
        """Get all accounts for a user with optional filters."""
        with self._uow:
            return self._uow.accounts.get_by_user(
                user_id=user_id,
                status=status,
                account_type=account_type,
            )

    # UPDATE methods

    def update_account_name(
        self,
        account_id: AccountId,
        new_name: str,
        updated_by: UserId | None = None,
    ) -> Account | AccountError:
        """Update account name."""
        with self._uow:
            account = self._uow.accounts.get(account_id)
            if account is None:
                return AccountError(
                    code="ACCOUNT_NOT_FOUND",
                    message=f"Account {account_id} not found",
                )
            try:
                account.update_name(new_name, updated_by=updated_by)
            except ValueError as e:
                return AccountError(code="VALIDATION_ERROR", message=str(e))

            self._uow.collect_events(account.events)
            self._uow.commit()
            return account

    # LIFECYCLE methods

    def close_account(
        self,
        account_id: AccountId,
        closed_by: UserId | None = None,
    ) -> Account | AccountError:
        """Close an account."""
        with self._uow:
            account = self._uow.accounts.get(account_id)
            if account is None:
                return AccountError(
                    code="ACCOUNT_NOT_FOUND",
                    message=f"Account {account_id} not found",
                )
            try:
                account.close(closed_by=closed_by)
            except ValueError as e:
                return AccountError(code="INVALID_STATE", message=str(e))

            self._uow.collect_events(account.events)
            self._uow.commit()
            return account

    def reopen_account(
        self,
        account_id: AccountId,
        reopened_by: UserId | None = None,
    ) -> Account | AccountError:
        """Reopen a closed account."""
        with self._uow:
            account = self._uow.accounts.get(account_id)
            if account is None:
                return AccountError(
                    code="ACCOUNT_NOT_FOUND",
                    message=f"Account {account_id} not found",
                )
            try:
                account.reopen(reopened_by=reopened_by)
            except ValueError as e:
                return AccountError(code="INVALID_STATE", message=str(e))

            self._uow.collect_events(account.events)
            self._uow.commit()
            return account

    def delete_account(
        self,
        account_id: AccountId,
    ) -> None | AccountError:
        """Delete an account (only if no transactions exist)."""
        with self._uow:
            account = self._uow.accounts.get(account_id)
            if account is None:
                return AccountError(
                    code="ACCOUNT_NOT_FOUND",
                    message=f"Account {account_id} not found",
                )

            if self._uow.accounts.has_transactions(account_id):
                return AccountError(
                    code="HAS_TRANSACTIONS",
                    message="Cannot delete account with transactions. Close it instead.",
                )

            # Emit event before delete
            deleted_event = AccountDeleted(
                aggregate_id=str(account_id),
                aggregate_type="Account",
            )

            self._uow.accounts.delete(account)
            self._uow.collect_events([deleted_event])
            self._uow.commit()
            return None
```
  </action>
  <verify>
Run: `python -c "from src.application.services.account_service import AccountService; print('AccountService imported')"`
AccountService imports without errors.
  </verify>
  <done>
AccountService created with all CRUD operations, lifecycle management, and proper event collection.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create AccountService Unit Tests</name>
  <files>tests/unit/application/__init__.py, tests/unit/application/test_account_service.py</files>
  <action>
**Create tests/unit/application/__init__.py:**
```python
"""Unit tests for application layer."""
```

**Create tests/unit/application/test_account_service.py:**

Create unit tests using mock UnitOfWork and repository:

```python
"""Unit tests for AccountService."""
from decimal import Decimal
from unittest.mock import MagicMock, patch
import pytest

from src.application.services.account_service import AccountService, AccountError
from src.domain.model.account import Account
from src.domain.model.entity_id import AccountId, UserId
from src.domain.model.money import Money
from src.domain.model.account_types import AccountType, AccountStatus, AccountSubtype
from src.domain.model.rewards_balance import RewardsBalance


@pytest.fixture
def mock_uow():
    """Create mock UnitOfWork with mock accounts repository."""
    uow = MagicMock()
    uow.accounts = MagicMock()
    uow.__enter__ = MagicMock(return_value=uow)
    uow.__exit__ = MagicMock(return_value=False)
    return uow


@pytest.fixture
def user_id():
    """Generate test user ID."""
    return UserId.generate()


@pytest.fixture
def usd_balance():
    """USD Money for testing."""
    return Money(Decimal("1000.00"), "USD")


class TestCreateAccounts:
    """Tests for account creation methods."""

    def test_create_checking_account(self, mock_uow, user_id, usd_balance):
        service = AccountService(mock_uow)

        result = service.create_checking_account(
            user_id=user_id,
            name="My Checking",
            opening_balance=usd_balance,
        )

        assert isinstance(result, Account)
        assert result.name == "My Checking"
        assert result.account_type == AccountType.CHECKING
        mock_uow.accounts.add.assert_called_once()
        mock_uow.collect_events.assert_called_once()
        mock_uow.commit.assert_called_once()

    def test_create_savings_account(self, mock_uow, user_id, usd_balance):
        service = AccountService(mock_uow)

        result = service.create_savings_account(
            user_id=user_id,
            name="Savings",
            opening_balance=usd_balance,
        )

        assert isinstance(result, Account)
        assert result.account_type == AccountType.SAVINGS

    def test_create_credit_card_account(self, mock_uow, user_id, usd_balance):
        service = AccountService(mock_uow)
        credit_limit = Money(Decimal("5000.00"), "USD")

        result = service.create_credit_card_account(
            user_id=user_id,
            name="Visa Card",
            opening_balance=usd_balance,
            credit_limit=credit_limit,
        )

        assert isinstance(result, Account)
        assert result.account_type == AccountType.CREDIT_CARD
        assert result.credit_limit == credit_limit

    def test_create_credit_card_currency_mismatch_returns_error(self, mock_uow, user_id, usd_balance):
        service = AccountService(mock_uow)
        eur_limit = Money(Decimal("5000.00"), "EUR")

        result = service.create_credit_card_account(
            user_id=user_id,
            name="Visa Card",
            opening_balance=usd_balance,
            credit_limit=eur_limit,
        )

        assert isinstance(result, AccountError)
        assert result.code == "VALIDATION_ERROR"

    def test_create_loan_account(self, mock_uow, user_id, usd_balance):
        service = AccountService(mock_uow)

        result = service.create_loan_account(
            user_id=user_id,
            name="Mortgage",
            opening_balance=usd_balance,
            subtype=AccountSubtype.MORTGAGE,
            apr=Decimal("0.0599"),
            term_months=360,
        )

        assert isinstance(result, Account)
        assert result.account_type == AccountType.LOAN
        assert result.subtype == AccountSubtype.MORTGAGE

    def test_create_brokerage_account(self, mock_uow, user_id, usd_balance):
        service = AccountService(mock_uow)

        result = service.create_brokerage_account(
            user_id=user_id,
            name="Fidelity",
            opening_balance=usd_balance,
        )

        assert isinstance(result, Account)
        assert result.account_type == AccountType.BROKERAGE

    def test_create_ira_account(self, mock_uow, user_id, usd_balance):
        service = AccountService(mock_uow)

        result = service.create_ira_account(
            user_id=user_id,
            name="Roth IRA",
            opening_balance=usd_balance,
            subtype=AccountSubtype.ROTH_IRA,
        )

        assert isinstance(result, Account)
        assert result.account_type == AccountType.IRA

    def test_create_rewards_account(self, mock_uow, user_id):
        service = AccountService(mock_uow)
        rewards = RewardsBalance(Decimal("50000"), "Alaska Miles")

        result = service.create_rewards_account(
            user_id=user_id,
            name="Alaska Airlines",
            rewards_balance=rewards,
        )

        assert isinstance(result, Account)
        assert result.account_type == AccountType.REWARDS


class TestGetAccounts:
    """Tests for account retrieval methods."""

    def test_get_account_found(self, mock_uow, user_id, usd_balance):
        service = AccountService(mock_uow)
        account = Account.create_checking(user_id, "Test", usd_balance)
        mock_uow.accounts.get.return_value = account

        result = service.get_account(account.id)

        assert result == account

    def test_get_account_not_found(self, mock_uow):
        service = AccountService(mock_uow)
        mock_uow.accounts.get.return_value = None
        account_id = AccountId.generate()

        result = service.get_account(account_id)

        assert isinstance(result, AccountError)
        assert result.code == "ACCOUNT_NOT_FOUND"

    def test_get_user_accounts(self, mock_uow, user_id, usd_balance):
        service = AccountService(mock_uow)
        accounts = [
            Account.create_checking(user_id, "Checking", usd_balance),
            Account.create_savings(user_id, "Savings", usd_balance),
        ]
        mock_uow.accounts.get_by_user.return_value = accounts

        result = service.get_user_accounts(user_id)

        assert len(result) == 2
        mock_uow.accounts.get_by_user.assert_called_once_with(
            user_id=user_id, status=None, account_type=None
        )


class TestAccountLifecycle:
    """Tests for account lifecycle operations."""

    def test_close_account(self, mock_uow, user_id, usd_balance):
        service = AccountService(mock_uow)
        account = Account.create_checking(user_id, "Test", usd_balance)
        account.clear_events()  # Clear creation event
        mock_uow.accounts.get.return_value = account

        result = service.close_account(account.id)

        assert isinstance(result, Account)
        assert result.status == AccountStatus.CLOSED
        mock_uow.collect_events.assert_called()
        mock_uow.commit.assert_called_once()

    def test_close_account_not_found(self, mock_uow):
        service = AccountService(mock_uow)
        mock_uow.accounts.get.return_value = None

        result = service.close_account(AccountId.generate())

        assert isinstance(result, AccountError)
        assert result.code == "ACCOUNT_NOT_FOUND"

    def test_reopen_account(self, mock_uow, user_id, usd_balance):
        service = AccountService(mock_uow)
        account = Account.create_checking(user_id, "Test", usd_balance)
        account.close()
        account.clear_events()
        mock_uow.accounts.get.return_value = account

        result = service.reopen_account(account.id)

        assert isinstance(result, Account)
        assert result.status == AccountStatus.ACTIVE

    def test_delete_account_success(self, mock_uow, user_id, usd_balance):
        service = AccountService(mock_uow)
        account = Account.create_checking(user_id, "Test", usd_balance)
        mock_uow.accounts.get.return_value = account
        mock_uow.accounts.has_transactions.return_value = False

        result = service.delete_account(account.id)

        assert result is None  # Success
        mock_uow.accounts.delete.assert_called_once()
        mock_uow.commit.assert_called_once()

    def test_delete_account_with_transactions(self, mock_uow, user_id, usd_balance):
        service = AccountService(mock_uow)
        account = Account.create_checking(user_id, "Test", usd_balance)
        mock_uow.accounts.get.return_value = account
        mock_uow.accounts.has_transactions.return_value = True

        result = service.delete_account(account.id)

        assert isinstance(result, AccountError)
        assert result.code == "HAS_TRANSACTIONS"
        mock_uow.accounts.delete.assert_not_called()


class TestUpdateAccount:
    """Tests for account update operations."""

    def test_update_account_name(self, mock_uow, user_id, usd_balance):
        service = AccountService(mock_uow)
        account = Account.create_checking(user_id, "Old Name", usd_balance)
        account.clear_events()
        mock_uow.accounts.get.return_value = account

        result = service.update_account_name(account.id, "New Name")

        assert isinstance(result, Account)
        assert result.name == "New Name"
        mock_uow.collect_events.assert_called()

    def test_update_account_name_empty_returns_error(self, mock_uow, user_id, usd_balance):
        service = AccountService(mock_uow)
        account = Account.create_checking(user_id, "Name", usd_balance)
        mock_uow.accounts.get.return_value = account

        result = service.update_account_name(account.id, "  ")

        assert isinstance(result, AccountError)
        assert result.code == "VALIDATION_ERROR"
```
  </action>
  <verify>
Run: `pytest tests/unit/application/test_account_service.py -v`
All tests pass.
  </verify>
  <done>
AccountService unit tests created with mock UoW. ~20 tests covering all operations.
  </done>
</task>

</tasks>

<verification>
Run full test suite:
```bash
pytest tests/unit/ -v
lint-imports
```

All tests pass. No architecture violations.
</verification>

<success_criteria>
- [ ] Application layer package structure created
- [ ] AccountService has create methods for all 7 account types
- [ ] AccountService has get_account and get_user_accounts
- [ ] AccountService has close_account and reopen_account
- [ ] AccountService has delete_account with transaction guard
- [ ] AccountService has update_account_name
- [ ] All operations use UoW transaction boundaries
- [ ] Events collected before commit
- [ ] Unit tests cover happy paths and error cases (~20 tests)
- [ ] lint-imports passes
</success_criteria>

<output>
After completion, create `.planning/phases/02-account-domain/02-04-SUMMARY.md`
</output>
