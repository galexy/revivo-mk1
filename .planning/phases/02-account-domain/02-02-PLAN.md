---
phase: 02-account-domain
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/domain/model/account.py
  - src/domain/ports/account_repository.py
  - src/domain/model/__init__.py
  - tests/unit/domain/test_account.py
autonomous: true

must_haves:
  truths:
    - "Account aggregate can be created for all 7 account types"
    - "Credit card accounts require credit_limit"
    - "Loan accounts accept APR and term_months"
    - "Rewards accounts use RewardsBalance instead of Money"
    - "Account emits domain events on state changes"
    - "Account can be closed and reopened"
  artifacts:
    - path: "src/domain/model/account.py"
      provides: "Account aggregate root entity"
      contains: "class Account"
      min_lines: 150
    - path: "src/domain/ports/account_repository.py"
      provides: "AccountRepository protocol"
      contains: "class AccountRepository"
    - path: "tests/unit/domain/test_account.py"
      provides: "Account aggregate unit tests"
      contains: "def test_"
  key_links:
    - from: "src/domain/model/account.py"
      to: "src/domain/model/account_types.py"
      via: "AccountType, AccountStatus imports"
      pattern: "from.*account_types import"
    - from: "src/domain/model/account.py"
      to: "src/domain/events/account_events.py"
      via: "Event emission in factory methods"
      pattern: "AccountCreated\\("
---

<objective>
Create the Account aggregate root entity with factory methods for all account types and lifecycle operations.

Purpose: The Account aggregate is the core domain entity for Phase 2. It encapsulates all account behavior including type-specific validation, state transitions, and event emission.
Output: Account entity with factory methods for 7 account types, lifecycle operations (close/reopen), property updates, and AccountRepository protocol.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-account-domain/02-CONTEXT.md
@.planning/phases/02-account-domain/02-RESEARCH.md

# Phase 1 foundations
@src/domain/model/money.py
@src/domain/model/entity_id.py
@src/domain/events/base.py
@src/domain/ports/unit_of_work.py

# From 02-01 (assumed complete if running in wave)
# @src/domain/model/account_types.py
# @src/domain/model/rewards_balance.py
# @src/domain/model/institution.py
# @src/domain/events/account_events.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Account Aggregate Root Entity</name>
  <files>src/domain/model/account.py</files>
  <action>
Create src/domain/model/account.py with the Account aggregate root following Pattern 1 from 02-RESEARCH.md:

**Class definition:**
```python
@dataclass(eq=False, slots=True)
class Account:
```
NOT frozen - uses explicit mutation methods that emit events.
eq=False because identity is based on ID, not field values.

**Required fields:**
- id: AccountId
- user_id: UserId
- name: str
- account_type: AccountType
- status: AccountStatus
- opening_balance: Money
- opening_date: datetime

**Optional type-specific fields (all default to None):**
- subtype: AccountSubtype | None
- credit_limit: Money | None (credit cards)
- apr: Decimal | None (loans, as decimal e.g., 0.1999 for 19.99%)
- term_months: int | None (loans)
- due_date: datetime | None (loans with fixed terms)
- rewards_balance: RewardsBalance | None (rewards accounts)
- institution: InstitutionDetails | None
- encrypted_account_number: str | None

**Lifecycle fields:**
- closing_date: datetime | None
- notes: str | None
- sort_order: int = 0

**Audit fields:**
- created_at: datetime (default factory: datetime.now(UTC))
- updated_at: datetime (default factory: datetime.now(UTC))
- created_by: UserId | None = None
- updated_by: UserId | None = None

**Event tracking (not persisted):**
- _events: list[DomainEvent] = field(default_factory=list, repr=False)

**Properties:**
- events -> list[DomainEvent]: Return copy of _events list
- is_active -> bool: Return status == ACTIVE
- available_credit -> Money | None: For credit cards, return credit_limit (placeholder until Phase 3 calculates actual)

**Methods:**
- clear_events(): Clear the _events list
- close(closed_by: UserId | None): Set status=CLOSED, closing_date=now, emit AccountClosed
- reopen(reopened_by: UserId | None): Set status=ACTIVE, clear closing_date, emit AccountReopened
- update_name(new_name: str, updated_by: UserId | None): Validate non-empty, update name, emit AccountUpdated
- update_notes(notes: str | None, updated_by: UserId | None): Update notes field, emit AccountUpdated
- update_institution(institution: InstitutionDetails | None, updated_by: UserId | None): Update institution, emit AccountUpdated

**Factory methods (classmethod, return Self):**
All factories: generate AccountId, set status=ACTIVE, emit AccountCreated event.

1. create_checking(user_id, name, opening_balance, institution=None, opening_date=None, account_number=None, notes=None)
2. create_savings(user_id, name, opening_balance, institution=None, opening_date=None, account_number=None, notes=None)
3. create_credit_card(user_id, name, opening_balance, credit_limit, institution=None, opening_date=None, notes=None)
   - Validate credit_limit currency matches opening_balance currency
4. create_loan(user_id, name, opening_balance, subtype=None, apr=None, term_months=None, due_date=None, institution=None, opening_date=None, notes=None)
5. create_brokerage(user_id, name, opening_balance, institution=None, opening_date=None, notes=None)
6. create_ira(user_id, name, opening_balance, subtype=None, institution=None, opening_date=None, notes=None)
   - Validate subtype is IRA-related if provided
7. create_rewards(user_id, name, rewards_balance, institution=None, opening_date=None, notes=None)
   - Uses RewardsBalance instead of Money for opening balance

Import from:
- datetime (UTC, datetime)
- decimal (Decimal)
- dataclasses (dataclass, field)
- typing (Self)
- src.domain.model.entity_id (AccountId, UserId)
- src.domain.model.money (Money)
- src.domain.model.account_types (AccountType, AccountStatus, AccountSubtype)
- src.domain.model.rewards_balance (RewardsBalance)
- src.domain.model.institution (InstitutionDetails)
- src.domain.events.account_events (AccountCreated, AccountUpdated, AccountClosed, AccountReopened)
  </action>
  <verify>
Run: `python -c "from src.domain.model.account import Account; print('Account imported successfully')"`
Account class imports without errors.
  </verify>
  <done>
Account aggregate root created with 7 factory methods, lifecycle operations, and event emission. All account types supported with type-specific fields.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create AccountRepository Protocol</name>
  <files>src/domain/ports/account_repository.py, src/domain/model/__init__.py</files>
  <action>
Create src/domain/ports/account_repository.py with the AccountRepository protocol:

```python
from typing import Protocol

from src.domain.model.account import Account
from src.domain.model.entity_id import AccountId, UserId
from src.domain.model.account_types import AccountType, AccountStatus


class AccountRepository(Protocol):
    """Repository protocol for Account aggregate."""

    def add(self, account: Account) -> None:
        """Add a new account."""
        ...

    def get(self, account_id: AccountId) -> Account | None:
        """Get account by ID, returns None if not found."""
        ...

    def get_or_raise(self, account_id: AccountId) -> Account:
        """Get account by ID, raises EntityNotFoundError if not found."""
        ...

    def get_by_user(
        self,
        user_id: UserId,
        status: AccountStatus | None = None,
        account_type: AccountType | None = None,
    ) -> list[Account]:
        """Get all accounts for a user with optional filters."""
        ...

    def delete(self, account: Account) -> None:
        """Delete an account (only if no transactions exist)."""
        ...

    def has_transactions(self, account_id: AccountId) -> bool:
        """Check if account has any transactions (for deletion guard)."""
        ...
```

Update src/domain/model/__init__.py to export new domain types:
- Account
- AccountType, AccountStatus, AccountSubtype
- RewardsBalance
- InstitutionDetails
  </action>
  <verify>
Run: `python -c "from src.domain.ports.account_repository import AccountRepository; print('AccountRepository imported')"`
Protocol imports correctly.
  </verify>
  <done>
AccountRepository protocol defined with standard CRUD operations plus user-scoped queries and transaction existence check.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Account Aggregate Unit Tests</name>
  <files>tests/unit/domain/test_account.py</files>
  <action>
Create comprehensive unit tests for Account aggregate in tests/unit/domain/test_account.py:

**Factory method tests:**
- test_create_checking_account: Creates with correct type, generates ID, emits AccountCreated
- test_create_savings_account: Creates with correct type
- test_create_credit_card_account: Requires credit_limit, validates currency match
- test_create_credit_card_currency_mismatch: Raises ValueError when currencies differ
- test_create_loan_account: Accepts APR, term_months, due_date, subtype
- test_create_brokerage_account: Creates with correct type
- test_create_ira_account: Accepts IRA subtypes
- test_create_rewards_account: Uses RewardsBalance, not Money

**Event emission tests:**
- test_account_created_event_emitted: Factory methods emit AccountCreated
- test_account_updated_event_emitted: update_name emits AccountUpdated with old/new values
- test_account_closed_event_emitted: close() emits AccountClosed
- test_account_reopened_event_emitted: reopen() emits AccountReopened
- test_clear_events: clear_events() empties the events list

**Lifecycle tests:**
- test_close_active_account: Sets status=CLOSED, sets closing_date
- test_close_already_closed_account: Raises ValueError
- test_reopen_closed_account: Sets status=ACTIVE, clears closing_date
- test_reopen_active_account: Raises ValueError

**Property update tests:**
- test_update_name: Updates name, sets updated_at
- test_update_name_empty: Raises ValueError for empty/whitespace name
- test_update_notes: Updates notes field
- test_update_institution: Updates institution

**Property tests:**
- test_is_active_property: Returns True for ACTIVE, False for CLOSED
- test_available_credit_for_credit_card: Returns credit_limit (placeholder)
- test_available_credit_for_non_credit_card: Returns None

Use pytest fixtures for common setup:
- user_id fixture: Generate test UserId
- usd_balance fixture: Money(Decimal("1000"), "USD")
- sample_institution fixture: InstitutionDetails(name="Test Bank")
  </action>
  <verify>
Run: `pytest tests/unit/domain/test_account.py -v`
All tests pass.
  </verify>
  <done>
Comprehensive Account unit tests covering all 7 account types, lifecycle operations, event emission, and property updates. ~25 tests total.
  </done>
</task>

</tasks>

<verification>
Run full domain test suite:
```bash
pytest tests/unit/domain/ -v
lint-imports
```

All tests pass. Architecture constraints maintained.
</verification>

<success_criteria>
- [ ] Account aggregate has factory methods for all 7 account types
- [ ] Credit card factory validates credit_limit currency matches balance
- [ ] Loan factory accepts APR, term, due_date
- [ ] Rewards factory uses RewardsBalance instead of Money
- [ ] close() and reopen() work correctly with validation
- [ ] All state changes emit appropriate domain events
- [ ] update_name, update_notes, update_institution work correctly
- [ ] AccountRepository protocol defined with all required methods
- [ ] All unit tests pass (~25 tests)
- [ ] lint-imports passes
</success_criteria>

<output>
After completion, create `.planning/phases/02-account-domain/02-02-SUMMARY.md`
</output>
