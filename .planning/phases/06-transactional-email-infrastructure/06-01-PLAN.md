---
phase: 06-transactional-email-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/domain/ports/email_service.py
  - src/adapters/email/__init__.py
  - src/adapters/email/smtp_adapter.py
  - src/adapters/email/templates/base.html
  - src/adapters/email/templates/base.txt
  - src/adapters/email/templates/verification.html
  - src/adapters/email/templates/verification.txt
autonomous: true

must_haves:
  truths:
    - "EmailService protocol defines send_email method signature"
    - "SMTP adapter can compose multipart HTML+text emails"
    - "Templates render verification email with link and expiry"
  artifacts:
    - path: "src/domain/ports/email_service.py"
      provides: "EmailService protocol definition"
      contains: "class EmailService"
    - path: "src/adapters/email/smtp_adapter.py"
      provides: "SMTP implementation of EmailService"
      contains: "class SmtpEmailAdapter"
    - path: "src/adapters/email/templates/verification.html"
      provides: "HTML verification email template"
      contains: "verification_link"
  key_links:
    - from: "src/adapters/email/smtp_adapter.py"
      to: "src/domain/ports/email_service.py"
      via: "implements EmailService protocol"
      pattern: "send_email"
---

<objective>
Create the email service domain port and SMTP adapter implementation with Jinja2 templates.

Purpose: Establish clean architecture email infrastructure that can be mocked for testing and swapped for different providers.
Output: EmailService protocol, SmtpEmailAdapter, and verification email templates.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/CHECKPOINTS.md
@.planning/phases/06-transactional-email-infrastructure/06-CONTEXT.md
@.planning/phases/06-transactional-email-infrastructure/06-RESEARCH.md

# Existing patterns to follow
@src/domain/ports/repository.py
@src/adapters/logging.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create EmailService protocol in domain/ports</name>
  <files>
    src/domain/ports/email_service.py
    src/domain/ports/__init__.py
  </files>
  <action>
Create EmailService protocol in domain/ports following existing Protocol patterns:

1. Create `src/domain/ports/email_service.py`:
   - Define `EmailService` Protocol with `send_email(to_email, subject, html_content, text_content) -> None`
   - Define `EmailDeliveryError` exception for send failures
   - Add docstrings explaining protocol purpose and implementations
   - Follow pattern from repository.py for Protocol definition style

2. Export from `src/domain/ports/__init__.py`:
   - Add EmailService and EmailDeliveryError to exports

Protocol signature per RESEARCH.md:
```python
class EmailService(Protocol):
    def send_email(
        self,
        to_email: str,
        subject: str,
        html_content: str,
        text_content: str,
    ) -> None:
        """Send an email. Raises EmailDeliveryError on failure."""
        ...
```
  </action>
  <verify>
Run `python -c "from src.domain.ports import EmailService, EmailDeliveryError; print('OK')"` succeeds.
Run `lint-imports` passes (email_service.py has no infrastructure imports).
  </verify>
  <done>
EmailService protocol exists in domain/ports with send_email method. No infrastructure imports.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create SMTP adapter with Jinja2 templates</name>
  <files>
    src/adapters/email/__init__.py
    src/adapters/email/smtp_adapter.py
    src/adapters/email/templates/base.html
    src/adapters/email/templates/base.txt
    src/adapters/email/templates/verification.html
    src/adapters/email/templates/verification.txt
  </files>
  <action>
Create the email adapter package with SMTP implementation and templates:

1. Create `src/adapters/email/__init__.py`:
   - Export SmtpEmailAdapter
   - Export get_email_service() factory function that reads from env vars
   - Export render_verification_email() template helper

2. Create `src/adapters/email/smtp_adapter.py`:
   - SmtpEmailAdapter class implementing EmailService protocol
   - Constructor takes: host, port, username, password, from_name, from_email, use_tls (all from env vars)
   - `is_available()` method with lazy check (per RESEARCH.md Pattern 4)
   - `send_email()` using email.message.EmailMessage with set_content() + add_alternative() pattern
   - Use smtplib.SMTP for sending (sync is fine for job queue context)
   - Log email_sent on success (mask email per PII rules: first 3 chars + ***)
   - Raise EmailDeliveryError from domain/ports on failure
   - Import get_logger from src.adapters.logging

3. Create Jinja2 template environment:
   - Use PackageLoader pointing to src.adapters.email.templates
   - Create render_verification_email(recipient_name, verification_link, expiry_hours) -> tuple[str, str]

4. Create template files per RESEARCH.md examples:
   - `templates/base.html`: Basic HTML structure with header/footer placeholders
   - `templates/base.txt`: Plain text base with company footer
   - `templates/verification.html`: Extends base, has verify button, link, expiry warning
   - `templates/verification.txt`: Plain text version with link and expiry

5. Create `get_email_service()` factory:
   - Reads SMTP_HOST, SMTP_PORT, SMTP_USER, SMTP_PASSWORD, SMTP_FROM_NAME, SMTP_FROM_EMAIL from os.environ
   - Returns SmtpEmailAdapter instance configured from env vars
   - Default SMTP_PORT to 1025 (Mailpit), use_tls to False for dev

Template variables per CONTEXT.md decisions:
- recipient_name (optional)
- verification_link
- expiry_hours (default 48)
- company_name (from env or default)
- support_email (from env or default)
  </action>
  <verify>
Run `python -c "from src.adapters.email import SmtpEmailAdapter, get_email_service, render_verification_email; print('OK')"` succeeds.
Verify templates exist: `ls src/adapters/email/templates/*.html src/adapters/email/templates/*.txt`
Run `pytest tests/ -x -q` passes (no regressions).
  </verify>
  <done>
SmtpEmailAdapter implements EmailService protocol. Templates render HTML+text verification emails. get_email_service() factory returns configured adapter.
  </done>
</task>

</tasks>

<verification>
1. EmailService protocol importable from domain/ports
2. SmtpEmailAdapter importable from adapters/email
3. Templates exist and can be rendered with test data
4. No domain layer imports infrastructure (lint-imports clean)
5. All existing tests pass
</verification>

<success_criteria>
- EmailService protocol with send_email method defined in domain/ports
- SmtpEmailAdapter implements protocol with multipart HTML+text email
- Jinja2 templates render verification email with link, expiry, footer
- get_email_service() factory reads from environment variables
- lint-imports passes (clean architecture maintained)
</success_criteria>

<output>
After completion, create `.planning/phases/06-transactional-email-infrastructure/06-01-SUMMARY.md`
</output>
