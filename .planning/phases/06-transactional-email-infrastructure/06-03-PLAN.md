---
phase: 06-transactional-email-infrastructure
plan: 03
type: execute
wave: 3
depends_on: ["06-02"]
files_modified:
  - src/adapters/security/tokens.py
  - src/adapters/jobs/tasks.py
  - src/application/handlers/user_handlers.py
autonomous: true

must_haves:
  truths:
    - "Verification token valid for 48 hours (not 24)"
    - "send_verification_email job renders and sends email via EmailService"
    - "UserRegistered event handler enqueues verification email job"
  artifacts:
    - path: "src/adapters/security/tokens.py"
      provides: "48-hour token expiry"
      contains: "172800"
    - path: "src/adapters/jobs/tasks.py"
      provides: "Implemented send_verification_email job"
      contains: "email_service.send_email"
    - path: "src/application/handlers/user_handlers.py"
      provides: "Job queue integration"
      contains: "defer_async"
  key_links:
    - from: "src/application/handlers/user_handlers.py"
      to: "src/adapters/jobs/tasks.py"
      via: "defer_async call"
      pattern: "send_verification_email\\.defer_async"
    - from: "src/adapters/jobs/tasks.py"
      to: "src/adapters/email"
      via: "get_email_service import"
      pattern: "from src\\.adapters\\.email import"
---

<objective>
Wire email sending to event flow: update token expiry, implement job task, connect event handler to job queue.

Purpose: When a user registers, the UserRegistered event triggers a job that sends the verification email.
Output: Complete event-to-email flow that can be tested end-to-end.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/CHECKPOINTS.md
@.planning/phases/06-transactional-email-infrastructure/06-CONTEXT.md
@.planning/phases/06-transactional-email-infrastructure/06-RESEARCH.md

# Files to modify
@src/adapters/security/tokens.py
@src/adapters/jobs/tasks.py
@src/application/handlers/user_handlers.py

# Dependencies from Plan 01
@src/adapters/email/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update verification token expiry to 48 hours</name>
  <files>
    src/adapters/security/tokens.py
  </files>
  <action>
Update token expiry from 24 hours to 48 hours per CONTEXT.md decision:

1. Change EMAIL_VERIFICATION_MAX_AGE from 86400 to 172800 (48 hours in seconds)
2. Update docstring to reflect 48-hour validity
3. Keep all other token logic unchanged

This aligns the token expiry with what the email template promises ("This link expires in 48 hours").

Per RESEARCH.md Pitfall 1: Token expiry mismatch is a common bug. Email says 48h but token expires in 24h = user confusion.
  </action>
  <verify>
Run `python -c "from src.adapters.security.tokens import EMAIL_VERIFICATION_MAX_AGE; assert EMAIL_VERIFICATION_MAX_AGE == 172800, f'Expected 172800, got {EMAIL_VERIFICATION_MAX_AGE}'; print('OK')"` succeeds.
Run `pytest tests/ -k "token" -x -q` passes (token tests still work with new expiry).
  </verify>
  <done>
EMAIL_VERIFICATION_MAX_AGE is 172800 seconds (48 hours). Token tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement send_verification_email job task</name>
  <files>
    src/adapters/jobs/tasks.py
  </files>
  <action>
Implement the send_verification_email job to actually send emails:

1. Import from email adapter:
   - from src.adapters.email import get_email_service, render_verification_email

2. Import os for APP_BASE_URL

3. Add EmailDeliveryError to email_retry exceptions:
   - from src.domain.ports import EmailDeliveryError
   - Update email_retry = RetryStrategy(..., retry_exceptions={ConnectionError, TimeoutError, EmailDeliveryError})

4. Implement send_verification_email task body:
```python
@job_queue.task(queue="email", retry=email_retry)
async def send_verification_email(
    user_id: str,
    email: str,
    verification_token: str,
) -> None:
    """Send verification email to newly registered user."""
    logger.info("sending_verification_email", user_id=user_id)

    # Get email service
    email_service = get_email_service()

    # Build verification link
    base_url = os.environ.get("APP_BASE_URL", "http://localhost:8000")
    verification_link = f"{base_url}/auth/verify-email?token={verification_token}"

    # Render templates
    html_content, text_content = render_verification_email(
        recipient_name=None,  # Don't have display_name in job args
        verification_link=verification_link,
        expiry_hours=48,
    )

    # Send email
    email_service.send_email(
        to_email=email,
        subject="Confirm your email to get started",
        html_content=html_content,
        text_content=text_content,
    )

    logger.info("verification_email_sent", user_id=user_id)
```

Note: Job is async but SmtpEmailAdapter.send_email is sync. This is fine - sync code runs in async context without issue. If performance becomes a problem, switch to aiosmtplib later.
  </action>
  <verify>
Run `python -c "from src.adapters.jobs.tasks import send_verification_email; print('OK')"` succeeds.
Run `pytest tests/ -x -q` passes (no regressions).
  </verify>
  <done>
send_verification_email job imports email adapter and sends real emails. Retry strategy includes EmailDeliveryError.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire event handler to enqueue email job</name>
  <files>
    src/application/handlers/user_handlers.py
  </files>
  <action>
Update on_user_registered handler to enqueue the verification email job:

1. Import the job task:
   - from src.adapters.jobs.tasks import send_verification_email

2. Import token generation:
   - from src.adapters.security.tokens import generate_verification_token

3. Update on_user_registered to be async and enqueue job:
```python
async def on_user_registered(event: UserRegistered) -> None:
    """Handle UserRegistered event.

    Enqueues verification email job. The job will send the email
    asynchronously via the job queue.

    Args:
        event: The UserRegistered event with user_id, email, household_id
    """
    logger.info(
        "user_registered_handler",
        user_id=event.user_id,
        household_id=event.household_id,
    )

    # Generate verification token
    verification_token = generate_verification_token(event.email)

    # Enqueue email job
    await send_verification_email.defer_async(
        user_id=event.user_id,
        email=event.email,
        verification_token=verification_token,
    )

    logger.info(
        "verification_email_job_enqueued",
        user_id=event.user_id,
    )
```

Per RESEARCH.md Pitfall 6: Event handlers should use defer_async() for async job deferral. The event bus must call handlers with await if they're async.

Note: Check if event bus supports async handlers. If not, may need to use synchronous defer() method or update event bus.
  </action>
  <verify>
Run `python -c "from src.application.handlers.user_handlers import on_user_registered; import inspect; print('async' if inspect.iscoroutinefunction(on_user_registered) else 'sync')"` shows "async".
Run `pytest tests/ -x -q` passes (handler tests may need updates for async).
  </verify>
  <done>
on_user_registered generates verification token and enqueues send_verification_email job via defer_async.
  </done>
</task>

</tasks>

<verification>
1. Token expiry is 172800 seconds (48 hours)
2. send_verification_email job imports and uses email adapter
3. on_user_registered enqueues email job with token
4. All existing tests pass
5. Async/sync compatibility verified
</verification>

<success_criteria>
- EMAIL_VERIFICATION_MAX_AGE = 172800 (48 hours)
- send_verification_email job renders templates and calls email_service.send_email
- on_user_registered generates token and calls defer_async to enqueue job
- Email retry strategy includes EmailDeliveryError
- No test regressions
</success_criteria>

<output>
After completion, create `.planning/phases/06-transactional-email-infrastructure/06-03-SUMMARY.md`
</output>
