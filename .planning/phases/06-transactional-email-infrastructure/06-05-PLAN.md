---
phase: 06-transactional-email-infrastructure
plan: 05
type: execute
wave: 5
depends_on: ["06-04"]
files_modified:
  - src/application/event_bus.py
  - src/domain/ports/unit_of_work.py
  - src/adapters/persistence/unit_of_work.py
  - src/application/handlers/user_handlers.py
  - src/application/services/auth_service.py
  - src/application/services/account_service.py
  - src/application/services/category_service.py
  - src/application/services/transaction_service.py
  - src/adapters/api/routes/auth.py
  - src/adapters/api/routes/accounts.py
  - src/adapters/api/routes/categories.py
  - src/adapters/api/routes/transactions.py
  - tests/integration/test_event_publishing.py
  - tests/integration/test_email_verification.py
autonomous: true

must_haves:
  truths:
    - "Event bus publish/publish_all are async and support both sync and async handlers"
    - "UoW.commit() is async and awaits event publishing"
    - "All service methods that call commit() are async"
    - "All route handlers await service method calls"
    - "on_user_registered is async and directly awaits defer_async (no create_task workaround)"
    - "Integration tests call publish/publish_all with await"
    - "All existing tests pass"
  artifacts:
    - path: "src/application/event_bus.py"
      provides: "Async event bus"
      contains: "async def publish"
    - path: "src/application/handlers/user_handlers.py"
      provides: "Async handler with proper await"
      contains: "await send_verification_email.defer_async"
  key_links:
    - from: "src/adapters/persistence/unit_of_work.py"
      to: "src/application/event_bus.py"
      via: "await publish_all"
      pattern: "await publish_all"
---

<objective>
Convert event bus, UoW commit, service layer, and routes to async so event handlers can properly await async operations like Procrastinate's defer_async().

Purpose: Eliminate the fire-and-forget create_task workaround in on_user_registered by making the entire publish chain async-aware.
Output: Async event bus, async UoW commit, async services, properly awaited defer_async in handler, passing tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/CHECKPOINTS.md
@.planning/phases/06-transactional-email-infrastructure/06-CONTEXT.md
@.planning/phases/06-transactional-email-infrastructure/06-04-SUMMARY.md

# Key files to modify
@src/application/event_bus.py
@src/domain/ports/unit_of_work.py
@src/adapters/persistence/unit_of_work.py
@src/application/handlers/user_handlers.py
@src/application/services/auth_service.py
@src/application/services/account_service.py
@src/application/services/category_service.py
@src/application/services/transaction_service.py
@src/adapters/api/routes/auth.py
@src/adapters/api/routes/accounts.py
@src/adapters/api/routes/categories.py
@src/adapters/api/routes/transactions.py
@tests/integration/test_event_publishing.py
@tests/integration/test_email_verification.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Make event bus async with mixed handler support</name>
  <files>
    src/application/event_bus.py
  </files>
  <action>
Convert publish() and publish_all() to async. Support both sync and async handlers.

Modify `src/application/event_bus.py`:

1. Add `import inspect` at top

2. Change `publish()` to async:
```python
async def publish(event: Any) -> None:
    event_type = type(event)
    handlers = _handlers.get(event_type, [])

    for handler in handlers:
        try:
            logger.info(
                "handling_event",
                event_type=event_type.__name__,
                handler=handler.__name__,
            )
            if inspect.iscoroutinefunction(handler):
                await handler(event)
            else:
                handler(event)
        except Exception:
            logger.exception(
                "handler_failed",
                event_type=event_type.__name__,
                handler=handler.__name__,
            )
            raise
```

3. Change `publish_all()` to async:
```python
async def publish_all(events: list[Any]) -> None:
    for event in events:
        await publish(event)
```

4. Update docstrings to reflect async behavior and mixed handler support.
  </action>
  <verify>
Run `python -c "import asyncio; from src.application.event_bus import publish, publish_all; print('async:', asyncio.iscoroutinefunction(publish), asyncio.iscoroutinefunction(publish_all))"` — should print "async: True True".
  </verify>
  <done>
Event bus publish/publish_all are async and support both sync and async handlers via inspect.iscoroutinefunction.
  </done>
</task>

<task type="auto">
  <name>Task 2: Make UoW commit async</name>
  <files>
    src/domain/ports/unit_of_work.py
    src/adapters/persistence/unit_of_work.py
  </files>
  <action>
Update UoW protocol and implementation to make commit() async.

1. In `src/domain/ports/unit_of_work.py`, change commit signature:
```python
async def commit(self) -> None:
    """Commit all changes to the database.

    This persists all added/modified entities and any collected
    domain events to the outbox table. After DB commit succeeds,
    publishes events to registered handlers asynchronously.
    """
    ...
```

Update the docstring at class level to show `await uow.commit()` in the usage example.

2. In `src/adapters/persistence/unit_of_work.py`, change commit() to async:
```python
async def commit(self) -> None:
```

The only async operation inside is the call to `publish_all()`. The SQLAlchemy session.commit() remains sync (blocking). Change the publish_all call from:
```python
publish_all(events_to_publish)
```
to:
```python
await publish_all(events_to_publish)
```

Everything else in commit() stays the same (outbox writes, session.commit(), event clearing are all sync SQLAlchemy operations).

The context manager (__enter__/__exit__) stays sync — no changes needed there.
  </action>
  <verify>
Run `python -c "import asyncio; from src.adapters.persistence.unit_of_work import SqlAlchemyUnitOfWork; print('async commit:', asyncio.iscoroutinefunction(SqlAlchemyUnitOfWork.commit))"` — should print True.
  </verify>
  <done>
UoW protocol and implementation commit() is async. Context manager stays sync.
  </done>
</task>

<task type="auto">
  <name>Task 3: Make service methods async</name>
  <files>
    src/application/services/auth_service.py
    src/application/services/account_service.py
    src/application/services/category_service.py
    src/application/services/transaction_service.py
  </files>
  <action>
Convert all service methods that call self._uow.commit() from sync to async.

For each service file, the changes are mechanical:
1. Every method containing `self._uow.commit()` → change `def` to `async def`
2. Every `self._uow.commit()` → `await self._uow.commit()`
3. The `with self._uow:` context manager stays unchanged (sync context managers work inside async functions)

**auth_service.py** — 7 methods:
- `register()` → `async def register()`, `await self._uow.commit()`
- `login()` → `async def login()`, `await self._uow.commit()`
- `refresh()` → `async def refresh()`, `await self._uow.commit()`
- `verify_email()` → `async def verify_email()`, `await self._uow.commit()`
- `logout_all_sessions()` → `async def logout_all_sessions()`, `await self._uow.commit()`
- `get_user_by_id()` — no commit, stays sync
- `get_user_profile()` — no commit, stays sync

**account_service.py** — all write methods:
- All create_* methods (7) → async + await commit
- `close_account()`, `reopen_account()` → async + await commit
- `delete_account()` → async + await commit
- `update_account_name()` → async + await commit
- Read methods (`get_account`, `get_household_accounts`, `get_user_accounts`) — no commit, stay sync

**category_service.py** — all write methods:
- `ensure_system_categories()` → async + await commit
- `create_category()` → async + await commit
- `update_category_name()` → async + await commit
- `update_category_parent()` → async + await commit
- `delete_category()` → async + await commit
- Read methods (`get_category`, `get_user_categories`, `get_category_tree`) — no commit, stay sync

**transaction_service.py** — all write methods:
- `create_transaction()` → async + await commit
- `update_transaction_memo()` → async + await commit
- `update_transaction_dates()` → async + await commit
- `update_transaction_splits()` → async + await commit
- `mark_transaction_cleared()` → async + await commit
- `mark_transaction_reconciled()` → async + await commit
- `delete_transaction()` → async + await commit
- Private helper `_create_mirror_transactions()` — no commit, stays sync
- Private helper `_sync_mirrors_for_split_update()` — no commit, stays sync
- Read methods — no commit, stay sync

Important: Only change `def` → `async def` and `self._uow.commit()` → `await self._uow.commit()`. Do NOT change any other code in these methods. The `with self._uow:` blocks stay as-is.
  </action>
  <verify>
Run `python -c "import asyncio; from src.application.services.auth_service import AuthService; print('register async:', asyncio.iscoroutinefunction(AuthService.register))"` — should print True.
Run `python -c "from src.application.services.auth_service import AuthService; print('get_user_by_id async:', asyncio.iscoroutinefunction(AuthService.get_user_by_id) if hasattr(AuthService, 'get_user_by_id') else 'N/A')"` — should print False (read methods stay sync).
  </verify>
  <done>
All service write methods are async with await self._uow.commit(). Read methods stay sync.
  </done>
</task>

<task type="auto">
  <name>Task 4: Update routes to await service calls</name>
  <files>
    src/adapters/api/routes/auth.py
    src/adapters/api/routes/accounts.py
    src/adapters/api/routes/categories.py
    src/adapters/api/routes/transactions.py
  </files>
  <action>
Update all route handlers to await async service methods.

**auth.py** — already `async def`, just add `await`:
- `await service.register(...)` (was `service.register(...)`)
- `await service.login(...)`
- `await service.refresh(...)`
- `await service.verify_email(...)`
- `await service.logout_all_sessions(...)`
- `service.get_user_profile(...)` — stays sync (read method, no await)

**accounts.py** — already `async def`, just add `await`:
- All create_* calls → `await service.create_*(...)`
- `await service.close_account(...)`
- `await service.reopen_account(...)`
- `await service.delete_account(...)`
- `await service.update_account_name(...)`
- Read calls (get_account, get_household_accounts, get_user_accounts) — stay sync, no await

**categories.py** — change `def` to `async def`, add `await`:
- All route functions → `async def`
- `await service.ensure_system_categories(...)` where called
- `await service.create_category(...)`
- `await service.update_category_name(...)` / `await service.update_category_parent(...)`
- `await service.delete_category(...)`
- Read calls (get_category, get_user_categories, get_category_tree) — stay sync, no await
  - BUT: if a route ONLY calls sync read methods, it should stay `def` (not `async def`) so FastAPI runs it in thread pool — this avoids blocking the event loop with sync DB I/O
  - Routes that mix read + write calls should be `async def` with `await` on the write calls only

**transactions.py** — change `def` to `async def`, add `await`:
- Same pattern as categories: write routes → `async def` + `await`
- Pure read routes → stay `def` (FastAPI thread pool)

Important: For routes that call `ensure_system_categories()` (which is async) before a read, those routes must also be `async def`.
  </action>
  <verify>
Run `python -c "from src.adapters.api.app import create_app; app = create_app(); print('App created successfully')"` — should print without import errors.
  </verify>
  <done>
All routes properly await async service methods. Read-only routes stay sync for thread pool execution.
  </done>
</task>

<task type="auto">
  <name>Task 5: Make handler async, remove create_task workaround</name>
  <files>
    src/application/handlers/user_handlers.py
  </files>
  <action>
Convert on_user_registered to async and properly await defer_async.

1. Remove `import asyncio` (no longer needed)

2. Change `on_user_registered` to async:
```python
async def on_user_registered(event: UserRegistered) -> None:
    """Handle UserRegistered event.

    Generates a verification token and enqueues a job to send
    the verification email. Awaits defer_async directly since
    the event bus supports async handlers.

    If the job queue is disabled (JOB_QUEUE_ENABLED=false), the
    defer is skipped and only a log message is emitted.
    """
```

3. Replace the create_task workaround with direct await:
```python
    try:
        from src.adapters.jobs.tasks import send_verification_email

        await send_verification_email.defer_async(
            user_id=event.user_id,
            email=event.email,
            verification_token=verification_token,
        )

        logger.info(
            "verification_email_job_enqueued",
            user_id=event.user_id,
        )
    except Exception:
        # Job queue may be unavailable (not opened, DB down, etc.).
        # Email is a side effect -- registration must not fail because
        # the verification email could not be enqueued.
        logger.warning(
            "verification_email_defer_failed",
            user_id=event.user_id,
            exc_info=True,
        )
```

The try/except now properly catches errors from defer_async because we're awaiting it directly instead of fire-and-forget via create_task.

4. `on_email_verified` can stay sync (it's a no-op logger, event bus handles both).
  </action>
  <verify>
Run `python -c "import asyncio; from src.application.handlers.user_handlers import on_user_registered; print('async handler:', asyncio.iscoroutinefunction(on_user_registered))"` — should print True.
  </verify>
  <done>
on_user_registered is async, directly awaits defer_async with proper error handling. No more create_task workaround.
  </done>
</task>

<task type="auto">
  <name>Task 6: Fix integration tests for async event bus and defer</name>
  <files>
    tests/integration/test_event_publishing.py
    tests/integration/test_email_verification.py
  </files>
  <action>
Update tests to work with async event bus and async UoW commit.

**test_event_publishing.py:**

1. Add `import asyncio` at top.

2. `TestEventBusRegistration` — tests call `event_bus.publish()` directly. Since publish is now async, these need to use `asyncio.run()` or be made async with pytest-asyncio. Since the project may not have pytest-asyncio, use `asyncio.run()`:

For each test that calls `event_bus.publish(event)`, change to:
```python
asyncio.run(event_bus.publish(event))
```

Similarly for `event_bus.publish_all()`.

3. `TestUnitOfWorkEventPublishing` — tests call `uow.commit()` which is now async. Change to:
```python
asyncio.run(uow.commit())
```

The `with uow:` context manager stays sync, only the commit() call inside changes.

Example for `test_uow_commit_publishes_events`:
```python
def test_uow_commit_publishes_events(self, session_factory) -> None:
    received_events = []
    def test_handler(event):
        received_events.append(event)
    event_bus.register(UserRegistered, test_handler)

    uow = SqlAlchemyUnitOfWork(session_factory)
    with uow:
        household = Household.create(name="Test Household")
        user = User.create(...)
        events = user.collect_events()
        uow.collect_events(events)
        uow.households.add(household)
        uow.users.add(user)
        asyncio.run(uow.commit())  # was uow.commit()

    assert len(received_events) == 1
```

IMPORTANT: `asyncio.run()` creates a new event loop, which works in test context since there's no running loop. But if tests already run under an event loop (e.g., pytest-asyncio), this would fail. Check if there's a running loop first — if so, use `loop.run_until_complete()` instead.

Actually, the simpler approach: since these tests are sync and there's no running event loop in test context, `asyncio.run()` is correct.

4. `TestHandlerRegistration.test_register_all_handlers_registers_user_handlers` — calls `event_bus.publish()` directly. Change to `asyncio.run(event_bus.publish(event))`.

**test_email_verification.py:**

1. `test_registration_enqueues_verification_email` — currently mocks `send_verification_email.defer`. Since the handler now calls `defer_async`, mock that instead:
```python
def test_registration_enqueues_verification_email(
    self, client_with_handlers, test_user_data
) -> None:
    from src.adapters.jobs.tasks import send_verification_email

    original_defer_async = send_verification_email.defer_async
    mock_defer_async = AsyncMock()
    send_verification_email.defer_async = mock_defer_async

    try:
        response = client_with_handlers.post(
            "/auth/register", json=test_user_data
        )

        assert response.status_code == 202
        mock_defer_async.assert_called_once()
        call_kwargs = mock_defer_async.call_args.kwargs
        assert call_kwargs["email"] == test_user_data["email"].lower()
        assert "verification_token" in call_kwargs
        assert "user_id" in call_kwargs
    finally:
        send_verification_email.defer_async = original_defer_async
```

Add `from unittest.mock import AsyncMock` to imports if not already present.

2. The `registered_user` fixture in `conftest.py` calls `client.post("/auth/register", ...)` which goes through the route → service → async commit. TestClient handles this transparently (it runs an event loop internally). Verify this still works.
  </action>
  <verify>
Run `uv run pytest tests/integration/test_event_publishing.py -v` — all tests pass.
Run `uv run pytest tests/integration/test_email_verification.py -v` — all tests pass.
Run `uv run pytest tests/ -x -q` — full suite passes, no regressions.
  </verify>
  <done>
All integration tests updated for async event bus and defer_async mocking. Full test suite passes.
  </done>
</task>

</tasks>

<verification>
1. event_bus.publish and publish_all are async def
2. UoW.commit() is async def, awaits publish_all
3. All service write methods are async, await commit
4. All routes await async service methods
5. on_user_registered is async, awaits defer_async directly (no create_task)
6. All tests pass (unit and integration)
7. App starts and responds to requests (smoke test per CHECKPOINTS.md)
</verification>

<success_criteria>
- Async event bus with mixed sync/async handler support
- Proper await chain: route → service → commit → publish_all → handler → defer_async
- No fire-and-forget create_task workaround
- Error handling works: defer_async failures caught by handler try/except
- All existing tests pass with no regressions
- Service per CHECKPOINTS.md: start app, smoke test endpoint with curl
</success_criteria>

<output>
After completion, create `.planning/phases/06-transactional-email-infrastructure/06-05-SUMMARY.md`
</output>
