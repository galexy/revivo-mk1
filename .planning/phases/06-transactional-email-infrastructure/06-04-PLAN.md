---
phase: 06-transactional-email-infrastructure
plan: 04
type: execute
wave: 4
depends_on: ["06-03"]
files_modified:
  - tests/mocks/__init__.py
  - tests/mocks/email.py
  - tests/integration/test_email_verification.py
  - tests/conftest.py
autonomous: false

must_haves:
  truths:
    - "MockEmailAdapter records sent emails for test assertions"
    - "Integration tests verify email sent on registration"
    - "End-to-end flow: register -> Mailpit -> verify link -> user verified"
  artifacts:
    - path: "tests/mocks/email.py"
      provides: "MockEmailAdapter for testing"
      contains: "class MockEmailAdapter"
    - path: "tests/integration/test_email_verification.py"
      provides: "Integration tests for email flow"
      contains: "test_registration_enqueues_verification_email"
  key_links:
    - from: "tests/integration/test_email_verification.py"
      to: "tests/mocks/email.py"
      via: "mock email fixture"
      pattern: "mock_email"
---

<objective>
Create mock email adapter for testing and integration tests for verification email flow, with final human verification.

Purpose: Ensure email flow works without real SMTP calls in tests, plus manual verification of full dev workflow.
Output: MockEmailAdapter, integration tests, verified end-to-end email flow.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/CHECKPOINTS.md
@.planning/phases/06-transactional-email-infrastructure/06-CONTEXT.md
@.planning/phases/06-transactional-email-infrastructure/06-RESEARCH.md

# Test patterns
@tests/conftest.py
@tests/integration/test_auth.py

# Email infrastructure from Plan 01
@src/adapters/email/__init__.py
@src/domain/ports/email_service.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MockEmailAdapter for testing</name>
  <files>
    tests/mocks/__init__.py
    tests/mocks/email.py
  </files>
  <action>
Create mock email adapter following project test patterns:

1. Create `tests/mocks/` directory if not exists

2. Create `tests/mocks/__init__.py`:
   - Export MockEmailAdapter

3. Create `tests/mocks/email.py`:
```python
"""Mock email adapter for testing.

Records sent emails for assertion without making real SMTP calls.
"""
from dataclasses import dataclass, field


@dataclass
class SentEmail:
    """Record of a sent email."""
    to_email: str
    subject: str
    html_content: str
    text_content: str


@dataclass
class MockEmailAdapter:
    """Mock email adapter that records sent emails.

    Implements EmailService protocol for test injection.
    """
    sent_emails: list[SentEmail] = field(default_factory=list)

    def send_email(
        self,
        to_email: str,
        subject: str,
        html_content: str,
        text_content: str,
    ) -> None:
        """Record email instead of sending."""
        self.sent_emails.append(SentEmail(
            to_email=to_email,
            subject=subject,
            html_content=html_content,
            text_content=text_content,
        ))

    def get_last_email(self) -> SentEmail | None:
        """Get the most recently sent email."""
        return self.sent_emails[-1] if self.sent_emails else None

    def get_emails_to(self, email: str) -> list[SentEmail]:
        """Get all emails sent to a specific address."""
        return [e for e in self.sent_emails if e.to_email == email]

    def clear(self) -> None:
        """Clear all recorded emails."""
        self.sent_emails.clear()
```
  </action>
  <verify>
Run `python -c "from tests.mocks.email import MockEmailAdapter, SentEmail; m = MockEmailAdapter(); m.send_email('a@b.c', 'Sub', '<h>Hi</h>', 'Hi'); print(m.get_last_email().to_email)"` outputs "a@b.c".
  </verify>
  <done>
MockEmailAdapter exists in tests/mocks/ and records sent emails for assertions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create integration tests for verification email flow</name>
  <files>
    tests/integration/test_email_verification.py
    tests/conftest.py
  </files>
  <action>
Create integration tests for email verification flow:

1. Add mock email fixture to tests/conftest.py (or in test file):
```python
from tests.mocks.email import MockEmailAdapter
from src.adapters.email import get_email_service

@pytest.fixture
def mock_email_adapter(app):
    """Fixture providing mock email adapter."""
    adapter = MockEmailAdapter()
    # Override the email service factory in the app
    app.dependency_overrides[get_email_service] = lambda: adapter
    yield adapter
    app.dependency_overrides.pop(get_email_service, None)
```

Note: The email adapter is used in job tasks, not directly in API routes. Need to mock at module level for job tests.

2. Create `tests/integration/test_email_verification.py`:
```python
"""Integration tests for email verification flow.

These tests verify:
- Registration enqueues verification email job
- Verification email contains correct link
- Verification link works to verify user
"""
import pytest
from unittest.mock import patch, AsyncMock

# Test: Registration triggers email job
# Mock the job defer to capture arguments
def test_registration_enqueues_verification_email(client, db_session):
    """Registration should enqueue verification email job."""
    with patch("src.application.handlers.user_handlers.send_verification_email") as mock_job:
        mock_job.defer_async = AsyncMock()

        response = client.post("/auth/register", json={
            "email": "newuser@example.com",
            "password": "SecurePass123!",
        })

        assert response.status_code == 202
        # Verify job was enqueued with correct args
        mock_job.defer_async.assert_called_once()
        call_args = mock_job.defer_async.call_args
        assert call_args.kwargs["email"] == "newuser@example.com"
        assert "verification_token" in call_args.kwargs


# Test: Verification link format
def test_verification_email_contains_link(client, db_session):
    """Verification email should contain verification link."""
    # This test needs to run the job and check email content
    # For now, test that template renders correctly
    from src.adapters.email import render_verification_email

    html, text = render_verification_email(
        recipient_name="Test User",
        verification_link="http://localhost:8000/auth/verify-email?token=abc123",
        expiry_hours=48,
    )

    assert "http://localhost:8000/auth/verify-email?token=abc123" in html
    assert "http://localhost:8000/auth/verify-email?token=abc123" in text
    assert "48 hours" in html
    assert "48 hours" in text


# Test: Verification endpoint works
def test_verification_link_verifies_user(client, db_session):
    """Clicking verification link should verify user."""
    from src.adapters.security.tokens import generate_verification_token

    # Register user
    with patch("src.application.handlers.user_handlers.send_verification_email") as mock_job:
        mock_job.defer_async = AsyncMock()
        response = client.post("/auth/register", json={
            "email": "verify@example.com",
            "password": "SecurePass123!",
        })
        assert response.status_code == 202

    # Generate token (simulating what job would do)
    token = generate_verification_token("verify@example.com")

    # Click verification link
    response = client.get(f"/auth/verify-email?token={token}")
    assert response.status_code == 200

    # Verify user can now login (email verified)
    response = client.post(
        "/auth/token",
        data={"username": "verify@example.com", "password": "SecurePass123!"},
    )
    assert response.status_code == 200
```

Adjust test patterns based on existing test_auth.py patterns.
  </action>
  <verify>
Run `pytest tests/integration/test_email_verification.py -v` passes all tests.
Run `pytest tests/ -x -q` passes (no regressions in other tests).
  </verify>
  <done>
Integration tests verify: registration enqueues job, email contains link, verification link works.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: End-to-end verification email flow</name>
  <what-built>
Complete email verification infrastructure:
- EmailService protocol and SMTP adapter
- Mailpit in Docker Compose
- Event handler enqueues verification email job
- 48-hour token expiry matching email content
- Integration tests with mock email adapter
  </what-built>
  <how-to-verify>
1. Start the full Docker Compose stack:
   ```bash
   docker compose up -d
   ```

2. Apply migrations and start the service:
   ```bash
   alembic upgrade head
   uvicorn src.main:app --host 0.0.0.0 --port 8000 &
   ```

3. Open Mailpit web UI:
   - Navigate to http://localhost:8025 in browser
   - Should see empty inbox

4. Register a new user:
   ```bash
   curl -X POST http://localhost:8000/auth/register \
     -H "Content-Type: application/json" \
     -d '{"email": "test@example.com", "password": "SecurePass123!"}'
   ```
   - Should return 202

5. Check Mailpit inbox:
   - Refresh http://localhost:8025
   - Should see verification email to test@example.com
   - Open email and verify:
     - Subject: "Confirm your email to get started"
     - Contains verification link
     - States "48 hours" expiry
     - Has plain text alternative

6. Click verification link (or copy to curl):
   - Link should be like: http://localhost:8000/auth/verify-email?token=...
   - Clicking should return 200 (or redirect on success)

7. Verify user can login:
   ```bash
   curl -X POST http://localhost:8000/auth/token \
     -d "username=test@example.com&password=SecurePass123!" \
     -H "Content-Type: application/x-www-form-urlencoded"
   ```
   - Should return JWT (user is now verified)

8. Verify re-clicking link is idempotent:
   - Click same verification link again
   - Should still succeed (not error)
  </how-to-verify>
  <resume-signal>Type "approved" if all steps pass, or describe any issues found.</resume-signal>
</task>

</tasks>

<verification>
1. MockEmailAdapter records emails without SMTP calls
2. Integration tests pass for email flow
3. Full stack runs with Mailpit
4. Registration sends email to Mailpit
5. Verification link in email works
6. User becomes verified after clicking link
</verification>

<success_criteria>
- MockEmailAdapter in tests/mocks/ implements EmailService protocol
- Integration tests verify job enqueue and template rendering
- Dev workflow complete: register -> Mailpit shows email -> click link -> user verified
- All tests pass (unit and integration)
- Human verified end-to-end flow works
</success_criteria>

<output>
After completion, create `.planning/phases/06-transactional-email-infrastructure/06-04-SUMMARY.md`
</output>
