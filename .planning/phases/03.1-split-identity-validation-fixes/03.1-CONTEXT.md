# Phase 3.1 Context: Split Identity & Validation Fixes

## Problem Statement

Phase 3 UAT revealed 4 issues that require fixes before proceeding to Phase 4:

1. **Invalid IDs return 500** - API returns Internal Server Error instead of 400 for invalid account/category IDs
2. **Empty string category accepted** - Split with `category_id: ""` creates split with null for both fields
3. **Categories lack type** - No income/expense distinction for categories
4. **Split-to-mirror linkage unclear** - When updating transfers, unclear which mirror corresponds to which split

Issue #4 is the most significant as it requires a modeling change from SplitLine as a value object to an entity with identity.

## Current State

### SplitLine (Value Object)
```python
@dataclass(frozen=True)
class SplitLine:
    amount: Money
    category_id: str | None
    transfer_account_id: str | None
    memo: str | None
```

- No identity - compared by attributes
- Immutable (frozen)
- No link between split and its mirror transaction

### Transaction (for mirrors)
```python
# Mirror transactions have:
source_transaction_id: str  # points to parent transaction
is_mirror: bool = True
```

- Mirror knows its source transaction
- But NOT which specific split it was created from

### The Problem Scenario

```
Transaction T1 in Checking (amount: -$1000):
  Split A: -$500 → Savings (creates Mirror M1 in Savings: +$500)
  Split B: -$500 → Savings (creates Mirror M2 in Savings: +$500)
```

Both splits have same amount and destination. If client PATCHes T1 to change one split to -$600:
- Which mirror should update?
- Current model has no way to match split to mirror

## Proposed Model Changes

### 1. SplitLine Becomes Entity

```python
@dataclass
class SplitLine:
    id: str  # split_xxx (TypeID, assigned on creation)
    amount: Money
    category_id: str | None
    transfer_account_id: str | None
    memo: str | None
    mirror_transaction_id: str | None  # populated for transfer splits after mirror creation
```

- Has identity via `id` field
- Server generates ID on creation
- Client must provide ID when updating existing splits

### 2. Transaction Gains source_split_id

```python
# For mirror transactions:
source_split_id: str | None  # which split this mirror was created from
```

- Only populated for mirrors
- Links mirror back to specific source split
- Enables proper update/delete matching

### 3. Category Gains type

```python
class CategoryType(StrEnum):
    INCOME = auto()
    EXPENSE = auto()

@dataclass
class Category:
    id: str
    name: str
    parent_id: str | None
    category_type: CategoryType  # NEW
    is_system: bool
```

## PATCH Semantics for Splits

### Request Format

```json
{
  "splits": [
    {"id": "split_1", "amount": {...}, "category_id": "cat_xxx"},  // update existing
    {"id": "split_2", "amount": {...}, "transfer_account_id": "acct_xxx"},  // update existing
    {"amount": {...}, "category_id": "cat_yyy"}  // no ID = create new
  ]
}
```

### Rules

1. **Include ID** → Update that existing split
2. **Omit ID** → Create new split (server generates ID)
3. **Existing split ID not in list** → Delete that split (and its mirror if transfer)

## Comprehensive PATCH Cases

### For Each EXISTING Split (one outcome):

| Outcome | Condition | Actions |
|---------|-----------|---------|
| **UNCHANGED** | ID in PATCH, data identical | No-op |
| **MODIFIED** | ID in PATCH, data different | See modification sub-cases |
| **REMOVED** | ID not in PATCH | Delete split (+ mirror if transfer) |

### Modification Sub-Cases

| Case | Change | Actions |
|------|--------|---------|
| M1 | Amount changed (category split) | Update split amount |
| M2 | Amount changed (transfer split) | Update split amount AND update mirror amount |
| M3 | Category changed | Update category_id |
| M4 | Transfer destination changed | Delete old mirror, create new mirror in new destination |
| M5 | Category → Transfer | Remove category_id, set transfer_account_id, create mirror |
| M6 | Transfer → Category | Delete mirror, remove transfer_account_id, set category_id |

### For Each INCOMING Split Without ID:

| Type | Actions |
|------|---------|
| Category | Generate split ID, create split |
| Transfer | Generate split ID, create split, create mirror (with source_split_id link) |

## Validation Rules

All validation happens BEFORE any mutations:

| Rule | Condition | Error |
|------|-----------|-------|
| V1 | Split ID not found on this transaction | 400 "Invalid split ID" |
| V2 | Split has neither category nor transfer | 400 "Split must have category or transfer" |
| V3 | Split has both category and transfer | 400 "Split cannot have both category and transfer" |
| V4 | Splits don't sum to transaction amount | 400 "Splits must sum to transaction amount" |
| V5 | Empty splits array | 400 "Must have at least one split" |
| V6 | Transfer to same account | 400 "Cannot transfer to same account" |
| V7 | Positive transfer amount | 400 "Transfer splits must be negative" |
| V8 | Category ID invalid or not found | 400 "Category not found" |
| V9 | Account ID invalid or not found | 400 "Account not found" |
| V10 | Transaction is a mirror | 400 "Cannot modify mirror directly" |
| V11 | Empty string for category_id or transfer_account_id | 400 "Invalid ID format" |

## Processing Algorithm

```
PATCH /transactions/{id}
  with body: { amount?, splits?, memo?, ... }

1. LOAD transaction
   - If not found: 404
   - If is_mirror: 400 "Cannot modify mirror directly"

2. If splits provided:
   a. VALIDATE all incoming splits (V1-V11)

   b. CATEGORIZE each incoming split:
      - Has ID matching existing → UPDATE
      - Has no ID → CREATE

   c. IDENTIFY removals:
      - Existing splits whose IDs not in PATCH → DELETE

   d. PROCESS deletions first:
      For each removed split:
        - If transfer: delete mirror (by source_split_id match)
        - Delete split

   e. PROCESS updates:
      For each matched split:
        - Detect change type (M1-M6)
        - Apply appropriate actions

   f. PROCESS creations:
      For each new split (no ID):
        - Generate split ID
        - Create split
        - If transfer: create mirror with source_split_id

3. VALIDATE final state:
   - Splits sum to transaction amount
   - At least one split exists

4. COMMIT atomically
```

## Database Migration

### New Columns

```sql
-- split_lines table
ALTER TABLE split_lines ADD COLUMN id VARCHAR(36) NOT NULL;
ALTER TABLE split_lines ADD COLUMN mirror_transaction_id VARCHAR(36);

-- transactions table
ALTER TABLE transactions ADD COLUMN source_split_id VARCHAR(36);

-- categories table
ALTER TABLE categories ADD COLUMN category_type VARCHAR(10) NOT NULL DEFAULT 'expense';
```

### Backfill Strategy

1. Generate IDs for all existing splits
2. For existing mirrors, match to splits by:
   - source_transaction_id (already have this)
   - If only one transfer split to that account, link is unambiguous
   - If multiple splits to same account with same amount, assign arbitrarily (edge case)
3. Set all existing categories to EXPENSE (most common default)

## API Response Changes

### Transaction Response

```json
{
  "id": "txn_xxx",
  "amount": {"amount": "-1000.00", "currency": "USD"},
  "splits": [
    {
      "id": "split_xxx",  // NEW - always present
      "amount": {"amount": "-500.00", "currency": "USD"},
      "category_id": "cat_xxx",
      "transfer_account_id": null,
      "mirror_transaction_id": null,
      "memo": "Groceries"
    },
    {
      "id": "split_yyy",  // NEW
      "amount": {"amount": "-500.00", "currency": "USD"},
      "category_id": null,
      "transfer_account_id": "acct_savings",
      "mirror_transaction_id": "txn_mirror",  // NEW - link to mirror
      "memo": "Savings transfer"
    }
  ],
  ...
}
```

### Category Response

```json
{
  "id": "cat_xxx",
  "name": "Groceries",
  "parent_id": null,
  "category_type": "expense",  // NEW
  "is_system": false
}
```

## Test Coverage Required

### Domain Tests

- SplitLine identity (ID generation, equality by ID)
- SplitLine validation (exactly one of category/transfer)
- Category type validation
- Transaction split manipulation (add, update, remove)

### Integration Tests (PATCH scenarios)

- All splits match, no changes
- All splits match, amounts changed (category)
- All splits match, amounts changed (transfer) - verify mirror sync
- Category changed on split
- Transfer destination changed - verify old mirror deleted, new created
- Category → Transfer conversion
- Transfer → Category conversion
- Some splits removed (category only)
- Some splits removed (transfer) - verify mirrors deleted
- New splits added (category)
- New splits added (transfer) - verify mirrors created
- Mixed: some updated, some removed, some added
- Invalid split ID in PATCH → 400
- Split with neither category nor transfer → 400
- Split with both category and transfer → 400
- Empty string category_id → 400
- Invalid category_id format → 400
- Non-existent category_id → 400
- Invalid account_id format → 400
- Non-existent account_id → 400

### UAT Verification

- Re-run failed UAT tests from Phase 3
- Verify all 4 issues are resolved

## Out of Scope

- Changing how transactions are created (only PATCH behavior changes)
- UI changes (Phase 4)
- Payee handling
- Transaction status changes (clear/reconcile)

## Dependencies

- Phase 3 complete (transaction domain exists)
- No external dependencies

## Risks

1. **Migration complexity** - Backfilling split IDs for existing data
2. **API contract change** - Clients must handle split IDs in responses
3. **Performance** - Additional lookups for mirror matching (mitigated by source_split_id index)
