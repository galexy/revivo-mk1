---
phase: 03.1-split-identity-validation-fixes
plan: 02
type: execute
wave: 2
depends_on: ["03.1-01"]
files_modified:
  - alembic/versions/004_add_split_identity.py
  - src/adapters/persistence/orm/tables.py
  - src/adapters/persistence/repositories/transaction.py
  - src/adapters/persistence/repositories/category.py
  - src/adapters/api/schemas/transaction.py
  - src/adapters/api/schemas/category.py
  - src/adapters/api/app.py
  - src/application/services/transaction_service.py
autonomous: true

must_haves:
  truths:
    - "Invalid account/category IDs return 400 (not 500)"
    - "Empty string for category_id or transfer_account_id returns 400"
    - "Split IDs are persisted and loaded from database"
    - "Mirror transactions have source_split_id linking to source split"
    - "Categories have category_type stored in database"
  artifacts:
    - path: "alembic/versions/004_add_split_identity.py"
      provides: "Database migration for split_id, source_split_id, category_type columns"
      contains: "split_id"
    - path: "src/adapters/api/app.py"
      provides: "ValueError exception handler returning 400"
      contains: "value_error_handler"
    - path: "src/adapters/api/schemas/transaction.py"
      provides: "SplitLineRequest/Response with id field and empty string validation"
      contains: "id: str | None"
  key_links:
    - from: "src/adapters/api/app.py"
      to: "ValueError"
      via: "exception_handler decorator"
      pattern: "@app.exception_handler\\(ValueError\\)"
    - from: "src/adapters/persistence/repositories/transaction.py"
      to: "split_lines table"
      via: "split_id column"
      pattern: "split_id"
---

<objective>
Add database migration for split identity columns, update persistence layer to handle split IDs, add ValueError exception handler for proper 400 responses, and add Pydantic validation for empty strings.

Purpose: Complete the persistence and API layers for split identity, enable proper error responses for invalid IDs.

Output: Migration file, updated repositories, updated schemas, exception handler in app.py.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03.1-split-identity-validation-fixes/03.1-CONTEXT.md
@.planning/phases/03.1-split-identity-validation-fixes/03.1-RESEARCH.md
@.planning/phases/03.1-split-identity-validation-fixes/03.1-01-SUMMARY.md
@src/adapters/persistence/orm/tables.py
@src/adapters/persistence/repositories/transaction.py
@src/adapters/api/schemas/transaction.py
@src/adapters/api/app.py
@alembic/versions/003_add_transaction_tables.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create database migration and update tables</name>
  <files>
    alembic/versions/004_add_split_identity.py
    src/adapters/persistence/orm/tables.py
  </files>
  <action>
1. Create migration file alembic/versions/004_add_split_identity.py:

```python
"""Add split identity and category type.

Phase 3.1: Split Identity & Validation Fixes

This migration adds:
- split_id column to split_lines (TypeID for split identity)
- source_split_id column to transactions (links mirrors to source splits)
- category_type column to categories (income/expense classification)

Three-step approach for split_id:
1. Add column as nullable
2. Backfill existing splits with generated IDs
3. Alter to NOT NULL

Revision ID: 004
Revises: 003
Create Date: 2026-02-02
"""

from typing import Sequence, Union

import sqlalchemy as sa
from alembic import op
from typeid import TypeID

revision: str = "004"
down_revision: Union[str, None] = "003"
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # 1. Add split_id column to split_lines (nullable first)
    op.add_column(
        "split_lines",
        sa.Column("split_id", sa.String(36), nullable=True),
    )

    # 2. Backfill existing splits with generated IDs
    conn = op.get_bind()
    result = conn.execute(sa.text("SELECT id FROM split_lines WHERE split_id IS NULL"))
    for row in result:
        split_id = str(TypeID(prefix="split"))
        conn.execute(
            sa.text("UPDATE split_lines SET split_id = :split_id WHERE id = :id"),
            {"split_id": split_id, "id": row[0]},
        )

    # 3. Make split_id NOT NULL and add unique index
    op.alter_column("split_lines", "split_id", nullable=False)
    op.create_index("ix_split_lines_split_id", "split_lines", ["split_id"], unique=True)

    # 4. Add source_split_id to transactions (nullable - only for mirrors)
    op.add_column(
        "transactions",
        sa.Column("source_split_id", sa.String(36), nullable=True),
    )
    op.create_index(
        "ix_transactions_source_split_id",
        "transactions",
        ["source_split_id"],
    )

    # 5. Add category_type to categories (with default 'expense')
    op.add_column(
        "categories",
        sa.Column(
            "category_type",
            sa.String(10),
            nullable=False,
            server_default="expense",
        ),
    )


def downgrade() -> None:
    # Drop in reverse order
    op.drop_column("categories", "category_type")

    op.drop_index("ix_transactions_source_split_id", table_name="transactions")
    op.drop_column("transactions", "source_split_id")

    op.drop_index("ix_split_lines_split_id", table_name="split_lines")
    op.drop_column("split_lines", "split_id")
```

2. Update src/adapters/persistence/orm/tables.py to add new columns to table definitions:

For split_lines table, add:
```python
sa.Column("split_id", sa.String(36), nullable=False),
```

For transactions table, add:
```python
sa.Column("source_split_id", sa.String(36), nullable=True),
```

For categories table, add:
```python
sa.Column("category_type", sa.String(10), nullable=False, server_default="expense"),
```
  </action>
  <verify>
Run migration: `cd /workspace && alembic upgrade head`
Check tables: `cd /workspace && python -c "from src.adapters.persistence.orm.tables import split_lines, transactions, categories; print('Tables loaded OK')"`
  </verify>
  <done>
- Migration 004 exists and runs successfully
- split_lines has split_id column (NOT NULL, unique index)
- transactions has source_split_id column (nullable)
- categories has category_type column (NOT NULL, default 'expense')
- Table definitions in tables.py match migration
  </done>
</task>

<task type="auto">
  <name>Task 2: Update repositories, schemas, and exception handler</name>
  <files>
    src/adapters/persistence/repositories/transaction.py
    src/adapters/persistence/repositories/category.py
    src/adapters/api/schemas/transaction.py
    src/adapters/api/schemas/category.py
    src/adapters/api/app.py
    src/application/services/transaction_service.py
  </files>
  <action>
1. Update SqlAlchemyTransactionRepository in transaction.py:

In _load_splits():
- Read split_id column from database
- Reconstruct SplitId from string
- Create SplitLine with id parameter:
```python
split = SplitLine(
    id=SplitId.from_string(row.split_id),
    amount=amount,
    category_id=category_id,
    transfer_account_id=transfer_account_id,
    memo=row.memo,
)
```

In _save_splits():
- Include split_id in insert values:
```python
insert_stmt = split_lines.insert().values(
    split_id=str(split.id),
    transaction_id=str(transaction.id),
    # ... rest of values
)
```

In _reconstruct_value_objects():
- Add reconstruction for source_split_id:
```python
if txn.source_split_id is not None and isinstance(txn.source_split_id, str):
    object.__setattr__(txn, "source_split_id", SplitId.from_string(txn.source_split_id))
```

In add():
- Include source_split_id in insert values:
```python
source_split_id=str(transaction.source_split_id) if transaction.source_split_id else None,
```

2. Update SqlAlchemyCategoryRepository in category.py:

In _hydrate() or equivalent:
- Read category_type from database
- Convert string to CategoryType enum

In add() and update():
- Include category_type in insert/update values

3. Update transaction.py schemas:

Add id field to SplitLineRequest (optional for create, required for update):
```python
class SplitLineRequest(BaseModel):
    id: str | None = Field(default=None, description="Split ID (omit for new splits)")
    amount: MoneySchema
    category_id: str | None = Field(default=None)
    transfer_account_id: str | None = Field(default=None)
    memo: str | None = Field(default=None, max_length=500)

    @field_validator('category_id', mode='before')
    @classmethod
    def validate_category_id(cls, v: str | None) -> str | None:
        if v == "":
            raise ValueError("category_id cannot be empty string")
        return v if v else None

    @field_validator('transfer_account_id', mode='before')
    @classmethod
    def validate_transfer_account_id(cls, v: str | None) -> str | None:
        if v == "":
            raise ValueError("transfer_account_id cannot be empty string")
        return v if v else None
```

Add id field to SplitLineResponse:
```python
class SplitLineResponse(BaseModel):
    id: str  # Always present in response
    amount: MoneySchema
    category_id: str | None
    transfer_account_id: str | None
    memo: str | None
```

4. Update category.py schemas:

Add category_type to CategoryResponse:
```python
category_type: str  # "income" or "expense"
```

Add category_type to CreateCategoryRequest (optional, defaults to expense):
```python
category_type: str = Field(default="expense", pattern="^(income|expense)$")
```

5. Add ValueError exception handler to app.py:

After the lifespan function, add:
```python
from fastapi import Request
from fastapi.responses import JSONResponse

# Inside create_app(), after creating the app instance:
@app.exception_handler(ValueError)
async def value_error_handler(request: Request, exc: ValueError) -> JSONResponse:
    """Convert ValueError to 400 Bad Request.

    Handles:
    - TypeID parsing failures (invalid format, wrong prefix)
    - Domain validation errors (invalid split configuration)
    - Empty string validation errors
    """
    return JSONResponse(
        status_code=400,
        content={
            "detail": {
                "code": "VALIDATION_ERROR",
                "message": str(exc),
            }
        },
    )
```

6. Update TransactionService._sync_mirrors_for_split_update() in transaction_service.py:
- When creating new mirrors, pass source_split to Transaction.create_mirror()
- When finding mirrors to update/delete, use source_split_id for matching (not just account_id)
  </action>
  <verify>
Run all tests: `cd /workspace && python -m pytest tests/ -v --tb=short`
Test exception handler: `cd /workspace && python -c "
from fastapi.testclient import TestClient
from src.adapters.api.app import app
client = TestClient(app)
# This should trigger ValueError from invalid TypeID
response = client.post('/api/v1/transactions', json={
    'account_id': 'invalid',
    'effective_date': '2026-01-01',
    'amount': {'amount': '100.00', 'currency': 'USD'},
    'splits': [{'amount': {'amount': '100.00', 'currency': 'USD'}}]
})
print(f'Status: {response.status_code}')
assert response.status_code == 400, f'Expected 400, got {response.status_code}'
print('OK - ValueError returns 400')
"`
  </verify>
  <done>
- Repository loads and saves split_id correctly
- Repository handles source_split_id for mirrors
- Category repository handles category_type
- Schemas include id field for splits
- Empty string validation returns 400
- ValueError exception handler returns 400 with structured error
- All tests pass
  </done>
</task>

</tasks>

<verification>
1. Run migration: `alembic upgrade head`
2. All tests pass: `python -m pytest tests/ -v`
3. Invalid ID returns 400: Test with invalid TypeID format
4. Empty string returns 400: Test with category_id: ""
5. Split IDs persist: Create transaction, reload, verify split IDs match
</verification>

<success_criteria>
- Migration 004 runs without errors (including backfill)
- split_lines.split_id column is NOT NULL with unique index
- transactions.source_split_id column exists
- categories.category_type column exists with default 'expense'
- Repository correctly loads/saves split IDs
- ValueError converts to 400 response (not 500)
- Empty string validation triggers 400 response
- All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/03.1-split-identity-validation-fixes/03.1-02-SUMMARY.md`
</output>
