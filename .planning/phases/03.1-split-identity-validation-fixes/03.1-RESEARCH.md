# Phase 3.1: Split Identity & Validation Fixes - Research

**Researched:** 2026-02-02
**Domain:** Python dataclass patterns, SQLAlchemy migrations, Pydantic validation, FastAPI error handling
**Confidence:** HIGH

## Summary

This phase addresses four UAT issues from Phase 3 that require targeted fixes to the existing transaction domain:

1. **Invalid IDs return 500 instead of 400** - ValueError from TypeID parsing bubbles up as Internal Server Error
2. **Empty string category_id accepted** - Creates splits with null for both category_id and transfer_account_id
3. **Categories lack income/expense type** - No way to indicate default transaction direction
4. **Split-to-mirror linkage unclear** - When updating transfers with multiple splits to same account, unclear which mirror corresponds to which split

The most significant change is transforming SplitLine from a value object (frozen dataclass, no identity) to an entity (has ID, can be referenced). This enables PATCH semantics where clients specify which split to update by ID.

The existing codebase already follows clean architecture patterns with TypeID-based entity IDs, SQLAlchemy imperative mapping, and Pydantic v2 schemas. The fixes can leverage these established patterns without introducing new dependencies.

**Primary recommendation:** Add SplitId to SplitLine entity, add source_split_id to Transaction for mirror linkage, add CategoryType enum to Category, and add ValueError exception handler to FastAPI for proper 400 responses.

## Standard Stack

The established libraries/tools for this domain (already in use):

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| typeid-python | 0.3.0+ | TypeID entity identifiers | Already used for all entity IDs (acct_, txn_, cat_, user_, payee_) |
| SQLAlchemy | 2.0.36+ | ORM with imperative mapping | Already used for all persistence |
| Alembic | 1.14.0+ | Database migrations | Already used for schema changes |
| Pydantic | 2.10.0+ | API request/response schemas | Already used for all API schemas |
| FastAPI | 0.115.0+ | REST API framework | Already used for all endpoints |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| dataclasses | stdlib | Domain entities | Already used for all domain models |
| StrEnum | stdlib | Type-safe string enums | Already used for TransactionStatus, TransactionSource |

### No New Dependencies Required
This phase does not require any new libraries. All fixes use existing patterns.

## Architecture Patterns

### Pattern 1: Value Object to Entity Transformation

**What:** Converting SplitLine from frozen value object to entity with identity
**When to use:** When a domain object needs to be referenced/updated independently

**Current (Value Object):**
```python
# Source: /workspace/src/domain/model/split_line.py
@dataclass(frozen=True, slots=True)
class SplitLine:
    amount: Money
    category_id: CategoryId | None = None
    transfer_account_id: AccountId | None = None
    memo: str | None = None
```

**New (Entity with ID):**
```python
@dataclass(frozen=True, slots=True)
class SplitLine:
    id: SplitId  # NEW - required, server-generated
    amount: Money
    category_id: CategoryId | None = None
    transfer_account_id: AccountId | None = None
    memo: str | None = None

    @classmethod
    def create(
        cls,
        amount: Money,
        category_id: CategoryId | None = None,
        transfer_account_id: AccountId | None = None,
        memo: str | None = None,
    ) -> Self:
        """Factory method that generates ID."""
        return cls(
            id=SplitId.generate(),
            amount=amount,
            category_id=category_id,
            transfer_account_id=transfer_account_id,
            memo=memo,
        )
```

**Key insight:** Keep SplitLine frozen even as entity. The ID provides identity; updates create new instances with same ID.

### Pattern 2: TypeID Creation for New Entity Type

**What:** Adding SplitId following existing TypeID patterns
**When to use:** Any new entity type needs its own prefixed ID

**Example (following existing pattern in entity_id.py):**
```python
@dataclass(frozen=True, slots=True)
class SplitId:
    """Identifier for SplitLine entity.

    Format: split_01h455vb4pex5vsknk084sn02q
    """

    value: str

    @classmethod
    def generate(cls) -> Self:
        """Generate a new SplitId."""
        tid = TypeID(prefix="split")
        return cls(value=str(tid))

    @classmethod
    def from_string(cls, value: str) -> Self:
        """Parse and validate a SplitId from string."""
        tid = TypeID.from_string(value)
        if tid.prefix != "split":
            raise ValueError(f"Expected 'split' prefix, got '{tid.prefix}'")
        return cls(value=value)

    @property
    def prefix(self) -> str:
        return "split"

    def __str__(self) -> str:
        return self.value
```

### Pattern 3: Three-Step Migration for Non-Nullable Column

**What:** Adding NOT NULL column to existing table with data
**When to use:** When adding required columns to tables with existing rows

**Step 1:** Add column as nullable
```python
def upgrade() -> None:
    # Add new column as nullable first
    op.add_column('split_lines', sa.Column('split_id', sa.String(36), nullable=True))
```

**Step 2:** Backfill existing data
```python
    # Backfill existing splits with generated IDs
    from typeid import TypeID

    conn = op.get_bind()
    result = conn.execute(sa.text("SELECT id FROM split_lines WHERE split_id IS NULL"))
    for row in result:
        new_id = str(TypeID(prefix="split"))
        conn.execute(
            sa.text("UPDATE split_lines SET split_id = :split_id WHERE id = :id"),
            {"split_id": new_id, "id": row.id}
        )
```

**Step 3:** Alter to NOT NULL
```python
    # Now make it non-nullable
    op.alter_column('split_lines', 'split_id', nullable=False)
```

### Pattern 4: FastAPI ValueError Exception Handler

**What:** Converting ValueError to 400 Bad Request instead of 500 Internal Server Error
**When to use:** When domain/validation code raises ValueError for invalid input

**Example (in app.py or separate exception_handlers.py):**
```python
from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse

app = FastAPI()

@app.exception_handler(ValueError)
async def value_error_handler(request: Request, exc: ValueError):
    """Convert ValueError to 400 Bad Request with structured error."""
    return JSONResponse(
        status_code=400,
        content={
            "detail": {
                "code": "VALIDATION_ERROR",
                "message": str(exc),
            }
        },
    )
```

### Pattern 5: Pydantic Field Validator for ID Format

**What:** Validating ID strings have correct TypeID format before processing
**When to use:** API endpoints that accept entity IDs in request body

**Example:**
```python
from pydantic import BaseModel, field_validator

class SplitLineRequest(BaseModel):
    id: str | None = None  # Optional for create, required for update
    amount: MoneySchema
    category_id: str | None = None
    transfer_account_id: str | None = None
    memo: str | None = None

    @field_validator('id', mode='before')
    @classmethod
    def validate_split_id(cls, v: str | None) -> str | None:
        if v is None:
            return None
        if v == "":
            raise ValueError("Split ID cannot be empty string")
        # TypeID validation happens in domain layer
        return v

    @field_validator('category_id', mode='before')
    @classmethod
    def validate_category_id(cls, v: str | None) -> str | None:
        if v == "":
            raise ValueError("Category ID cannot be empty string")
        return v if v else None

    @field_validator('transfer_account_id', mode='before')
    @classmethod
    def validate_transfer_account_id(cls, v: str | None) -> str | None:
        if v == "":
            raise ValueError("Transfer account ID cannot be empty string")
        return v if v else None
```

### Pattern 6: Enum Addition to Existing Entity

**What:** Adding CategoryType enum to Category entity
**When to use:** When enhancing entity with new classification

**Example:**
```python
class CategoryType(StrEnum):
    """Category type for default transaction direction."""
    INCOME = auto()
    EXPENSE = auto()

@dataclass(eq=False)
class Category:
    id: CategoryId
    user_id: UserId
    name: str
    category_type: CategoryType  # NEW
    parent_id: CategoryId | None = None
    # ... rest of existing fields
```

### Recommended Project Structure (no changes)

The existing structure supports these changes:
```
src/
├── domain/
│   └── model/
│       ├── entity_id.py      # Add SplitId
│       ├── split_line.py     # Add id field, validation
│       ├── transaction.py    # Add source_split_id
│       └── category.py       # Add category_type
├── adapters/
│   ├── api/
│   │   ├── app.py           # Add ValueError handler
│   │   └── schemas/
│   │       └── transaction.py  # Add id to SplitLineRequest/Response
│   └── persistence/
│       └── orm/
│           └── tables.py     # Add columns
└── application/
    └── services/
        └── transaction_service.py  # Update PATCH logic
```

### Anti-Patterns to Avoid

- **Mutable entity with identity:** SplitLine should remain frozen. Updates create new instances.
- **ID assignment in constructor:** Use factory method to generate ID, keeping constructor explicit.
- **Catching all exceptions as 400:** Only ValueError should become 400; let other exceptions remain 500.
- **Backfill in separate migration:** ID generation and schema change should be atomic in same migration.

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| UUID generation | Random UUIDs | TypeID with prefix | Existing pattern, time-sortable, type-safe |
| ID validation | Regex matching | TypeID.from_string() | Handles all edge cases, consistent with codebase |
| Enum serialization | String constants | StrEnum with auto() | JSON-friendly, type-safe, matches existing code |
| Exception conversion | Custom middleware | @app.exception_handler | FastAPI standard pattern |
| Migration data updates | ORM operations | Raw SQL in migration | Avoid model coupling, idempotent |

**Key insight:** All fixes use established patterns from the existing codebase. No new architectural decisions required.

## Common Pitfalls

### Pitfall 1: Breaking API Contract with Split IDs

**What goes wrong:** Existing API clients don't send split IDs, causing validation failures
**Why it happens:** Making id required in request schema
**How to avoid:**
- id is optional in SplitLineRequest (omit for create, include for update)
- Server generates ID when not provided
- Always include ID in SplitLineResponse
**Warning signs:** 400 errors from existing working clients

### Pitfall 2: Orphaned Mirrors After Split Update

**What goes wrong:** Changing transfer_account_id leaves old mirror orphaned
**Why it happens:** Not tracking which mirror corresponds to which split
**How to avoid:**
- Add source_split_id to Transaction (mirrors only)
- Delete old mirror by source_split_id match, create new mirror with new link
**Warning signs:** Multiple mirrors for same source, incorrect balances

### Pitfall 3: Migration Failure on Existing Data

**What goes wrong:** Adding NOT NULL column fails because existing rows have NULL
**Why it happens:** Single-step migration without backfill
**How to avoid:**
- Three-step: nullable column -> backfill -> NOT NULL
- Generate TypeID values in migration script
- Test migration against database with existing data
**Warning signs:** Migration error "column cannot be null"

### Pitfall 4: Empty String vs None Confusion

**What goes wrong:** Empty string `""` passes validation but causes domain errors
**Why it happens:** Pydantic treats empty string as truthy value
**How to avoid:**
- Add field_validator that rejects empty strings
- Convert empty strings to None explicitly if that's valid
- Validate in schema layer before hitting domain
**Warning signs:** Splits with both category_id and transfer_account_id as None

### Pitfall 5: Concurrent Split Updates Race Condition

**What goes wrong:** Two concurrent PATCH requests modify same split inconsistently
**Why it happens:** No optimistic locking on split updates
**How to avoid:**
- Use transaction-level locking (existing UoW pattern)
- Consider adding version field if frequent conflicts expected
- Validate split IDs exist on transaction before processing
**Warning signs:** Lost updates, incorrect split amounts

## Code Examples

### Example 1: SplitId Entity ID (following existing pattern)

```python
# Source: Follow pattern from /workspace/src/domain/model/entity_id.py
@dataclass(frozen=True, slots=True)
class SplitId:
    """Identifier for SplitLine entity.

    Format: split_01h455vb4pex5vsknk084sn02q
    """

    value: str

    @classmethod
    def generate(cls) -> Self:
        """Generate a new SplitId."""
        tid = TypeID(prefix="split")
        return cls(value=str(tid))

    @classmethod
    def from_string(cls, value: str) -> Self:
        """Parse and validate a SplitId from string.

        Raises:
            ValueError: If ID format is invalid or prefix doesn't match.
        """
        tid = TypeID.from_string(value)
        if tid.prefix != "split":
            raise ValueError(f"Expected 'split' prefix, got '{tid.prefix}'")
        return cls(value=value)

    @property
    def prefix(self) -> str:
        return "split"

    def __str__(self) -> str:
        return self.value
```

### Example 2: Updated SplitLine with ID and Validation

```python
# Source: Modify /workspace/src/domain/model/split_line.py
@dataclass(frozen=True, slots=True)
class SplitLine:
    """A single line in a split transaction - now with identity.

    Per CONTEXT.md: Split must have exactly one of category_id or
    transfer_account_id (V2, V3, V11 validation rules).
    """

    id: SplitId
    amount: Money
    category_id: CategoryId | None = None
    transfer_account_id: AccountId | None = None
    memo: str | None = None

    def __post_init__(self) -> None:
        """Validate split line constraints."""
        # V3: Cannot have both category and transfer
        if self.category_id is not None and self.transfer_account_id is not None:
            raise ValueError("Split cannot have both category and transfer account")

        # V2: Must have at least one (unless uncategorized is allowed)
        # Note: Uncategorized splits ARE allowed per existing behavior

        # V7: Transfer splits must be negative
        if self.transfer_account_id is not None and not self.amount.is_negative():
            raise ValueError("Transfer split amount must be negative (outgoing)")

    @classmethod
    def create(
        cls,
        amount: Money,
        category_id: CategoryId | None = None,
        transfer_account_id: AccountId | None = None,
        memo: str | None = None,
    ) -> Self:
        """Factory method that generates ID."""
        return cls(
            id=SplitId.generate(),
            amount=amount,
            category_id=category_id,
            transfer_account_id=transfer_account_id,
            memo=memo,
        )
```

### Example 3: CategoryType Enum and Updated Category

```python
# Source: Modify /workspace/src/domain/model/category.py
class CategoryType(StrEnum):
    """Category type for default transaction direction.

    INCOME: Categories for money coming in (salary, interest, etc.)
    EXPENSE: Categories for money going out (food, utilities, etc.)
    """
    INCOME = auto()
    EXPENSE = auto()

@dataclass(eq=False)
class Category:
    # ... existing fields ...
    category_type: CategoryType = CategoryType.EXPENSE  # Default to expense
```

### Example 4: ValueError Exception Handler

```python
# Source: Add to /workspace/src/adapters/api/app.py
from fastapi import Request
from fastapi.responses import JSONResponse

@app.exception_handler(ValueError)
async def value_error_handler(request: Request, exc: ValueError) -> JSONResponse:
    """Convert ValueError to 400 Bad Request.

    Handles:
    - TypeID parsing failures (invalid format, wrong prefix)
    - Domain validation errors (invalid split configuration)
    """
    return JSONResponse(
        status_code=400,
        content={
            "detail": {
                "code": "VALIDATION_ERROR",
                "message": str(exc),
            }
        },
    )
```

### Example 5: Updated Transaction with source_split_id

```python
# Source: Modify /workspace/src/domain/model/transaction.py
@dataclass(eq=False)
class Transaction:
    # ... existing fields ...

    # Mirror transaction link - now includes split reference
    source_transaction_id: TransactionId | None = None  # Existing
    source_split_id: SplitId | None = None  # NEW - which split created this mirror
    is_mirror: bool = False
```

### Example 6: Migration with Backfill

```python
# Source: New migration file
"""Add split identity and category type.

Revision ID: 004
Revises: 003
"""

def upgrade() -> None:
    # 1. Add split_id column (nullable first)
    op.add_column(
        'split_lines',
        sa.Column('split_id', sa.String(36), nullable=True)
    )

    # 2. Backfill existing splits with generated IDs
    from typeid import TypeID
    conn = op.get_bind()
    result = conn.execute(sa.text("SELECT id FROM split_lines WHERE split_id IS NULL"))
    for row in result:
        split_id = str(TypeID(prefix="split"))
        conn.execute(
            sa.text("UPDATE split_lines SET split_id = :split_id WHERE id = :id"),
            {"split_id": split_id, "id": row.id}
        )

    # 3. Make split_id NOT NULL
    op.alter_column('split_lines', 'split_id', nullable=False)

    # 4. Add source_split_id to transactions (nullable - only for mirrors)
    op.add_column(
        'transactions',
        sa.Column('source_split_id', sa.String(36), nullable=True)
    )

    # 5. Add category_type to categories (with default)
    op.add_column(
        'categories',
        sa.Column('category_type', sa.String(10), nullable=False, server_default='expense')
    )

    # 6. Create indexes
    op.create_index('ix_split_lines_split_id', 'split_lines', ['split_id'], unique=True)
    op.create_index('ix_transactions_source_split_id', 'transactions', ['source_split_id'])
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| SplitLine as value object | SplitLine with TypeID identity | This phase | Enables PATCH by split ID |
| Match mirrors by account_id | Match mirrors by source_split_id | This phase | Handles multiple splits to same account |
| ValueError -> 500 error | ValueError -> 400 via handler | This phase | Proper client error responses |
| Category without type | Category with income/expense type | This phase | Enables default direction hints |

**Not deprecated:**
- Frozen dataclass pattern (still used, even for entity)
- TypeID for all entity IDs (extended to SplitId)
- Imperative SQLAlchemy mapping (unchanged)

## Open Questions

### 1. Uncategorized Splits Allowed?

**What we know:** Current code allows splits with neither category_id nor transfer_account_id (uncategorized)
**What's unclear:** Should V2 validation require exactly one, or allow neither for "uncategorized"?
**Recommendation:** Keep current behavior (allow neither) - this matches YNAB and common patterns. User can categorize later.

### 2. Backfill Mirror source_split_id

**What we know:** Existing mirrors have source_transaction_id but not source_split_id
**What's unclear:** How to backfill source_split_id for existing mirrors?
**Recommendation:** For existing data:
- If source transaction has only one transfer split, link is unambiguous
- If multiple transfer splits to same account with same amount, assign arbitrarily
- Flag in migration comments that manual review may be needed for edge cases

### 3. Category Type for System Categories

**What we know:** System category "Uncategorized" exists
**What's unclear:** What category_type should system categories have?
**Recommendation:** Set to EXPENSE as default (most common). System categories are meta-categories and type matters less.

## Sources

### Primary (HIGH confidence)
- [Cosmic Python - Domain Modeling](https://www.cosmicpython.com/book/chapter_01_domain_model.html) - Entity vs value object patterns
- [FastAPI - Handling Errors](https://fastapi.tiangolo.com/tutorial/handling-errors/) - Exception handler pattern
- [Alembic Cookbook](https://alembic.sqlalchemy.org/en/latest/cookbook.html) - Data migration patterns
- [Pydantic Validators](https://docs.pydantic.dev/latest/concepts/validators/) - Field validator syntax
- Existing codebase at /workspace/src - All patterns verified against implementation

### Secondary (MEDIUM confidence)
- [DDD in Python - Entities](https://dddinpython.com/index.php/2022/07/22/entities/) - Entity implementation guidance
- [Alembic Best Practices](https://dev.to/welel/best-practices-for-alembic-and-sqlalchemy-3b34) - Migration three-step pattern
- [Better Stack - FastAPI Error Handling](https://betterstack.com/community/guides/scaling-python/error-handling-fastapi/) - Exception categorization

### Tertiary (LOW confidence)
- None - all findings verified with official docs or codebase

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - All libraries already in use, no new dependencies
- Architecture: HIGH - All patterns follow existing codebase conventions
- Pitfalls: HIGH - Based on analysis of existing code and UAT failures
- Migration: MEDIUM - Backfill logic for existing mirrors may need refinement

**Research date:** 2026-02-02
**Valid until:** 2026-03-02 (30 days - stable patterns, internal codebase)
