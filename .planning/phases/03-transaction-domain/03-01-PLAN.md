---
phase: 03-transaction-domain
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/domain/model/transaction_types.py
  - src/domain/model/split_line.py
  - src/domain/model/payee.py
  - src/domain/model/entity_id.py
  - src/domain/events/transaction_events.py
autonomous: true

must_haves:
  truths:
    - "TransactionStatus enum has PENDING, CLEARED, RECONCILED values"
    - "SplitLine value object enforces signed amounts and validates splits sum to total"
    - "PayeeId and Payee entity support auto-creation pattern"
    - "Domain events capture transaction lifecycle changes"
  artifacts:
    - path: "src/domain/model/transaction_types.py"
      provides: "TransactionStatus, TransactionSource enums"
      contains: "class TransactionStatus"
    - path: "src/domain/model/split_line.py"
      provides: "SplitLine value object with signed amounts"
      contains: "class SplitLine"
    - path: "src/domain/model/payee.py"
      provides: "Payee entity for managed payee list"
      contains: "class Payee"
    - path: "src/domain/model/entity_id.py"
      provides: "PayeeId added to entity IDs"
      contains: "class PayeeId"
    - path: "src/domain/events/transaction_events.py"
      provides: "Transaction domain events"
      contains: "TransactionCreated"
  key_links:
    - from: "src/domain/model/split_line.py"
      to: "src/domain/model/money.py"
      via: "Money value object import"
      pattern: "from.*money import Money"
    - from: "src/domain/model/split_line.py"
      to: "src/domain/model/entity_id.py"
      via: "CategoryId, AccountId imports"
      pattern: "from.*entity_id import"
---

<objective>
Create Transaction domain primitives including enums, value objects, and events following the CONTEXT decisions for Phase 3.

Purpose: Establish the foundational types that Transaction aggregate and related entities will use. These primitives must reflect the always-split model (every transaction has 1+ splits) and the transfer mirror pattern.

Output: Domain primitives ready for Transaction aggregate implementation in Plan 02.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-transaction-domain/03-CONTEXT.md

# Existing domain patterns to follow
@src/domain/model/entity_id.py
@src/domain/model/account_types.py
@src/domain/model/money.py
@src/domain/events/base.py
@src/domain/events/account_events.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create transaction type enums and SplitLine value object</name>
  <files>
    src/domain/model/transaction_types.py
    src/domain/model/split_line.py
  </files>
  <action>
Create transaction_types.py with StrEnum classes following account_types.py pattern:

1. **TransactionStatus** (status progression per CONTEXT):
   - PENDING = auto() - default for new transactions
   - CLEARED = auto() - cleared/posted to account
   - RECONCILED = auto() - verified against bank statement

2. **TransactionSource** (for Phase 6 foundation per CONTEXT):
   - MANUAL = auto() - user-entered transactions
   - DOWNLOADED = auto() - imported from bank sync

Create split_line.py with SplitLine frozen dataclass:

```python
@dataclass(frozen=True, slots=True)
class SplitLine:
    """A single line in a split transaction.

    Per CONTEXT: Split amounts are SIGNED (positive = inflow, negative = outflow).
    Each split targets either a category OR a transfer account (not both).
    Transfer splits must be negative (outgoing from source account).
    """
    amount: Money  # SIGNED amount (positive/negative)
    category_id: CategoryId | None = None  # For expense/income splits
    transfer_account_id: AccountId | None = None  # For transfer splits
    memo: str | None = None  # Per-split memo

    def __post_init__(self) -> None:
        # Validate: must have either category OR transfer account (or neither for uncategorized)
        if self.category_id is not None and self.transfer_account_id is not None:
            raise ValueError("Split cannot have both category and transfer account")
        # Transfer splits must be negative (outgoing)
        if self.transfer_account_id is not None and not self.amount.is_negative():
            raise ValueError("Transfer split amount must be negative (outgoing)")

    @property
    def is_transfer(self) -> bool:
        return self.transfer_account_id is not None
```

Key design points:
- Frozen dataclass with slots (immutable value object)
- Signed amounts per CONTEXT (not always positive like research suggested)
- Transfer splits target an account, not a category
- memo is per-split as specified in CONTEXT
  </action>
  <verify>
```bash
cd /workspace && python -c "
from src.domain.model.transaction_types import TransactionStatus, TransactionSource
from src.domain.model.split_line import SplitLine
from src.domain.model.money import Money
from src.domain.model.entity_id import CategoryId, AccountId
from decimal import Decimal

# Verify enums
assert TransactionStatus.PENDING.value == 'pending'
assert TransactionStatus.CLEARED.value == 'cleared'
assert TransactionStatus.RECONCILED.value == 'reconciled'
assert TransactionSource.MANUAL.value == 'manual'
assert TransactionSource.DOWNLOADED.value == 'downloaded'

# Verify SplitLine with expense (negative)
expense = SplitLine(
    amount=Money(Decimal('-50.00'), 'USD'),
    category_id=CategoryId.generate()
)
assert expense.amount.is_negative()
assert not expense.is_transfer

# Verify transfer split (must be negative)
transfer = SplitLine(
    amount=Money(Decimal('-100.00'), 'USD'),
    transfer_account_id=AccountId.generate()
)
assert transfer.is_transfer
assert transfer.amount.is_negative()

# Verify positive transfer fails
try:
    bad = SplitLine(
        amount=Money(Decimal('100.00'), 'USD'),
        transfer_account_id=AccountId.generate()
    )
    assert False, 'Should have raised ValueError'
except ValueError as e:
    assert 'negative' in str(e).lower()

print('All verifications passed!')
"
```
  </verify>
  <done>
TransactionStatus enum has PENDING/CLEARED/RECONCILED values. SplitLine value object validates signed amounts and transfer splits correctly. Transfer splits must be negative.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create PayeeId and Payee entity</name>
  <files>
    src/domain/model/entity_id.py
    src/domain/model/payee.py
  </files>
  <action>
Add PayeeId to entity_id.py following the existing pattern (AccountId, TransactionId, etc.):

```python
@dataclass(frozen=True, slots=True)
class PayeeId:
    """Identifier for Payee entity.

    Format: payee_01h455vb4pex5vsknk084sn02q
    """
    value: str

    @classmethod
    def generate(cls) -> Self:
        tid = TypeID(prefix="payee")
        return cls(value=str(tid))

    @classmethod
    def from_string(cls, value: str) -> Self:
        tid = TypeID.from_string(value)
        if tid.prefix != "payee":
            raise ValueError(f"Expected 'payee' prefix, got '{tid.prefix}'")
        return cls(value=value)

    @property
    def prefix(self) -> str:
        return "payee"

    def __str__(self) -> str:
        return self.value
```

Create payee.py with Payee entity (per CONTEXT: managed entity list with autocomplete, auto-created when entering transactions):

```python
@dataclass(eq=False)
class Payee:
    """Managed payee entity for transaction payee autocomplete.

    Per CONTEXT:
    - Payees are a managed entity list
    - New payees auto-created when entering transactions
    - Optional: default_category_id for auto-fill (Claude's discretion)
    """
    id: PayeeId
    user_id: UserId
    name: str
    normalized_name: str  # Lowercase for matching/deduplication
    default_category_id: CategoryId | None = None  # For auto-categorization

    # Usage tracking
    last_used_at: datetime | None = None
    usage_count: int = 0

    # Audit
    created_at: datetime = field(default_factory=lambda: datetime.now(UTC))
    updated_at: datetime = field(default_factory=lambda: datetime.now(UTC))

    @classmethod
    def create(
        cls,
        user_id: UserId,
        name: str,
        default_category_id: CategoryId | None = None,
    ) -> Self:
        """Create a new payee with normalized name for matching."""
        return cls(
            id=PayeeId.generate(),
            user_id=user_id,
            name=name.strip(),
            normalized_name=name.strip().lower(),
            default_category_id=default_category_id,
        )

    def update_name(self, new_name: str) -> None:
        if not new_name or not new_name.strip():
            raise ValueError("Payee name cannot be empty")
        self.name = new_name.strip()
        self.normalized_name = new_name.strip().lower()
        self.updated_at = datetime.now(UTC)

    def record_usage(self) -> None:
        """Track that this payee was used in a transaction."""
        self.last_used_at = datetime.now(UTC)
        self.usage_count += 1
        self.updated_at = datetime.now(UTC)
```

Key design:
- normalized_name for case-insensitive matching and autocomplete
- default_category_id supports auto-categorization (Claude's discretion per CONTEXT)
- usage_count/last_used_at for sorting autocomplete by relevance
- eq=False because identity is by ID
  </action>
  <verify>
```bash
cd /workspace && python -c "
from src.domain.model.entity_id import PayeeId, UserId, CategoryId
from src.domain.model.payee import Payee

# Verify PayeeId
payee_id = PayeeId.generate()
assert payee_id.prefix == 'payee'
assert str(payee_id).startswith('payee_')

# Verify round-trip
parsed = PayeeId.from_string(str(payee_id))
assert parsed.value == payee_id.value

# Verify Payee entity
payee = Payee.create(
    user_id=UserId.generate(),
    name='  Amazon Prime  ',
    default_category_id=CategoryId.generate()
)
assert payee.name == 'Amazon Prime'
assert payee.normalized_name == 'amazon prime'
assert payee.usage_count == 0

# Verify usage tracking
payee.record_usage()
assert payee.usage_count == 1
assert payee.last_used_at is not None

print('PayeeId and Payee entity verified!')
"
```
  </verify>
  <done>
PayeeId added to entity_id.py with 'payee' prefix. Payee entity supports name normalization, default category for auto-fill, and usage tracking for autocomplete relevance.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create transaction domain events</name>
  <files>src/domain/events/transaction_events.py</files>
  <action>
Create transaction_events.py following the account_events.py pattern:

```python
"""Domain events for Transaction aggregate.

Events are emitted during transaction lifecycle and processed via the outbox pattern.
Following the established pattern from account_events.py.
"""
from dataclasses import dataclass, field
from datetime import UTC, datetime

from src.domain.events.base import DomainEvent


@dataclass(frozen=True)
class TransactionCreated(DomainEvent):
    """Emitted when a new transaction is created."""
    account_id: str = ""  # Primary account
    amount: str = ""  # Decimal as string
    currency: str = "USD"
    is_mirror: bool = False  # True for auto-created mirror transactions


@dataclass(frozen=True)
class TransactionUpdated(DomainEvent):
    """Emitted when transaction fields are modified."""
    field: str = ""
    old_value: str | None = None
    new_value: str | None = None


@dataclass(frozen=True)
class TransactionDeleted(DomainEvent):
    """Emitted when a transaction is deleted."""
    was_mirror: bool = False  # True if deleted mirror


@dataclass(frozen=True)
class TransactionStatusChanged(DomainEvent):
    """Emitted when transaction status changes (Pending -> Cleared -> Reconciled)."""
    old_status: str = ""
    new_status: str = ""


@dataclass(frozen=True)
class MirrorTransactionCreated(DomainEvent):
    """Emitted when a mirror transaction is auto-created for a transfer.

    Per CONTEXT: Source transaction owns transfer; mirror is auto-created.
    """
    source_transaction_id: str = ""
    mirror_transaction_id: str = ""
    target_account_id: str = ""


@dataclass(frozen=True)
class MirrorTransactionDeleted(DomainEvent):
    """Emitted when a mirror transaction is deleted (transfer split removed)."""
    source_transaction_id: str = ""
    mirror_transaction_id: str = ""


@dataclass(frozen=True)
class CategoryCreated(DomainEvent):
    """Emitted when a new category is created."""
    category_name: str = ""
    parent_id: str | None = None
    is_system: bool = False


@dataclass(frozen=True)
class CategoryUpdated(DomainEvent):
    """Emitted when a category is modified."""
    field: str = ""
    old_value: str | None = None
    new_value: str | None = None


@dataclass(frozen=True)
class CategoryDeleted(DomainEvent):
    """Emitted when a category is deleted."""
    pass


@dataclass(frozen=True)
class PayeeCreated(DomainEvent):
    """Emitted when a new payee is auto-created."""
    payee_name: str = ""
```

Key design:
- All events inherit from DomainEvent base class
- Use default values for all fields (required for dataclass inheritance)
- MirrorTransactionCreated/Deleted events for transfer tracking
- Events use string IDs (serialization-friendly)
  </action>
  <verify>
```bash
cd /workspace && python -c "
from src.domain.events.transaction_events import (
    TransactionCreated,
    TransactionUpdated,
    TransactionDeleted,
    TransactionStatusChanged,
    MirrorTransactionCreated,
    MirrorTransactionDeleted,
    CategoryCreated,
    CategoryUpdated,
    CategoryDeleted,
    PayeeCreated,
)

# Verify events can be instantiated
txn_created = TransactionCreated(
    aggregate_id='txn_123',
    aggregate_type='Transaction',
    account_id='acct_456',
    amount='100.00',
    currency='USD',
    is_mirror=False
)
assert txn_created.aggregate_type == 'Transaction'
assert txn_created.is_mirror == False

mirror_created = MirrorTransactionCreated(
    aggregate_id='txn_789',
    aggregate_type='Transaction',
    source_transaction_id='txn_123',
    mirror_transaction_id='txn_789',
    target_account_id='acct_999'
)
assert mirror_created.source_transaction_id == 'txn_123'

status_changed = TransactionStatusChanged(
    aggregate_id='txn_123',
    aggregate_type='Transaction',
    old_status='pending',
    new_status='cleared'
)
assert status_changed.new_status == 'cleared'

print('All transaction events verified!')
"
```
  </verify>
  <done>
Transaction domain events created: TransactionCreated, TransactionUpdated, TransactionDeleted, TransactionStatusChanged, MirrorTransactionCreated, MirrorTransactionDeleted, CategoryCreated, CategoryUpdated, CategoryDeleted, PayeeCreated. All follow established event patterns.
  </done>
</task>

</tasks>

<verification>
Run import-linter to verify domain layer independence:

```bash
cd /workspace && lint-imports
```

Run pytest for any existing domain tests:

```bash
cd /workspace && pytest tests/unit/domain/ -v --tb=short 2>/dev/null || echo "No existing domain tests yet"
```
</verification>

<success_criteria>
1. TransactionStatus enum has PENDING, CLEARED, RECONCILED values
2. TransactionSource enum has MANUAL, DOWNLOADED values
3. SplitLine value object validates signed amounts correctly
4. SplitLine transfer splits must be negative
5. PayeeId follows existing EntityId pattern
6. Payee entity has name normalization and usage tracking
7. All transaction events follow DomainEvent pattern
8. Domain layer has no infrastructure imports (lint-imports passes)
</success_criteria>

<output>
After completion, create `.planning/phases/03-transaction-domain/03-01-SUMMARY.md`
</output>
