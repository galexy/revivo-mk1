---
phase: 03-transaction-domain
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/domain/model/transaction_types.py
  - src/domain/model/split_line.py
  - src/domain/model/attachment.py
  - src/domain/model/entity_id.py
  - src/domain/events/transaction_events.py
autonomous: true

must_haves:
  truths:
    - "TransactionType enum has EXPENSE, INCOME, TRANSFER values"
    - "TransactionStatus enum has PENDING, CLEARED, VOID values"
    - "SplitLine is immutable value object with amount validation"
    - "AttachmentId follows TypeID pattern with 'att' prefix"
  artifacts:
    - path: "src/domain/model/transaction_types.py"
      provides: "TransactionType and TransactionStatus enums"
      contains: "class TransactionType(StrEnum)"
    - path: "src/domain/model/split_line.py"
      provides: "SplitLine value object for split transactions"
      contains: "class SplitLine"
    - path: "src/domain/model/attachment.py"
      provides: "Attachment entity and AttachmentId"
      contains: "class Attachment"
    - path: "src/domain/events/transaction_events.py"
      provides: "Domain events for transactions"
      contains: "class TransactionCreated"
  key_links:
    - from: "src/domain/model/split_line.py"
      to: "src/domain/model/money.py"
      via: "import Money"
      pattern: "from.*money import Money"
    - from: "src/domain/model/attachment.py"
      to: "src/domain/model/entity_id.py"
      via: "import TransactionId"
      pattern: "from.*entity_id import.*TransactionId"
---

<objective>
Create Transaction domain primitives: enums, value objects, and supporting types

Purpose: Establish the foundational types that Transaction aggregate will compose. These are the building blocks: transaction types (expense/income/transfer), status lifecycle, split line allocations, and attachment metadata.

Output: Domain model primitives ready for Transaction aggregate composition
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-transaction-domain/03-RESEARCH.md

@src/domain/model/entity_id.py
@src/domain/model/money.py
@src/domain/events/base.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create transaction type enumerations</name>
  <files>src/domain/model/transaction_types.py</files>
  <action>
Create transaction_types.py with two StrEnum classes following the pattern from account_types.py:

1. TransactionType(StrEnum):
   - EXPENSE = auto()  # Money out of account
   - INCOME = auto()   # Money into account
   - TRANSFER = auto() # Between two accounts

2. TransactionStatus(StrEnum):
   - PENDING = auto()  # Not yet cleared
   - CLEARED = auto()  # Reconciled with bank
   - VOID = auto()     # Cancelled/reversed

Use StrEnum with auto() for JSON-friendly string values that match how we model AccountType and AccountStatus. Include docstrings explaining each value's purpose.
  </action>
  <verify>
Run: `python -c "from src.domain.model.transaction_types import TransactionType, TransactionStatus; print(TransactionType.EXPENSE, TransactionStatus.PENDING)"`
Expected: `expense pending`
  </verify>
  <done>TransactionType and TransactionStatus enums exist with expected values</done>
</task>

<task type="auto">
  <name>Task 2: Create SplitLine value object and Attachment entity</name>
  <files>
src/domain/model/split_line.py
src/domain/model/attachment.py
src/domain/model/entity_id.py
  </files>
  <action>
Create split_line.py:
- Frozen dataclass with slots for SplitLine
- Fields: amount (Money), category_id (CategoryId | None), memo (str | None)
- __post_init__ validation: amount must be positive (not negative, not zero)
- Import Money from src.domain.model.money
- Import CategoryId from src.domain.model.entity_id

Create attachment.py:
- Add AttachmentId class to entity_id.py first (following existing pattern):
  - Prefix: "att"
  - generate() and from_string() class methods
  - __str__ returns value
- Create Attachment entity (dataclass with eq=False):
  - Fields: id (AttachmentId), transaction_id (TransactionId), user_id (UserId)
  - File metadata: filename, storage_path, content_type, size_bytes
  - Audit: created_at (datetime with UTC default)
  - Factory method: create() that generates new AttachmentId

Follow existing entity_id.py patterns exactly for AttachmentId. Keep Attachment simple - it stores metadata only, actual files are on filesystem.
  </action>
  <verify>
Run: `python -c "
from src.domain.model.split_line import SplitLine
from src.domain.model.attachment import Attachment, AttachmentId
from src.domain.model.money import Money
from src.domain.model.entity_id import TransactionId, UserId, CategoryId
from decimal import Decimal

# Test SplitLine
sl = SplitLine(amount=Money(Decimal('10'), 'USD'), category_id=CategoryId.generate())
print(f'SplitLine: {sl.amount}')

# Test AttachmentId
aid = AttachmentId.generate()
print(f'AttachmentId prefix: {aid.prefix}')

# Test Attachment
att = Attachment.create(
    transaction_id=TransactionId.generate(),
    user_id=UserId.generate(),
    filename='receipt.jpg',
    storage_path='user123/abc.jpg',
    content_type='image/jpeg',
    size_bytes=1024
)
print(f'Attachment: {att.filename}')
"`
Expected output shows SplitLine amount, AttachmentId prefix is 'att', Attachment filename is 'receipt.jpg'
  </verify>
  <done>SplitLine value object and Attachment entity with AttachmentId exist and validate correctly</done>
</task>

<task type="auto">
  <name>Task 3: Create transaction domain events</name>
  <files>src/domain/events/transaction_events.py</files>
  <action>
Create transaction_events.py following the pattern from account_events.py:

1. TransactionCreated(DomainEvent):
   - transaction_type: str
   - amount: str (Decimal as string for serialization)
   - currency: str

2. TransactionUpdated(DomainEvent):
   - field: str (which field changed)
   - old_value: str | None
   - new_value: str | None

3. TransactionDeleted(DomainEvent):
   - pass (no extra fields, aggregate_id from base is sufficient)

4. AttachmentAdded(DomainEvent):
   - attachment_id: str
   - filename: str

5. AttachmentRemoved(DomainEvent):
   - attachment_id: str

All events inherit from DomainEvent (base.py) and use frozen=True dataclass. The aggregate_id and aggregate_type come from base class with default values.
  </action>
  <verify>
Run: `python -c "
from src.domain.events.transaction_events import TransactionCreated, TransactionUpdated, TransactionDeleted, AttachmentAdded
print('TransactionCreated:', TransactionCreated.__annotations__)
print('AttachmentAdded:', AttachmentAdded.__annotations__)
"`
Expected: Shows field annotations for events
  </verify>
  <done>Transaction domain events defined and importable</done>
</task>

</tasks>

<verification>
All tasks completed successfully:
1. `python -c "from src.domain.model.transaction_types import TransactionType, TransactionStatus"` - no errors
2. `python -c "from src.domain.model.split_line import SplitLine"` - no errors
3. `python -c "from src.domain.model.attachment import Attachment, AttachmentId"` - no errors
4. `python -c "from src.domain.events.transaction_events import TransactionCreated"` - no errors
5. `pytest tests/unit/domain/ -v --tb=short` - passes (if unit tests exist)
</verification>

<success_criteria>
- TransactionType enum with EXPENSE, INCOME, TRANSFER
- TransactionStatus enum with PENDING, CLEARED, VOID
- SplitLine frozen dataclass validates positive amounts
- AttachmentId follows TypeID pattern with "att" prefix
- Attachment entity has create() factory method
- Transaction domain events defined
- All imports work without circular dependencies
</success_criteria>

<output>
After completion, create `.planning/phases/03-transaction-domain/03-01-SUMMARY.md`
</output>
