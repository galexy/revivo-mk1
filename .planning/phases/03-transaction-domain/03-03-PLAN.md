---
phase: 03-transaction-domain
plan: 03
type: execute
wave: 2
depends_on: ["03-01", "03-02"]
files_modified:
  - src/adapters/persistence/orm/tables.py
  - src/adapters/persistence/orm/types.py
  - alembic/versions/003_add_transaction_tables.py
autonomous: true

must_haves:
  truths:
    - "categories table exists with parent_id for hierarchy"
    - "transactions table has search_vector column for full-text search"
    - "split_lines table has CASCADE delete on transaction_id"
    - "attachments table has CASCADE delete on transaction_id"
    - "Migration applies cleanly to database"
  artifacts:
    - path: "src/adapters/persistence/orm/tables.py"
      provides: "Transaction, category, split_lines, attachments tables"
      contains: "transactions = Table"
    - path: "alembic/versions/003_add_transaction_tables.py"
      provides: "Migration for transaction tables"
      contains: "def upgrade"
  key_links:
    - from: "alembic/versions/003_add_transaction_tables.py"
      to: "src/adapters/persistence/orm/tables.py"
      via: "table definitions"
      pattern: "CREATE TABLE.*transactions"
---

<objective>
Create database tables and migration for Transaction domain

Purpose: Establish persistence layer foundation with proper indexes, constraints, and PostgreSQL full-text search support. This follows the existing tables.py pattern and uses Alembic for migrations.

Output: Database schema ready to persist transactions, categories, split_lines, and attachments
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/03-transaction-domain/03-RESEARCH.md

@src/adapters/persistence/orm/tables.py
@src/adapters/persistence/orm/types.py
@alembic/versions/
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add custom type decorators for Transaction domain</name>
  <files>src/adapters/persistence/orm/types.py</files>
  <action>
Add to existing types.py file:

1. TransactionIdType(TypeDecorator):
   - impl = String(36)
   - process_bind_param: TransactionId -> str (txn.value)
   - process_result_value: str -> TransactionId (TransactionId.from_string)

2. CategoryIdType(TypeDecorator):
   - impl = String(36)
   - process_bind_param: CategoryId -> str (cat.value)
   - process_result_value: str -> CategoryId (CategoryId.from_string)

3. AttachmentIdType(TypeDecorator):
   - impl = String(36)
   - process_bind_param: AttachmentId -> str (att.value)
   - process_result_value: str -> AttachmentId (AttachmentId.from_string)

4. TransactionTypeEnum(TypeDecorator):
   - impl = String(20)
   - process_bind_param: TransactionType -> str (.value)
   - process_result_value: str -> TransactionType

5. TransactionStatusEnum(TypeDecorator):
   - impl = String(20)
   - process_bind_param: TransactionStatus -> str (.value)
   - process_result_value: str -> TransactionStatus

Follow the existing AccountIdType and AccountTypeEnum patterns exactly. Import from src.domain.model.entity_id and src.domain.model.transaction_types.
  </action>
  <verify>
Run: `python -c "
from src.adapters.persistence.orm.types import (
    TransactionIdType, CategoryIdType, AttachmentIdType,
    TransactionTypeEnum, TransactionStatusEnum
)
print('Type decorators importable')
"`
  </verify>
  <done>Custom type decorators for Transaction domain created</done>
</task>

<task type="auto">
  <name>Task 2: Add transaction tables to tables.py</name>
  <files>src/adapters/persistence/orm/tables.py</files>
  <action>
Add to existing tables.py file following the research document patterns:

1. categories table:
   - id: String(36) primary key (cat_xxx)
   - user_id: String(36) FK to users.id, not null
   - name: String(255) not null
   - category_type: String(20) not null default "expense"
   - parent_id: String(36) FK to categories.id, nullable
   - is_system: Boolean not null default False
   - sort_order: Integer not null default 0
   - icon: String(50) nullable
   - created_at: DateTime(timezone=True) not null
   - updated_at: DateTime(timezone=True) not null
   - Indexes: ix_categories_user_id, ix_categories_parent

2. transactions table:
   - id: String(36) primary key (txn_xxx)
   - user_id: String(36) FK to users.id, not null
   - transaction_type: String(20) not null (expense/income/transfer)
   - status: String(20) not null default "pending"
   - date: DateTime(timezone=True) not null
   - amount: Numeric(19,4) not null
   - currency: String(3) not null default "USD"
   - account_id: String(36) FK to accounts.id, not null
   - transfer_account_id: String(36) FK to accounts.id, nullable
   - category_id: String(36) FK to categories.id, nullable
   - payee: String(255) nullable
   - description: Text nullable
   - reference_number: String(100) nullable
   - cleared_at: DateTime(timezone=True) nullable
   - created_at: DateTime(timezone=True) not null
   - updated_at: DateTime(timezone=True) not null
   - search_vector: TSVECTOR nullable (from sqlalchemy.dialects.postgresql)
   - Indexes: ix_transactions_user_id, ix_transactions_user_date, ix_transactions_account, ix_transactions_transfer_account, ix_transactions_category, ix_transactions_search (GIN)

3. split_lines table:
   - id: Integer primary key autoincrement
   - transaction_id: String(36) FK to transactions.id ON DELETE CASCADE, not null
   - amount: Numeric(19,4) not null
   - currency: String(3) not null default "USD"
   - category_id: String(36) FK to categories.id, nullable
   - memo: String(500) nullable
   - Indexes: ix_split_lines_transaction, ix_split_lines_category

4. attachments table:
   - id: String(36) primary key (att_xxx)
   - transaction_id: String(36) FK to transactions.id ON DELETE CASCADE, not null
   - user_id: String(36) FK to users.id, not null
   - filename: String(255) not null
   - storage_path: String(500) not null
   - content_type: String(100) not null
   - size_bytes: Integer not null
   - created_at: DateTime(timezone=True) not null
   - Indexes: ix_attachments_transaction, ix_attachments_user

Use the custom TypeDecorators where appropriate (TransactionIdType, CategoryIdType for primary keys). Import TSVECTOR from sqlalchemy.dialects.postgresql.

Note: For GIN index on search_vector, use:
Index("ix_transactions_search", "search_vector", postgresql_using="gin")
  </action>
  <verify>
Run: `python -c "
from src.adapters.persistence.orm.tables import (
    categories, transactions, split_lines, attachments
)
print('categories columns:', [c.name for c in categories.columns])
print('transactions columns:', [c.name for c in transactions.columns])
print('split_lines columns:', [c.name for c in split_lines.columns])
print('attachments columns:', [c.name for c in attachments.columns])
"`
  </verify>
  <done>All transaction tables defined in tables.py</done>
</task>

<task type="auto">
  <name>Task 3: Create Alembic migration</name>
  <files>alembic/versions/003_add_transaction_tables.py</files>
  <action>
Create new Alembic migration file. First check existing migrations to determine the correct revision number:
`ls alembic/versions/`

Create migration with proper down_revision chain:

```python
"""Add transaction domain tables

Revision ID: 003
Revises: [previous revision]
Create Date: [auto]
"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers
revision = '003_add_transaction_tables'
down_revision = '[previous]'  # Get this from ls alembic/versions/
branch_labels = None
depends_on = None


def upgrade() -> None:
    # Categories table
    op.create_table(
        'categories',
        sa.Column('id', sa.String(36), primary_key=True),
        sa.Column('user_id', sa.String(36), sa.ForeignKey('users.id'), nullable=False),
        sa.Column('name', sa.String(255), nullable=False),
        sa.Column('category_type', sa.String(20), nullable=False, server_default='expense'),
        sa.Column('parent_id', sa.String(36), sa.ForeignKey('categories.id'), nullable=True),
        sa.Column('is_system', sa.Boolean, nullable=False, server_default='false'),
        sa.Column('sort_order', sa.Integer, nullable=False, server_default='0'),
        sa.Column('icon', sa.String(50), nullable=True),
        sa.Column('created_at', sa.DateTime(timezone=True), nullable=False),
        sa.Column('updated_at', sa.DateTime(timezone=True), nullable=False),
    )
    op.create_index('ix_categories_user_id', 'categories', ['user_id'])
    op.create_index('ix_categories_parent', 'categories', ['parent_id'])

    # Transactions table
    op.create_table(
        'transactions',
        sa.Column('id', sa.String(36), primary_key=True),
        sa.Column('user_id', sa.String(36), sa.ForeignKey('users.id'), nullable=False),
        sa.Column('transaction_type', sa.String(20), nullable=False),
        sa.Column('status', sa.String(20), nullable=False, server_default='pending'),
        sa.Column('date', sa.DateTime(timezone=True), nullable=False),
        sa.Column('amount', sa.Numeric(19, 4), nullable=False),
        sa.Column('currency', sa.String(3), nullable=False, server_default='USD'),
        sa.Column('account_id', sa.String(36), sa.ForeignKey('accounts.id'), nullable=False),
        sa.Column('transfer_account_id', sa.String(36), sa.ForeignKey('accounts.id'), nullable=True),
        sa.Column('category_id', sa.String(36), sa.ForeignKey('categories.id'), nullable=True),
        sa.Column('payee', sa.String(255), nullable=True),
        sa.Column('description', sa.Text, nullable=True),
        sa.Column('reference_number', sa.String(100), nullable=True),
        sa.Column('cleared_at', sa.DateTime(timezone=True), nullable=True),
        sa.Column('created_at', sa.DateTime(timezone=True), nullable=False),
        sa.Column('updated_at', sa.DateTime(timezone=True), nullable=False),
        sa.Column('search_vector', postgresql.TSVECTOR, nullable=True),
    )
    op.create_index('ix_transactions_user_id', 'transactions', ['user_id'])
    op.create_index('ix_transactions_user_date', 'transactions', ['user_id', 'date'])
    op.create_index('ix_transactions_account', 'transactions', ['account_id'])
    op.create_index('ix_transactions_transfer_account', 'transactions', ['transfer_account_id'])
    op.create_index('ix_transactions_category', 'transactions', ['category_id'])
    op.create_index('ix_transactions_search', 'transactions', ['search_vector'], postgresql_using='gin')

    # Split lines table
    op.create_table(
        'split_lines',
        sa.Column('id', sa.Integer, primary_key=True, autoincrement=True),
        sa.Column('transaction_id', sa.String(36), sa.ForeignKey('transactions.id', ondelete='CASCADE'), nullable=False),
        sa.Column('amount', sa.Numeric(19, 4), nullable=False),
        sa.Column('currency', sa.String(3), nullable=False, server_default='USD'),
        sa.Column('category_id', sa.String(36), sa.ForeignKey('categories.id'), nullable=True),
        sa.Column('memo', sa.String(500), nullable=True),
    )
    op.create_index('ix_split_lines_transaction', 'split_lines', ['transaction_id'])
    op.create_index('ix_split_lines_category', 'split_lines', ['category_id'])

    # Attachments table
    op.create_table(
        'attachments',
        sa.Column('id', sa.String(36), primary_key=True),
        sa.Column('transaction_id', sa.String(36), sa.ForeignKey('transactions.id', ondelete='CASCADE'), nullable=False),
        sa.Column('user_id', sa.String(36), sa.ForeignKey('users.id'), nullable=False),
        sa.Column('filename', sa.String(255), nullable=False),
        sa.Column('storage_path', sa.String(500), nullable=False),
        sa.Column('content_type', sa.String(100), nullable=False),
        sa.Column('size_bytes', sa.Integer, nullable=False),
        sa.Column('created_at', sa.DateTime(timezone=True), nullable=False),
    )
    op.create_index('ix_attachments_transaction', 'attachments', ['transaction_id'])
    op.create_index('ix_attachments_user', 'attachments', ['user_id'])


def downgrade() -> None:
    op.drop_table('attachments')
    op.drop_table('split_lines')
    op.drop_table('transactions')
    op.drop_table('categories')
```

Then run the migration to verify it applies cleanly.
  </action>
  <verify>
Run migrations and verify tables exist:
```
alembic upgrade head
python -c "
from sqlalchemy import inspect
from src.adapters.persistence.orm.database import engine
inspector = inspect(engine)
tables = inspector.get_table_names()
print('Tables:', sorted([t for t in tables if t in ['categories', 'transactions', 'split_lines', 'attachments']]))
"
```
Expected: Shows all four tables
  </verify>
  <done>Migration created and applies successfully</done>
</task>

</tasks>

<verification>
All tasks completed:
1. Custom type decorators work in types.py
2. All tables defined in tables.py
3. Migration runs: `alembic upgrade head` succeeds
4. Tables exist in database
5. Foreign keys and indexes created correctly
</verification>

<success_criteria>
- categories, transactions, split_lines, attachments tables exist
- search_vector column has GIN index for full-text search
- ON DELETE CASCADE on transaction_id foreign keys
- alembic upgrade head runs without errors
- alembic downgrade -1 runs without errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-transaction-domain/03-03-SUMMARY.md`
</output>
