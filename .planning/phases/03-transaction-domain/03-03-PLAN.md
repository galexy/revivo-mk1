---
phase: 03-transaction-domain
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/adapters/persistence/orm/tables.py
  - src/adapters/persistence/orm/types.py
  - alembic/versions/003_add_transaction_tables.py
autonomous: true

must_haves:
  truths:
    - "Database tables exist for transactions, split_lines, categories, and payees"
    - "Alembic migration applies cleanly to existing database"
    - "Full-text search vector column exists with GIN index"
    - "Foreign key constraints enforce referential integrity"
  artifacts:
    - path: "src/adapters/persistence/orm/tables.py"
      provides: "Transaction domain table definitions"
      contains: "transactions = Table"
    - path: "alembic/versions/003_add_transaction_tables.py"
      provides: "Migration for Phase 3 tables"
      contains: "def upgrade"
  key_links:
    - from: "src/adapters/persistence/orm/tables.py"
      to: "accounts table"
      via: "Foreign key from transactions.account_id"
      pattern: "ForeignKey.*accounts.id"
    - from: "src/adapters/persistence/orm/tables.py"
      to: "users table"
      via: "Foreign key from transactions.user_id"
      pattern: "ForeignKey.*users.id"
---

<objective>
Create database tables and Alembic migration for Transaction domain entities following the CONTEXT decisions.

Purpose: Establish the persistence schema for transactions, splits, categories, and payees with proper indexes and constraints.

Output: Database tables ready for ORM mapper implementation in Plan 04.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/03-transaction-domain/03-CONTEXT.md
@.planning/phases/03-transaction-domain/03-01-SUMMARY.md

# Existing table patterns
@src/adapters/persistence/orm/tables.py
@src/adapters/persistence/orm/types.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add custom type decorators for new entity IDs</name>
  <files>src/adapters/persistence/orm/types.py</files>
  <action>
Add TypeDecorators for the new entity ID types following the existing pattern in types.py:

1. **TransactionIdType** - For TransactionId
2. **CategoryIdType** - For CategoryId
3. **PayeeIdType** - For PayeeId
4. **TransactionStatusEnum** - For TransactionStatus StrEnum
5. **TransactionSourceEnum** - For TransactionSource StrEnum

Follow the exact pattern used for AccountIdType and AccountTypeEnum:

```python
# Add imports at top
from src.domain.model.entity_id import TransactionId, CategoryId, PayeeId
from src.domain.model.transaction_types import TransactionStatus, TransactionSource

# Transaction ID type decorator
class TransactionIdType(TypeDecorator):
    """SQLAlchemy type for TransactionId domain type."""
    impl = String
    cache_ok = True

    def process_bind_param(self, value, dialect):
        if value is None:
            return None
        if isinstance(value, TransactionId):
            return value.value
        return str(value)

    def process_result_value(self, value, dialect):
        if value is None:
            return None
        return TransactionId.from_string(value)


class CategoryIdType(TypeDecorator):
    """SQLAlchemy type for CategoryId domain type."""
    impl = String
    cache_ok = True

    def process_bind_param(self, value, dialect):
        if value is None:
            return None
        if isinstance(value, CategoryId):
            return value.value
        return str(value)

    def process_result_value(self, value, dialect):
        if value is None:
            return None
        return CategoryId.from_string(value)


class PayeeIdType(TypeDecorator):
    """SQLAlchemy type for PayeeId domain type."""
    impl = String
    cache_ok = True

    def process_bind_param(self, value, dialect):
        if value is None:
            return None
        if isinstance(value, PayeeId):
            return value.value
        return str(value)

    def process_result_value(self, value, dialect):
        if value is None:
            return None
        return PayeeId.from_string(value)


class TransactionStatusEnum(TypeDecorator):
    """SQLAlchemy type for TransactionStatus enum."""
    impl = String
    cache_ok = True

    def process_bind_param(self, value, dialect):
        if value is None:
            return None
        if isinstance(value, TransactionStatus):
            return value.value
        return str(value)

    def process_result_value(self, value, dialect):
        if value is None:
            return None
        return TransactionStatus(value)


class TransactionSourceEnum(TypeDecorator):
    """SQLAlchemy type for TransactionSource enum."""
    impl = String
    cache_ok = True

    def process_bind_param(self, value, dialect):
        if value is None:
            return None
        if isinstance(value, TransactionSource):
            return value.value
        return str(value)

    def process_result_value(self, value, dialect):
        if value is None:
            return None
        return TransactionSource(value)
```
  </action>
  <verify>
```bash
cd /workspace && python -c "
from src.adapters.persistence.orm.types import (
    TransactionIdType,
    CategoryIdType,
    PayeeIdType,
    TransactionStatusEnum,
    TransactionSourceEnum,
)
from src.domain.model.entity_id import TransactionId, CategoryId, PayeeId
from src.domain.model.transaction_types import TransactionStatus, TransactionSource

# Test TransactionIdType
tid_type = TransactionIdType(36)
tid = TransactionId.generate()
bound = tid_type.process_bind_param(tid, None)
assert bound == tid.value
result = tid_type.process_result_value(bound, None)
assert result.value == tid.value
print('TransactionIdType: OK')

# Test CategoryIdType
cid_type = CategoryIdType(36)
cid = CategoryId.generate()
bound = cid_type.process_bind_param(cid, None)
result = cid_type.process_result_value(bound, None)
assert result.value == cid.value
print('CategoryIdType: OK')

# Test PayeeIdType
pid_type = PayeeIdType(36)
pid = PayeeId.generate()
bound = pid_type.process_bind_param(pid, None)
result = pid_type.process_result_value(bound, None)
assert result.value == pid.value
print('PayeeIdType: OK')

# Test TransactionStatusEnum
status_type = TransactionStatusEnum(20)
bound = status_type.process_bind_param(TransactionStatus.PENDING, None)
assert bound == 'pending'
result = status_type.process_result_value('cleared', None)
assert result == TransactionStatus.CLEARED
print('TransactionStatusEnum: OK')

# Test TransactionSourceEnum
source_type = TransactionSourceEnum(20)
bound = source_type.process_bind_param(TransactionSource.MANUAL, None)
assert bound == 'manual'
result = source_type.process_result_value('downloaded', None)
assert result == TransactionSource.DOWNLOADED
print('TransactionSourceEnum: OK')

print('\\nAll type decorators verified!')
"
```
  </verify>
  <done>
TransactionIdType, CategoryIdType, PayeeIdType, TransactionStatusEnum, and TransactionSourceEnum type decorators added to types.py with proper domain type conversion.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add table definitions for transaction domain</name>
  <files>src/adapters/persistence/orm/tables.py</files>
  <action>
Add table definitions for categories, payees, transactions, and split_lines to tables.py:

```python
# Add imports
from sqlalchemy.dialects.postgresql import TSVECTOR
from .types import (
    # ... existing imports ...
    TransactionIdType,
    CategoryIdType,
    PayeeIdType,
    TransactionStatusEnum,
    TransactionSourceEnum,
)

# Categories table (hierarchical structure)
categories = Table(
    "categories",
    metadata,
    Column("id", CategoryIdType(36), primary_key=True),  # cat_xxx
    Column("user_id", UserIdType(36), ForeignKey("users.id"), nullable=False),
    Column("name", String(255), nullable=False),

    # Hierarchy - parent_id is None for top-level
    Column("parent_id", CategoryIdType(36), ForeignKey("categories.id"), nullable=True),

    # Metadata
    Column("is_system", Boolean, nullable=False, default=False),
    Column("is_hidden", Boolean, nullable=False, default=False),
    Column("sort_order", Integer, nullable=False, default=0),
    Column("icon", String(50), nullable=True),

    # Audit
    Column("created_at", DateTime(timezone=True), nullable=False),
    Column("updated_at", DateTime(timezone=True), nullable=False),

    # Indexes
    Index("ix_categories_user_id", "user_id"),
    Index("ix_categories_parent_id", "parent_id"),
    Index("ix_categories_user_system", "user_id", "is_system"),
)

# Payees table (managed entity list)
payees = Table(
    "payees",
    metadata,
    Column("id", PayeeIdType(36), primary_key=True),  # payee_xxx
    Column("user_id", UserIdType(36), ForeignKey("users.id"), nullable=False),
    Column("name", String(255), nullable=False),
    Column("normalized_name", String(255), nullable=False),  # Lowercase for matching

    # Default category for auto-fill
    Column("default_category_id", CategoryIdType(36), ForeignKey("categories.id"), nullable=True),

    # Usage tracking
    Column("last_used_at", DateTime(timezone=True), nullable=True),
    Column("usage_count", Integer, nullable=False, default=0),

    # Audit
    Column("created_at", DateTime(timezone=True), nullable=False),
    Column("updated_at", DateTime(timezone=True), nullable=False),

    # Indexes
    Index("ix_payees_user_id", "user_id"),
    Index("ix_payees_user_normalized", "user_id", "normalized_name"),
)

# Transactions table (always-split model)
transactions = Table(
    "transactions",
    metadata,
    Column("id", TransactionIdType(36), primary_key=True),  # txn_xxx
    Column("user_id", UserIdType(36), ForeignKey("users.id"), nullable=False),
    Column("account_id", AccountIdType(36), ForeignKey("accounts.id"), nullable=False),

    # Dates per CONTEXT: effective_date and posted_date
    Column("effective_date", Date, nullable=False),
    Column("posted_date", Date, nullable=True),  # None = pending

    # Amount: net flow (positive = inflow, negative = outflow)
    Column("amount", Numeric(19, 4), nullable=False),
    Column("currency", String(3), nullable=False, default="USD"),

    # Status and source
    Column("status", TransactionStatusEnum(20), nullable=False, default="pending"),
    Column("source", TransactionSourceEnum(20), nullable=False, default="manual"),

    # Payee (managed entity reference + denormalized name)
    Column("payee_id", PayeeIdType(36), ForeignKey("payees.id"), nullable=True),
    Column("payee_name", String(255), nullable=True),

    # Description
    Column("memo", Text, nullable=True),
    Column("check_number", String(50), nullable=True),

    # Mirror transaction link
    Column("source_transaction_id", TransactionIdType(36), ForeignKey("transactions.id"), nullable=True),
    Column("is_mirror", Boolean, nullable=False, default=False),

    # Audit
    Column("created_at", DateTime(timezone=True), nullable=False),
    Column("updated_at", DateTime(timezone=True), nullable=False),

    # Full-text search vector (updated by application)
    Column("search_vector", TSVECTOR, nullable=True),

    # Indexes
    Index("ix_transactions_user_id", "user_id"),
    Index("ix_transactions_account_id", "account_id"),
    Index("ix_transactions_user_effective_date", "user_id", "effective_date"),
    Index("ix_transactions_account_effective_date", "account_id", "effective_date"),
    Index("ix_transactions_source_transaction", "source_transaction_id"),
    Index("ix_transactions_search", "search_vector", postgresql_using="gin"),
)

# Split lines table (always 1+ per transaction)
split_lines = Table(
    "split_lines",
    metadata,
    Column("id", Integer, primary_key=True, autoincrement=True),
    Column("transaction_id", TransactionIdType(36), ForeignKey("transactions.id", ondelete="CASCADE"), nullable=False),

    # Amount: signed (positive = income, negative = expense)
    Column("amount", Numeric(19, 4), nullable=False),
    Column("currency", String(3), nullable=False, default="USD"),

    # Either category OR transfer account (not both)
    Column("category_id", CategoryIdType(36), ForeignKey("categories.id"), nullable=True),
    Column("transfer_account_id", AccountIdType(36), ForeignKey("accounts.id"), nullable=True),

    # Per-split memo
    Column("memo", String(500), nullable=True),

    # Order within transaction
    Column("sort_order", Integer, nullable=False, default=0),

    # Indexes
    Index("ix_split_lines_transaction_id", "transaction_id"),
    Index("ix_split_lines_category_id", "category_id"),
    Index("ix_split_lines_transfer_account", "transfer_account_id"),
)
```

Important notes:
- Use Date type (not DateTime) for effective_date and posted_date per CONTEXT (dates, not datetimes)
- TSVECTOR requires postgresql dialect import
- CASCADE delete on split_lines when transaction deleted
- Separate indexes for common query patterns
  </action>
  <verify>
```bash
cd /workspace && python -c "
from src.adapters.persistence.orm.tables import (
    categories,
    payees,
    transactions,
    split_lines,
    metadata,
)

# Verify tables exist
assert categories is not None
assert payees is not None
assert transactions is not None
assert split_lines is not None

# Verify key columns
assert 'id' in [c.name for c in categories.columns]
assert 'parent_id' in [c.name for c in categories.columns]
assert 'is_system' in [c.name for c in categories.columns]

assert 'normalized_name' in [c.name for c in payees.columns]
assert 'default_category_id' in [c.name for c in payees.columns]

assert 'effective_date' in [c.name for c in transactions.columns]
assert 'posted_date' in [c.name for c in transactions.columns]
assert 'is_mirror' in [c.name for c in transactions.columns]
assert 'source_transaction_id' in [c.name for c in transactions.columns]
assert 'search_vector' in [c.name for c in transactions.columns]

assert 'transfer_account_id' in [c.name for c in split_lines.columns]
assert 'category_id' in [c.name for c in split_lines.columns]

print('All table definitions verified!')
print(f'Categories columns: {[c.name for c in categories.columns]}')
print(f'Transactions columns: {[c.name for c in transactions.columns]}')
print(f'Split lines columns: {[c.name for c in split_lines.columns]}')
"
```
  </verify>
  <done>
Table definitions added for categories, payees, transactions, and split_lines with proper foreign keys, indexes, and type decorators.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Alembic migration</name>
  <files>alembic/versions/003_add_transaction_tables.py</files>
  <action>
Create Alembic migration for Phase 3 tables. First check existing migrations to get the correct revision chain:

```bash
ls -la alembic/versions/
```

Then create the migration file with proper down_revision reference:

```python
"""Add transaction domain tables.

Phase 3: Transaction Domain - categories, payees, transactions, split_lines.

Revision ID: 003_add_transaction_tables
Revises: <previous_revision_id>
Create Date: 2026-01-31
"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision = "003_add_transaction_tables"
down_revision = "<PREVIOUS_REVISION>"  # Get from existing migrations
branch_labels = None
depends_on = None


def upgrade() -> None:
    # Categories table (must be created before transactions for FK)
    op.create_table(
        "categories",
        sa.Column("id", sa.String(36), primary_key=True),
        sa.Column("user_id", sa.String(36), sa.ForeignKey("users.id"), nullable=False),
        sa.Column("name", sa.String(255), nullable=False),
        sa.Column("parent_id", sa.String(36), sa.ForeignKey("categories.id"), nullable=True),
        sa.Column("is_system", sa.Boolean, nullable=False, default=False),
        sa.Column("is_hidden", sa.Boolean, nullable=False, default=False),
        sa.Column("sort_order", sa.Integer, nullable=False, default=0),
        sa.Column("icon", sa.String(50), nullable=True),
        sa.Column("created_at", sa.DateTime(timezone=True), nullable=False),
        sa.Column("updated_at", sa.DateTime(timezone=True), nullable=False),
    )
    op.create_index("ix_categories_user_id", "categories", ["user_id"])
    op.create_index("ix_categories_parent_id", "categories", ["parent_id"])
    op.create_index("ix_categories_user_system", "categories", ["user_id", "is_system"])

    # Payees table (must be created before transactions for FK)
    op.create_table(
        "payees",
        sa.Column("id", sa.String(36), primary_key=True),
        sa.Column("user_id", sa.String(36), sa.ForeignKey("users.id"), nullable=False),
        sa.Column("name", sa.String(255), nullable=False),
        sa.Column("normalized_name", sa.String(255), nullable=False),
        sa.Column("default_category_id", sa.String(36), sa.ForeignKey("categories.id"), nullable=True),
        sa.Column("last_used_at", sa.DateTime(timezone=True), nullable=True),
        sa.Column("usage_count", sa.Integer, nullable=False, default=0),
        sa.Column("created_at", sa.DateTime(timezone=True), nullable=False),
        sa.Column("updated_at", sa.DateTime(timezone=True), nullable=False),
    )
    op.create_index("ix_payees_user_id", "payees", ["user_id"])
    op.create_index("ix_payees_user_normalized", "payees", ["user_id", "normalized_name"])

    # Transactions table
    op.create_table(
        "transactions",
        sa.Column("id", sa.String(36), primary_key=True),
        sa.Column("user_id", sa.String(36), sa.ForeignKey("users.id"), nullable=False),
        sa.Column("account_id", sa.String(36), sa.ForeignKey("accounts.id"), nullable=False),
        sa.Column("effective_date", sa.Date, nullable=False),
        sa.Column("posted_date", sa.Date, nullable=True),
        sa.Column("amount", sa.Numeric(19, 4), nullable=False),
        sa.Column("currency", sa.String(3), nullable=False, default="USD"),
        sa.Column("status", sa.String(20), nullable=False, default="pending"),
        sa.Column("source", sa.String(20), nullable=False, default="manual"),
        sa.Column("payee_id", sa.String(36), sa.ForeignKey("payees.id"), nullable=True),
        sa.Column("payee_name", sa.String(255), nullable=True),
        sa.Column("memo", sa.Text, nullable=True),
        sa.Column("check_number", sa.String(50), nullable=True),
        sa.Column("source_transaction_id", sa.String(36), nullable=True),  # Self-reference added after
        sa.Column("is_mirror", sa.Boolean, nullable=False, default=False),
        sa.Column("created_at", sa.DateTime(timezone=True), nullable=False),
        sa.Column("updated_at", sa.DateTime(timezone=True), nullable=False),
        sa.Column("search_vector", postgresql.TSVECTOR, nullable=True),
    )

    # Add self-referential FK after table created
    op.create_foreign_key(
        "fk_transactions_source_transaction",
        "transactions",
        "transactions",
        ["source_transaction_id"],
        ["id"],
    )

    op.create_index("ix_transactions_user_id", "transactions", ["user_id"])
    op.create_index("ix_transactions_account_id", "transactions", ["account_id"])
    op.create_index("ix_transactions_user_effective_date", "transactions", ["user_id", "effective_date"])
    op.create_index("ix_transactions_account_effective_date", "transactions", ["account_id", "effective_date"])
    op.create_index("ix_transactions_source_transaction", "transactions", ["source_transaction_id"])
    op.create_index(
        "ix_transactions_search",
        "transactions",
        ["search_vector"],
        postgresql_using="gin",
    )

    # Split lines table
    op.create_table(
        "split_lines",
        sa.Column("id", sa.Integer, primary_key=True, autoincrement=True),
        sa.Column(
            "transaction_id",
            sa.String(36),
            sa.ForeignKey("transactions.id", ondelete="CASCADE"),
            nullable=False,
        ),
        sa.Column("amount", sa.Numeric(19, 4), nullable=False),
        sa.Column("currency", sa.String(3), nullable=False, default="USD"),
        sa.Column("category_id", sa.String(36), sa.ForeignKey("categories.id"), nullable=True),
        sa.Column("transfer_account_id", sa.String(36), sa.ForeignKey("accounts.id"), nullable=True),
        sa.Column("memo", sa.String(500), nullable=True),
        sa.Column("sort_order", sa.Integer, nullable=False, default=0),
    )
    op.create_index("ix_split_lines_transaction_id", "split_lines", ["transaction_id"])
    op.create_index("ix_split_lines_category_id", "split_lines", ["category_id"])
    op.create_index("ix_split_lines_transfer_account", "split_lines", ["transfer_account_id"])


def downgrade() -> None:
    op.drop_table("split_lines")
    op.drop_table("transactions")
    op.drop_table("payees")
    op.drop_table("categories")
```

Before creating, check the existing migration files to get the correct down_revision:

```bash
ls alembic/versions/*.py
head -20 alembic/versions/*accounts*.py
```
  </action>
  <verify>
```bash
# Check migration file exists and has correct structure
cd /workspace && python -c "
import importlib.util
import sys

# Find the migration file
import os
migration_files = [f for f in os.listdir('alembic/versions') if '003' in f or 'transaction' in f.lower()]
if not migration_files:
    print('ERROR: Migration file not found')
    sys.exit(1)

migration_path = f'alembic/versions/{migration_files[0]}'
print(f'Found migration: {migration_path}')

# Load and verify
spec = importlib.util.spec_from_file_location('migration', migration_path)
migration = importlib.util.module_from_spec(spec)
spec.loader.exec_module(migration)

assert hasattr(migration, 'upgrade'), 'Missing upgrade function'
assert hasattr(migration, 'downgrade'), 'Missing downgrade function'
assert hasattr(migration, 'revision'), 'Missing revision'
assert hasattr(migration, 'down_revision'), 'Missing down_revision'

print(f'Revision: {migration.revision}')
print(f'Down revision: {migration.down_revision}')
print('Migration structure verified!')
"

# Apply migration to test database
cd /workspace && alembic upgrade head && echo "Migration applied successfully"
```
  </verify>
  <done>
Alembic migration created for categories, payees, transactions, and split_lines tables with proper foreign keys, indexes, and GIN index for full-text search.
  </done>
</task>

</tasks>

<verification>
Verify migration applies cleanly:

```bash
cd /workspace && alembic upgrade head
```

Verify tables exist in database:

```bash
cd /workspace && python -c "
from src.adapters.persistence.database import get_sync_engine
from sqlalchemy import inspect

engine = get_sync_engine()
inspector = inspect(engine)
tables = inspector.get_table_names()

required = ['categories', 'payees', 'transactions', 'split_lines']
for table in required:
    assert table in tables, f'Missing table: {table}'
print(f'All required tables exist: {required}')
"
```
</verification>

<success_criteria>
1. Type decorators added for TransactionId, CategoryId, PayeeId
2. Type decorators added for TransactionStatus, TransactionSource enums
3. Categories table with hierarchy support (parent_id FK)
4. Payees table with normalized_name and usage tracking
5. Transactions table with dual dates, mirror support, search_vector
6. Split_lines table with category OR transfer_account
7. Alembic migration applies without errors
8. All foreign key constraints created
9. GIN index on search_vector column
</success_criteria>

<output>
After completion, create `.planning/phases/03-transaction-domain/03-03-SUMMARY.md`
</output>
