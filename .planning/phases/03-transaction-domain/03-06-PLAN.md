---
phase: 03-transaction-domain
plan: 06
type: execute
wave: 5
depends_on: ["03-05"]
files_modified:
  - src/adapters/api/schemas/transaction.py
  - src/adapters/api/schemas/category.py
  - src/adapters/api/routes/transactions.py
  - src/adapters/api/routes/categories.py
  - src/adapters/api/app.py
autonomous: true

must_haves:
  truths:
    - "POST /api/v1/transactions creates a transaction with splits"
    - "GET /api/v1/transactions supports search and filter query parameters"
    - "PATCH /api/v1/transactions/{id} can update splits and amount"
    - "POST /api/v1/categories creates a category with optional parent"
    - "GET /api/v1/categories returns user's category tree"
    - "API validates inputs with Pydantic schemas"
  artifacts:
    - path: "src/adapters/api/routes/transactions.py"
      provides: "Transaction REST endpoints including split updates"
      contains: "router = APIRouter"
    - path: "src/adapters/api/routes/categories.py"
      provides: "Category REST endpoints"
      contains: "router = APIRouter"
    - path: "src/adapters/api/schemas/transaction.py"
      provides: "Transaction Pydantic schemas including UpdateTransactionSplitsRequest"
      contains: "class UpdateTransactionSplitsRequest"
    - path: "src/adapters/api/schemas/category.py"
      provides: "Category Pydantic schemas"
      contains: "class CreateCategoryRequest"
  key_links:
    - from: "src/adapters/api/routes/transactions.py"
      to: "src/application/services/transaction_service.py"
      via: "Service dependency injection"
      pattern: "TransactionService"
    - from: "src/adapters/api/routes/transactions.py"
      to: "update_transaction_splits"
      via: "PATCH endpoint calling service method"
      pattern: "service.update_transaction_splits"
    - from: "src/adapters/api/app.py"
      to: "routers"
      via: "app.include_router"
      pattern: "include_router.*transactions"
---

<objective>
Create REST API endpoints for Transaction and Category domains following the existing accounts API pattern.

Purpose: Expose transaction and category functionality via REST API with proper validation, error handling, and OpenAPI documentation.

Output: Complete API ready for integration testing in Plan 07.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/03-transaction-domain/03-CONTEXT.md
@.planning/phases/03-transaction-domain/03-05-SUMMARY.md

# Existing API patterns
@src/adapters/api/schemas/account.py
@src/adapters/api/routes/accounts.py
@src/adapters/api/app.py
@src/adapters/api/dependencies.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Pydantic schemas for categories and transactions</name>
  <files>
    src/adapters/api/schemas/category.py
    src/adapters/api/schemas/transaction.py
  </files>
  <action>
Create Pydantic schemas following the account.py pattern.

**category.py:**
```python
"""Pydantic schemas for Category API endpoints."""
from datetime import datetime

from pydantic import BaseModel, Field


class CreateCategoryRequest(BaseModel):
    """Request to create a new category."""
    name: str = Field(..., min_length=1, max_length=255)
    parent_id: str | None = Field(default=None, description="Parent category ID for subcategories")
    icon: str | None = Field(default=None, max_length=50, description="Emoji or icon name")


class UpdateCategoryRequest(BaseModel):
    """Request to update a category."""
    name: str | None = Field(default=None, min_length=1, max_length=255)
    parent_id: str | None = Field(default=None, description="New parent ID (or null for top-level)")
    icon: str | None = Field(default=None, max_length=50)


class CategoryResponse(BaseModel):
    """Response schema for a category."""
    id: str
    user_id: str
    name: str
    parent_id: str | None
    is_system: bool
    is_hidden: bool
    sort_order: int
    icon: str | None
    created_at: datetime
    updated_at: datetime

    model_config = {"from_attributes": True}


class CategoryListResponse(BaseModel):
    """Response for listing categories."""
    categories: list[CategoryResponse]
    total: int


class CategoryTreeResponse(BaseModel):
    """Response for category tree structure."""
    root: list[CategoryResponse]
    children: dict[str, list[CategoryResponse]]
```

**transaction.py:**
```python
"""Pydantic schemas for Transaction API endpoints."""
from datetime import date, datetime
from decimal import Decimal

from pydantic import BaseModel, Field, field_validator

from src.domain.model.transaction_types import TransactionSource, TransactionStatus


class MoneySchema(BaseModel):
    """Schema for money amounts."""
    amount: Decimal = Field(..., decimal_places=4)
    currency: str = Field(default="USD", min_length=3, max_length=3)


class SplitLineRequest(BaseModel):
    """Request schema for a split line."""
    amount: MoneySchema
    category_id: str | None = Field(default=None, description="Category for expense/income splits")
    transfer_account_id: str | None = Field(default=None, description="Target account for transfer splits")
    memo: str | None = Field(default=None, max_length=500)

    @field_validator('transfer_account_id')
    @classmethod
    def validate_transfer_amount(cls, v, info):
        # Note: Cross-field validation done in service layer
        return v


class SplitLineResponse(BaseModel):
    """Response schema for a split line."""
    amount: MoneySchema
    category_id: str | None
    transfer_account_id: str | None
    memo: str | None


class CreateTransactionRequest(BaseModel):
    """Request to create a transaction."""
    account_id: str = Field(..., description="Account for this transaction")
    effective_date: date = Field(..., description="When transaction logically occurred")
    posted_date: date | None = Field(default=None, description="When transaction cleared (defaults to effective_date)")
    amount: MoneySchema = Field(..., description="Net flow (positive=inflow, negative=outflow)")
    splits: list[SplitLineRequest] = Field(..., min_length=1, description="Split lines (must sum to amount)")
    payee_name: str | None = Field(default=None, max_length=255)
    memo: str | None = Field(default=None, max_length=2000)
    check_number: str | None = Field(default=None, max_length=50)


class UpdateTransactionRequest(BaseModel):
    """Request to update transaction metadata (dates, memo, etc).

    For updating splits/amount, use UpdateTransactionSplitsRequest via PATCH with splits field.
    """
    effective_date: date | None = None
    posted_date: date | None = None
    memo: str | None = None
    payee_name: str | None = None
    check_number: str | None = None
    # Optional: splits and amount for full financial update
    splits: list[SplitLineRequest] | None = Field(
        default=None,
        description="New splits (if provided, amount must also be provided)"
    )
    amount: MoneySchema | None = Field(
        default=None,
        description="New amount (required if splits provided)"
    )

    @field_validator('amount')
    @classmethod
    def validate_splits_with_amount(cls, v, info):
        # If splits provided but amount not, that's an error (caught in route)
        return v


class TransactionResponse(BaseModel):
    """Response schema for a transaction."""
    id: str
    user_id: str
    account_id: str
    effective_date: date
    posted_date: date | None
    amount: MoneySchema
    status: TransactionStatus
    source: TransactionSource
    splits: list[SplitLineResponse]
    payee_id: str | None
    payee_name: str | None
    memo: str | None
    check_number: str | None
    is_mirror: bool
    source_transaction_id: str | None
    created_at: datetime
    updated_at: datetime

    model_config = {"from_attributes": True}


class TransactionListResponse(BaseModel):
    """Response for listing transactions."""
    transactions: list[TransactionResponse]
    total: int
    limit: int
    offset: int


class TransactionFilterParams(BaseModel):
    """Query parameters for filtering transactions."""
    account_id: str | None = None
    category_id: str | None = None
    date_from: date | None = None
    date_to: date | None = None
    amount_min: Decimal | None = None
    amount_max: Decimal | None = None
    search: str | None = Field(default=None, description="Full-text search on payee/memo")
    limit: int = Field(default=100, le=500)
    offset: int = Field(default=0, ge=0)


class MarkClearedRequest(BaseModel):
    """Request to mark transaction as cleared."""
    posted_date: date | None = Field(default=None, description="Posted date (optional)")
```
  </action>
  <verify>
```bash
cd /workspace && python -c "
from src.adapters.api.schemas.category import (
    CreateCategoryRequest,
    UpdateCategoryRequest,
    CategoryResponse,
    CategoryListResponse,
    CategoryTreeResponse,
)
from src.adapters.api.schemas.transaction import (
    MoneySchema,
    SplitLineRequest,
    SplitLineResponse,
    CreateTransactionRequest,
    UpdateTransactionRequest,
    TransactionResponse,
    TransactionListResponse,
    TransactionFilterParams,
    MarkClearedRequest,
)
from decimal import Decimal
from datetime import date

# Test Category schemas
cat_req = CreateCategoryRequest(name='Food', parent_id=None)
assert cat_req.name == 'Food'

# Test Transaction schemas
split = SplitLineRequest(
    amount=MoneySchema(amount=Decimal('-50.00'), currency='USD'),
    category_id='cat_123'
)
assert split.amount.amount == Decimal('-50.00')

txn_req = CreateTransactionRequest(
    account_id='acct_123',
    effective_date=date.today(),
    amount=MoneySchema(amount=Decimal('-50.00'), currency='USD'),
    splits=[split]
)
assert len(txn_req.splits) == 1

# Test UpdateTransactionRequest with splits
update_req = UpdateTransactionRequest(
    splits=[split],
    amount=MoneySchema(amount=Decimal('-50.00'), currency='USD')
)
assert update_req.splits is not None
assert update_req.amount is not None

print('All schemas verified!')
"
```
  </verify>
  <done>
Pydantic schemas created for categories and transactions with proper validation, field constraints, and model configuration. UpdateTransactionRequest now supports optional splits/amount for full financial updates.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create API routes for categories and transactions</name>
  <files>
    src/adapters/api/routes/categories.py
    src/adapters/api/routes/transactions.py
  </files>
  <action>
Create API routes following the accounts.py pattern.

**categories.py:**
```python
"""Category API endpoints."""
from fastapi import APIRouter, Depends, HTTPException, status

from src.adapters.api.dependencies import get_category_service, get_current_user_id
from src.adapters.api.schemas.category import (
    CategoryListResponse,
    CategoryResponse,
    CategoryTreeResponse,
    CreateCategoryRequest,
    UpdateCategoryRequest,
)
from src.application.services.category_service import CategoryError, CategoryService
from src.domain.model.entity_id import CategoryId, UserId

router = APIRouter(prefix="/categories", tags=["categories"])


def _category_to_response(category) -> CategoryResponse:
    """Convert domain Category to response schema."""
    return CategoryResponse(
        id=str(category.id),
        user_id=str(category.user_id),
        name=category.name,
        parent_id=str(category.parent_id) if category.parent_id else None,
        is_system=category.is_system,
        is_hidden=category.is_hidden,
        sort_order=category.sort_order,
        icon=category.icon,
        created_at=category.created_at,
        updated_at=category.updated_at,
    )


@router.post("", response_model=CategoryResponse, status_code=status.HTTP_201_CREATED)
def create_category(
    request: CreateCategoryRequest,
    service: CategoryService = Depends(get_category_service),
    user_id: UserId = Depends(get_current_user_id),
):
    """Create a new category."""
    parent_id = CategoryId.from_string(request.parent_id) if request.parent_id else None

    result = service.create_category(
        user_id=user_id,
        name=request.name,
        parent_id=parent_id,
        icon=request.icon,
    )

    if isinstance(result, CategoryError):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail={"code": result.code, "message": result.message},
        )

    return _category_to_response(result)


@router.get("", response_model=CategoryListResponse)
def list_categories(
    service: CategoryService = Depends(get_category_service),
    user_id: UserId = Depends(get_current_user_id),
):
    """List all categories for the current user."""
    # Ensure system categories exist
    service.ensure_system_categories(user_id)

    categories = service.get_user_categories(user_id)
    return CategoryListResponse(
        categories=[_category_to_response(c) for c in categories],
        total=len(categories),
    )


@router.get("/tree", response_model=CategoryTreeResponse)
def get_category_tree(
    service: CategoryService = Depends(get_category_service),
    user_id: UserId = Depends(get_current_user_id),
):
    """Get categories organized as a tree structure."""
    service.ensure_system_categories(user_id)
    tree = service.get_category_tree(user_id)

    return CategoryTreeResponse(
        root=[_category_to_response(c) for c in tree["root"]],
        children={
            parent_id: [_category_to_response(c) for c in children]
            for parent_id, children in tree["children"].items()
        },
    )


@router.get("/{category_id}", response_model=CategoryResponse)
def get_category(
    category_id: str,
    service: CategoryService = Depends(get_category_service),
    user_id: UserId = Depends(get_current_user_id),
):
    """Get a category by ID."""
    cat_id = CategoryId.from_string(category_id)
    category = service.get_category(cat_id)

    if category is None:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Category not found")

    if category.user_id != user_id:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Category not found")

    return _category_to_response(category)


@router.patch("/{category_id}", response_model=CategoryResponse)
def update_category(
    category_id: str,
    request: UpdateCategoryRequest,
    service: CategoryService = Depends(get_category_service),
    user_id: UserId = Depends(get_current_user_id),
):
    """Update a category."""
    cat_id = CategoryId.from_string(category_id)

    # Update name if provided
    if request.name is not None:
        result = service.update_category_name(user_id, cat_id, request.name)
        if isinstance(result, CategoryError):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail={"code": result.code, "message": result.message},
            )

    # Update parent if provided (including setting to None for top-level)
    if request.parent_id is not None or "parent_id" in request.model_fields_set:
        parent_id = CategoryId.from_string(request.parent_id) if request.parent_id else None
        result = service.update_category_parent(user_id, cat_id, parent_id)
        if isinstance(result, CategoryError):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail={"code": result.code, "message": result.message},
            )

    # Fetch updated category
    category = service.get_category(cat_id)
    return _category_to_response(category)


@router.delete("/{category_id}", status_code=status.HTTP_204_NO_CONTENT)
def delete_category(
    category_id: str,
    reassign_to: str | None = None,
    service: CategoryService = Depends(get_category_service),
    user_id: UserId = Depends(get_current_user_id),
):
    """Delete a category."""
    cat_id = CategoryId.from_string(category_id)
    reassign_id = CategoryId.from_string(reassign_to) if reassign_to else None

    result = service.delete_category(user_id, cat_id, reassign_id)

    if isinstance(result, CategoryError):
        status_code = status.HTTP_400_BAD_REQUEST
        if result.code == "NOT_FOUND":
            status_code = status.HTTP_404_NOT_FOUND
        raise HTTPException(
            status_code=status_code,
            detail={"code": result.code, "message": result.message},
        )
```

**transactions.py:**
```python
"""Transaction API endpoints."""
from datetime import date
from decimal import Decimal

from fastapi import APIRouter, Depends, HTTPException, Query, status

from src.adapters.api.dependencies import get_transaction_service, get_current_user_id
from src.adapters.api.schemas.transaction import (
    CreateTransactionRequest,
    MarkClearedRequest,
    MoneySchema,
    SplitLineResponse,
    TransactionListResponse,
    TransactionResponse,
    UpdateTransactionRequest,
)
from src.application.services.transaction_service import TransactionError, TransactionService
from src.domain.model.entity_id import AccountId, CategoryId, TransactionId, UserId
from src.domain.model.money import Money
from src.domain.model.split_line import SplitLine

router = APIRouter(prefix="/transactions", tags=["transactions"])


def _split_to_response(split: SplitLine) -> SplitLineResponse:
    """Convert domain SplitLine to response schema."""
    return SplitLineResponse(
        amount=MoneySchema(amount=split.amount.amount, currency=split.amount.currency),
        category_id=str(split.category_id) if split.category_id else None,
        transfer_account_id=str(split.transfer_account_id) if split.transfer_account_id else None,
        memo=split.memo,
    )


def _transaction_to_response(txn) -> TransactionResponse:
    """Convert domain Transaction to response schema."""
    return TransactionResponse(
        id=str(txn.id),
        user_id=str(txn.user_id),
        account_id=str(txn.account_id),
        effective_date=txn.effective_date,
        posted_date=txn.posted_date,
        amount=MoneySchema(amount=txn.amount.amount, currency=txn.amount.currency),
        status=txn.status,
        source=txn.source,
        splits=[_split_to_response(s) for s in txn.splits],
        payee_id=str(txn.payee_id) if txn.payee_id else None,
        payee_name=txn.payee_name,
        memo=txn.memo,
        check_number=txn.check_number,
        is_mirror=txn.is_mirror,
        source_transaction_id=str(txn.source_transaction_id) if txn.source_transaction_id else None,
        created_at=txn.created_at,
        updated_at=txn.updated_at,
    )


@router.post("", response_model=TransactionResponse, status_code=status.HTTP_201_CREATED)
def create_transaction(
    request: CreateTransactionRequest,
    service: TransactionService = Depends(get_transaction_service),
    user_id: UserId = Depends(get_current_user_id),
):
    """Create a new transaction with splits."""
    # Convert request to domain objects
    account_id = AccountId.from_string(request.account_id)
    amount = Money(request.amount.amount, request.amount.currency)

    splits = []
    for split_req in request.splits:
        split = SplitLine(
            amount=Money(split_req.amount.amount, split_req.amount.currency),
            category_id=CategoryId.from_string(split_req.category_id) if split_req.category_id else None,
            transfer_account_id=AccountId.from_string(split_req.transfer_account_id) if split_req.transfer_account_id else None,
            memo=split_req.memo,
        )
        splits.append(split)

    result = service.create_transaction(
        user_id=user_id,
        account_id=account_id,
        effective_date=request.effective_date,
        amount=amount,
        splits=splits,
        payee_name=request.payee_name,
        memo=request.memo,
        check_number=request.check_number,
        posted_date=request.posted_date,
    )

    if isinstance(result, TransactionError):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail={"code": result.code, "message": result.message},
        )

    return _transaction_to_response(result)


@router.get("", response_model=TransactionListResponse)
def list_transactions(
    account_id: str | None = Query(default=None),
    category_id: str | None = Query(default=None),
    date_from: date | None = Query(default=None),
    date_to: date | None = Query(default=None),
    amount_min: Decimal | None = Query(default=None),
    amount_max: Decimal | None = Query(default=None),
    search: str | None = Query(default=None, description="Full-text search"),
    limit: int = Query(default=100, le=500),
    offset: int = Query(default=0, ge=0),
    service: TransactionService = Depends(get_transaction_service),
    user_id: UserId = Depends(get_current_user_id),
):
    """List transactions with filtering and search."""
    # If search provided, use full-text search
    if search:
        txns = service.search_transactions(user_id, search, limit)
        return TransactionListResponse(
            transactions=[_transaction_to_response(t) for t in txns],
            total=len(txns),
            limit=limit,
            offset=0,
        )

    # Otherwise use filter
    acct_id = AccountId.from_string(account_id) if account_id else None
    cat_id = CategoryId.from_string(category_id) if category_id else None

    txns = service.filter_transactions(
        user_id=user_id,
        account_id=acct_id,
        category_id=cat_id,
        date_from=date_from,
        date_to=date_to,
        amount_min=amount_min,
        amount_max=amount_max,
        limit=limit,
        offset=offset,
    )

    return TransactionListResponse(
        transactions=[_transaction_to_response(t) for t in txns],
        total=len(txns),  # TODO: Return actual total count for pagination
        limit=limit,
        offset=offset,
    )


@router.get("/{transaction_id}", response_model=TransactionResponse)
def get_transaction(
    transaction_id: str,
    service: TransactionService = Depends(get_transaction_service),
    user_id: UserId = Depends(get_current_user_id),
):
    """Get a transaction by ID."""
    txn_id = TransactionId.from_string(transaction_id)
    result = service.get_transaction(user_id, txn_id)

    if isinstance(result, TransactionError):
        if result.code == "NOT_FOUND":
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Transaction not found")
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail={"code": result.code, "message": result.message},
        )

    return _transaction_to_response(result)


@router.patch("/{transaction_id}", response_model=TransactionResponse)
def update_transaction(
    transaction_id: str,
    request: UpdateTransactionRequest,
    service: TransactionService = Depends(get_transaction_service),
    user_id: UserId = Depends(get_current_user_id),
):
    """Update transaction fields.

    Supports two modes:
    1. Metadata only: Update dates, memo, payee, check_number (no splits/amount)
    2. Full update: Include splits and amount to change financial allocations

    When updating splits, mirror transactions are automatically synced.
    """
    txn_id = TransactionId.from_string(transaction_id)

    # Handle splits update if provided
    if request.splits is not None:
        # Validate that amount is also provided
        if request.amount is None:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail={"code": "MISSING_AMOUNT", "message": "amount is required when updating splits"},
            )

        # Convert splits to domain objects
        new_splits = []
        for split_req in request.splits:
            split = SplitLine(
                amount=Money(split_req.amount.amount, split_req.amount.currency),
                category_id=CategoryId.from_string(split_req.category_id) if split_req.category_id else None,
                transfer_account_id=AccountId.from_string(split_req.transfer_account_id) if split_req.transfer_account_id else None,
                memo=split_req.memo,
            )
            new_splits.append(split)

        new_amount = Money(request.amount.amount, request.amount.currency)

        result = service.update_transaction_splits(user_id, txn_id, new_splits, new_amount)
        if isinstance(result, TransactionError):
            status_code = status.HTTP_400_BAD_REQUEST
            if result.code == "NOT_FOUND":
                status_code = status.HTTP_404_NOT_FOUND
            raise HTTPException(
                status_code=status_code,
                detail={"code": result.code, "message": result.message},
            )

    # Update dates if provided
    if request.effective_date or request.posted_date:
        result = service.update_transaction_dates(
            user_id, txn_id, request.effective_date, request.posted_date
        )
        if isinstance(result, TransactionError):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail={"code": result.code, "message": result.message},
            )

    # Update memo if provided
    if request.memo is not None:
        result = service.update_transaction_memo(user_id, txn_id, request.memo)
        if isinstance(result, TransactionError):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail={"code": result.code, "message": result.message},
            )

    # Fetch updated transaction
    result = service.get_transaction(user_id, txn_id)
    if isinstance(result, TransactionError):
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Transaction not found")

    return _transaction_to_response(result)


@router.post("/{transaction_id}/clear", response_model=TransactionResponse)
def mark_transaction_cleared(
    transaction_id: str,
    request: MarkClearedRequest | None = None,
    service: TransactionService = Depends(get_transaction_service),
    user_id: UserId = Depends(get_current_user_id),
):
    """Mark transaction as cleared."""
    txn_id = TransactionId.from_string(transaction_id)
    posted_date = request.posted_date if request else None

    result = service.mark_transaction_cleared(user_id, txn_id, posted_date)

    if isinstance(result, TransactionError):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail={"code": result.code, "message": result.message},
        )

    return _transaction_to_response(result)


@router.post("/{transaction_id}/reconcile", response_model=TransactionResponse)
def mark_transaction_reconciled(
    transaction_id: str,
    service: TransactionService = Depends(get_transaction_service),
    user_id: UserId = Depends(get_current_user_id),
):
    """Mark transaction as reconciled."""
    txn_id = TransactionId.from_string(transaction_id)

    result = service.mark_transaction_reconciled(user_id, txn_id)

    if isinstance(result, TransactionError):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail={"code": result.code, "message": result.message},
        )

    return _transaction_to_response(result)


@router.delete("/{transaction_id}", status_code=status.HTTP_204_NO_CONTENT)
def delete_transaction(
    transaction_id: str,
    service: TransactionService = Depends(get_transaction_service),
    user_id: UserId = Depends(get_current_user_id),
):
    """Delete a transaction (and its mirrors if source)."""
    txn_id = TransactionId.from_string(transaction_id)

    result = service.delete_transaction(user_id, txn_id)

    if isinstance(result, TransactionError):
        status_code = status.HTTP_400_BAD_REQUEST
        if result.code == "NOT_FOUND":
            status_code = status.HTTP_404_NOT_FOUND
        raise HTTPException(
            status_code=status_code,
            detail={"code": result.code, "message": result.message},
        )
```
  </action>
  <verify>
```bash
cd /workspace && python -c "
from src.adapters.api.routes.categories import router as cat_router
from src.adapters.api.routes.transactions import router as txn_router

# Verify routers have expected routes
cat_routes = [r.path for r in cat_router.routes]
assert '' in cat_routes or '/' in cat_routes  # POST /categories
assert '/tree' in cat_routes  # GET /categories/tree
assert '/{category_id}' in cat_routes

txn_routes = [r.path for r in txn_router.routes]
assert '' in txn_routes or '/' in txn_routes  # POST /transactions
assert '/{transaction_id}' in txn_routes
assert '/{transaction_id}/clear' in txn_routes
assert '/{transaction_id}/reconcile' in txn_routes

print(f'Category routes: {cat_routes}')
print(f'Transaction routes: {txn_routes}')
print('All routes verified!')
"
```
  </verify>
  <done>
API routes created for categories (CRUD, tree structure) and transactions (CRUD, search, filter, status updates, split updates) with proper error handling. PATCH /transactions/{id} now supports optional splits/amount for full financial updates.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update dependencies and register routers</name>
  <files>
    src/adapters/api/dependencies.py
    src/adapters/api/app.py
  </files>
  <action>
Update dependencies.py to add service factory functions:

```python
# Add imports
from src.application.services.category_service import CategoryService
from src.application.services.transaction_service import TransactionService


def get_category_service(
    uow: UnitOfWork = Depends(get_unit_of_work),
) -> CategoryService:
    """Dependency to get CategoryService."""
    return CategoryService(uow)


def get_transaction_service(
    uow: UnitOfWork = Depends(get_unit_of_work),
) -> TransactionService:
    """Dependency to get TransactionService."""
    return TransactionService(uow)
```

Update app.py to include new routers:

```python
# Add imports
from src.adapters.api.routes.categories import router as categories_router
from src.adapters.api.routes.transactions import router as transactions_router

# In create_app() or after app creation, add:
app.include_router(categories_router, prefix="/api/v1")
app.include_router(transactions_router, prefix="/api/v1")
```
  </action>
  <verify>
```bash
cd /workspace && python -c "
from src.adapters.api.dependencies import get_category_service, get_transaction_service
from src.adapters.api.app import create_app

# Verify dependencies exist
assert callable(get_category_service)
assert callable(get_transaction_service)
print('Dependencies verified!')

# Create app and check routes
app = create_app()
routes = [r.path for r in app.routes]

# Check that category and transaction routes are registered
api_routes = [r for r in routes if '/api/v1' in r]
print(f'API v1 routes: {api_routes}')

# At minimum, check the prefixes are present
route_str = str(routes)
assert 'categories' in route_str.lower() or any('categor' in r for r in routes), 'Category routes not found'
assert 'transactions' in route_str.lower() or any('transact' in r for r in routes), 'Transaction routes not found'

print('App routes verified!')
"
```
  </verify>
  <done>
Dependencies added for CategoryService and TransactionService. Routers registered in FastAPI app with /api/v1 prefix.
  </done>
</task>

</tasks>

<verification>
Start the API server and verify endpoints are accessible:

```bash
cd /workspace && python -c "
from fastapi.testclient import TestClient
from src.adapters.api.app import create_app

app = create_app()
client = TestClient(app)

# Check OpenAPI docs include new endpoints
response = client.get('/docs')
assert response.status_code == 200

# Check categories endpoint exists
response = client.get('/api/v1/categories')
print(f'GET /api/v1/categories: {response.status_code}')

# Check transactions endpoint exists
response = client.get('/api/v1/transactions')
print(f'GET /api/v1/transactions: {response.status_code}')

print('API endpoints accessible!')
"
```

Run lint-imports:

```bash
cd /workspace && lint-imports
```
</verification>

<success_criteria>
1. Pydantic schemas validate transaction and category inputs
2. POST /api/v1/categories creates categories
3. GET /api/v1/categories returns user's categories
4. GET /api/v1/categories/tree returns hierarchical structure
5. POST /api/v1/transactions creates transactions with splits
6. GET /api/v1/transactions supports search and filter parameters
7. PATCH /api/v1/transactions/{id} can update splits and amount
8. PATCH /api/v1/transactions/{id} syncs mirror transactions when splits change
9. POST /api/v1/transactions/{id}/clear marks cleared
10. POST /api/v1/transactions/{id}/reconcile marks reconciled
11. DELETE /api/v1/transactions/{id} deletes transaction
12. API returns proper error responses with codes
</success_criteria>

<output>
After completion, create `.planning/phases/03-transaction-domain/03-06-SUMMARY.md`
</output>
