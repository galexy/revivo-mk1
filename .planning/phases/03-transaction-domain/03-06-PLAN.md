---
phase: 03-transaction-domain
plan: 06
type: execute
wave: 5
depends_on: ["03-05"]
files_modified:
  - src/adapters/api/schemas/transaction.py
  - src/adapters/api/schemas/category.py
  - src/adapters/api/routes/transactions.py
  - src/adapters/api/routes/categories.py
  - src/adapters/api/app.py
  - src/adapters/api/dependencies.py
autonomous: true

must_haves:
  truths:
    - "POST /api/v1/transactions creates expense, income, transfer, or split"
    - "GET /api/v1/transactions supports filtering by account, category, date range"
    - "GET /api/v1/transactions/search performs full-text search"
    - "POST /api/v1/transactions/{id}/attachments handles file upload"
    - "GET /api/v1/categories returns user's category hierarchy"
  artifacts:
    - path: "src/adapters/api/routes/transactions.py"
      provides: "Transaction REST endpoints"
      contains: "router = APIRouter"
      min_lines: 100
    - path: "src/adapters/api/routes/categories.py"
      provides: "Category REST endpoints"
      contains: "router = APIRouter"
    - path: "src/adapters/api/schemas/transaction.py"
      provides: "Pydantic schemas for transactions"
      contains: "class CreateExpenseRequest"
  key_links:
    - from: "src/adapters/api/routes/transactions.py"
      to: "src/application/services/transaction_service.py"
      via: "service dependency"
      pattern: "TransactionService"
    - from: "src/adapters/api/app.py"
      to: "src/adapters/api/routes/transactions.py"
      via: "router include"
      pattern: "include_router.*transactions"
---

<objective>
Create REST API endpoints for Transaction and Category domains

Purpose: Expose Transaction domain functionality via REST API following established patterns from accounts router. Includes file upload for attachments, filtering, and full-text search.

Output: Complete REST API for transactions and categories
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/03-transaction-domain/03-RESEARCH.md

@src/adapters/api/routes/accounts.py
@src/adapters/api/schemas/account.py
@src/adapters/api/app.py
@src/adapters/api/dependencies.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Pydantic schemas for transactions and categories</name>
  <files>
src/adapters/api/schemas/transaction.py
src/adapters/api/schemas/category.py
  </files>
  <action>
Create transaction.py following research document patterns:

```python
from datetime import datetime
from decimal import Decimal
from pydantic import BaseModel, Field

from src.domain.model.transaction_types import TransactionStatus, TransactionType


class MoneySchema(BaseModel):
    """Schema for money amounts."""
    amount: Decimal = Field(..., decimal_places=4)
    currency: str = Field(default="USD", min_length=3, max_length=3)


class SplitLineSchema(BaseModel):
    """Schema for a split line."""
    amount: MoneySchema
    category_id: str | None = None
    memo: str | None = Field(default=None, max_length=500)


# --- Request Schemas ---

class CreateExpenseRequest(BaseModel):
    """Request to create an expense transaction."""
    account_id: str = Field(..., description="Account ID for the expense")
    amount: MoneySchema = Field(..., description="Expense amount (positive)")
    date: datetime = Field(..., description="Transaction date")
    category_id: str | None = Field(default=None, description="Category ID")
    payee: str | None = Field(default=None, max_length=255)
    description: str | None = Field(default=None, max_length=2000)


class CreateIncomeRequest(BaseModel):
    """Request to create an income transaction."""
    account_id: str
    amount: MoneySchema
    date: datetime
    category_id: str | None = None
    payee: str | None = Field(default=None, max_length=255)
    description: str | None = Field(default=None, max_length=2000)


class CreateTransferRequest(BaseModel):
    """Request to create a transfer between accounts."""
    from_account_id: str
    to_account_id: str
    amount: MoneySchema
    date: datetime
    description: str | None = Field(default=None, max_length=2000)


class CreateSplitExpenseRequest(BaseModel):
    """Request to create a split expense."""
    account_id: str
    total_amount: MoneySchema
    split_lines: list[SplitLineSchema] = Field(..., min_length=1)
    date: datetime
    payee: str | None = Field(default=None, max_length=255)
    description: str | None = Field(default=None, max_length=2000)


class UpdateTransactionRequest(BaseModel):
    """Request to update a transaction."""
    payee: str | None = None
    category_id: str | None = None
    date: datetime | None = None
    description: str | None = None
    # Note: amount updates are complex for splits, handle separately


# --- Response Schemas ---

class TransactionResponse(BaseModel):
    """Response schema for a single transaction."""
    id: str
    user_id: str
    transaction_type: TransactionType
    status: TransactionStatus
    date: datetime
    amount: MoneySchema
    account_id: str
    transfer_account_id: str | None = None
    category_id: str | None = None
    split_lines: list[SplitLineSchema] = []
    payee: str | None
    description: str | None
    reference_number: str | None = None
    attachment_count: int = 0
    created_at: datetime
    updated_at: datetime

    model_config = {"from_attributes": True}


class TransactionListResponse(BaseModel):
    """Response for listing transactions."""
    transactions: list[TransactionResponse]
    total: int
    limit: int
    offset: int


class AttachmentResponse(BaseModel):
    """Response schema for an attachment."""
    id: str
    transaction_id: str
    filename: str
    content_type: str
    size_bytes: int
    created_at: datetime

    model_config = {"from_attributes": True}
```

Create category.py:

```python
from datetime import datetime
from pydantic import BaseModel, Field


class CreateCategoryRequest(BaseModel):
    """Request to create a category."""
    name: str = Field(..., min_length=1, max_length=255)
    category_type: str = Field(default="expense", pattern="^(expense|income|both)$")
    parent_id: str | None = None


class UpdateCategoryRequest(BaseModel):
    """Request to update a category."""
    name: str | None = Field(default=None, min_length=1, max_length=255)
    parent_id: str | None = None  # Set to None to make root


class CategoryResponse(BaseModel):
    """Response schema for a category."""
    id: str
    user_id: str
    name: str
    category_type: str
    parent_id: str | None
    is_system: bool
    sort_order: int
    icon: str | None
    created_at: datetime
    updated_at: datetime

    model_config = {"from_attributes": True}


class CategoryListResponse(BaseModel):
    """Response for listing categories."""
    categories: list[CategoryResponse]
```
  </action>
  <verify>
Run: `python -c "
from src.adapters.api.schemas.transaction import (
    CreateExpenseRequest, CreateTransferRequest, CreateSplitExpenseRequest,
    TransactionResponse, AttachmentResponse, MoneySchema
)
from src.adapters.api.schemas.category import (
    CreateCategoryRequest, CategoryResponse
)
print('Transaction schemas OK')
print('Category schemas OK')
"`
  </verify>
  <done>Pydantic schemas for transactions and categories created</done>
</task>

<task type="auto">
  <name>Task 2: Create transaction and category API routes</name>
  <files>
src/adapters/api/routes/transactions.py
src/adapters/api/routes/categories.py
  </files>
  <action>
Create transactions.py following accounts.py pattern:

```python
from datetime import datetime
from typing import Annotated

from fastapi import APIRouter, Depends, File, HTTPException, Query, UploadFile, status

from src.adapters.api.dependencies import get_transaction_service, get_user_id
from src.adapters.api.schemas.transaction import (
    AttachmentResponse,
    CreateExpenseRequest,
    CreateIncomeRequest,
    CreateSplitExpenseRequest,
    CreateTransferRequest,
    TransactionListResponse,
    TransactionResponse,
    UpdateTransactionRequest,
)
from src.application.services.transaction_service import TransactionError, TransactionService
from src.domain.model.entity_id import AccountId, CategoryId, TransactionId, UserId
from src.domain.model.money import Money
from src.domain.model.split_line import SplitLine

router = APIRouter(prefix="/api/v1/transactions", tags=["transactions"])


def _handle_error(error: TransactionError) -> None:
    """Convert service error to HTTP exception."""
    status_map = {
        "ACCOUNT_NOT_FOUND": status.HTTP_404_NOT_FOUND,
        "TRANSACTION_NOT_FOUND": status.HTTP_404_NOT_FOUND,
        "CATEGORY_NOT_FOUND": status.HTTP_404_NOT_FOUND,
        "ACCOUNT_NOT_OWNED": status.HTTP_403_FORBIDDEN,
        "TRANSACTION_NOT_OWNED": status.HTTP_403_FORBIDDEN,
        "CATEGORY_NOT_OWNED": status.HTTP_403_FORBIDDEN,
        "INSUFFICIENT_BALANCE": status.HTTP_400_BAD_REQUEST,
    }
    raise HTTPException(
        status_code=status_map.get(error.code, status.HTTP_400_BAD_REQUEST),
        detail={"code": error.code, "message": error.message},
    )


@router.post("/expense", response_model=TransactionResponse, status_code=status.HTTP_201_CREATED)
def create_expense(
    request: CreateExpenseRequest,
    service: Annotated[TransactionService, Depends(get_transaction_service)],
    user_id: Annotated[UserId, Depends(get_user_id)],
):
    """Create an expense transaction (TRAN-01)."""
    result = service.create_expense(
        user_id=user_id,
        account_id=AccountId.from_string(request.account_id),
        amount=Money(request.amount.amount, request.amount.currency),
        date=request.date,
        category_id=CategoryId.from_string(request.category_id) if request.category_id else None,
        payee=request.payee,
        description=request.description,
    )
    if isinstance(result, TransactionError):
        _handle_error(result)
    return _to_response(result)


@router.post("/income", response_model=TransactionResponse, status_code=status.HTTP_201_CREATED)
def create_income(...):
    """Create an income transaction."""

@router.post("/transfer", response_model=TransactionResponse, status_code=status.HTTP_201_CREATED)
def create_transfer(
    request: CreateTransferRequest,
    service: Annotated[TransactionService, Depends(get_transaction_service)],
    user_id: Annotated[UserId, Depends(get_user_id)],
):
    """Create a transfer between accounts (TRAN-06)."""

@router.post("/split", response_model=TransactionResponse, status_code=status.HTTP_201_CREATED)
def create_split_expense(
    request: CreateSplitExpenseRequest,
    ...
):
    """Create a split expense transaction (TRAN-05)."""

@router.get("", response_model=TransactionListResponse)
def list_transactions(
    service: Annotated[TransactionService, Depends(get_transaction_service)],
    user_id: Annotated[UserId, Depends(get_user_id)],
    account_id: str | None = Query(default=None),
    category_id: str | None = Query(default=None),
    date_from: datetime | None = Query(default=None),
    date_to: datetime | None = Query(default=None),
    limit: int = Query(default=100, le=500),
    offset: int = Query(default=0, ge=0),
):
    """List and filter transactions (TRAN-10, TRAN-11)."""

@router.get("/search", response_model=TransactionListResponse)
def search_transactions(
    service: Annotated[TransactionService, Depends(get_transaction_service)],
    user_id: Annotated[UserId, Depends(get_user_id)],
    q: str = Query(..., min_length=1, description="Search query"),
    limit: int = Query(default=50, le=200),
    offset: int = Query(default=0, ge=0),
):
    """Full-text search on transactions (TRAN-09)."""

@router.get("/{transaction_id}", response_model=TransactionResponse)
def get_transaction(...):
    """Get a single transaction."""

@router.patch("/{transaction_id}", response_model=TransactionResponse)
def update_transaction(
    transaction_id: str,
    request: UpdateTransactionRequest,
    ...
):
    """Update a transaction (TRAN-02)."""

@router.delete("/{transaction_id}", status_code=status.HTTP_204_NO_CONTENT)
def delete_transaction(...):
    """Delete a transaction (TRAN-03)."""

@router.post("/{transaction_id}/attachments", response_model=AttachmentResponse, status_code=status.HTTP_201_CREATED)
async def add_attachment(
    transaction_id: str,
    file: UploadFile = File(...),
    service: Annotated[TransactionService, Depends(get_transaction_service)],
    user_id: Annotated[UserId, Depends(get_user_id)],
):
    """Add attachment to transaction (TRAN-07)."""
    result = await service.add_attachment(
        user_id=user_id,
        transaction_id=TransactionId.from_string(transaction_id),
        file=file.file,
        filename=file.filename or "attachment",
        content_type=file.content_type or "application/octet-stream",
    )
    if isinstance(result, TransactionError):
        _handle_error(result)
    return AttachmentResponse.model_validate(result)

@router.get("/{transaction_id}/attachments", response_model=list[AttachmentResponse])
def get_attachments(...):
    """Get all attachments for a transaction (TRAN-08)."""


def _to_response(txn) -> TransactionResponse:
    """Convert domain Transaction to response schema."""
    # Build response with split_lines, attachment_count
```

Create categories.py with similar CRUD endpoints:
- POST /api/v1/categories - Create category
- GET /api/v1/categories - List user's categories
- GET /api/v1/categories/{id} - Get single category
- PATCH /api/v1/categories/{id} - Update category
- DELETE /api/v1/categories/{id} - Delete category
  </action>
  <verify>
Run: `python -c "
from src.adapters.api.routes.transactions import router as txn_router
from src.adapters.api.routes.categories import router as cat_router
print('Transaction routes:', [r.path for r in txn_router.routes])
print('Category routes:', [r.path for r in cat_router.routes])
"`
  </verify>
  <done>Transaction and Category API routes created</done>
</task>

<task type="auto">
  <name>Task 3: Update app.py and dependencies.py</name>
  <files>
src/adapters/api/app.py
src/adapters/api/dependencies.py
  </files>
  <action>
Update dependencies.py to add new service dependencies:

```python
from typing import Annotated, Generator

from fastapi import Depends

from src.adapters.persistence.orm.database import sync_session_factory
from src.adapters.persistence.unit_of_work import SqlAlchemyUnitOfWork
from src.adapters.storage.file_storage import LocalFileStorage
from src.application.services.account_service import AccountService
from src.application.services.category_service import CategoryService
from src.application.services.transaction_service import TransactionService
from src.domain.model.entity_id import UserId

# File storage singleton (configure upload dir from settings)
_file_storage = LocalFileStorage("/app/uploads")


def get_uow() -> Generator[SqlAlchemyUnitOfWork, None, None]:
    uow = SqlAlchemyUnitOfWork(sync_session_factory)
    yield uow


def get_account_service(
    uow: Annotated[SqlAlchemyUnitOfWork, Depends(get_uow)],
) -> AccountService:
    return AccountService(uow)


def get_transaction_service(
    uow: Annotated[SqlAlchemyUnitOfWork, Depends(get_uow)],
) -> TransactionService:
    return TransactionService(uow, _file_storage)


def get_category_service(
    uow: Annotated[SqlAlchemyUnitOfWork, Depends(get_uow)],
) -> CategoryService:
    return CategoryService(uow)


def get_user_id() -> UserId:
    """Placeholder for auth - returns dev user ID.

    TODO: Replace with actual auth in Phase 4.
    """
    return UserId.from_string("user_01h455vb4pex5vsknk084sn02q")
```

Update app.py to include new routers:

```python
from fastapi import FastAPI

from src.adapters.api.routes import accounts, categories, transactions

app = FastAPI(
    title="Personal Finance API",
    description="API for managing personal finances",
    version="0.1.0",
)

# Include routers
app.include_router(accounts.router)
app.include_router(transactions.router)
app.include_router(categories.router)


@app.get("/health")
def health_check():
    return {"status": "healthy"}
```

Also create the uploads directory structure:
```bash
mkdir -p /app/uploads
```
Or make it configurable via environment variable.
  </action>
  <verify>
Run: `python -c "
from src.adapters.api.app import app
routes = [r.path for r in app.routes if hasattr(r, 'path')]
print('API routes:', sorted(routes))
"`
Expected: Shows /api/v1/accounts/*, /api/v1/transactions/*, /api/v1/categories/* routes
  </verify>
  <done>App updated with transaction and category routers</done>
</task>

</tasks>

<verification>
All tasks completed:
1. Pydantic schemas validate correctly
2. Transaction routes: POST expense/income/transfer/split, GET list/search, PATCH, DELETE
3. Attachment routes: POST upload, GET list
4. Category routes: CRUD operations
5. `curl http://localhost:8000/docs` shows OpenAPI docs
6. `pytest tests/` passes
</verification>

<success_criteria>
- POST /api/v1/transactions/expense creates expense
- POST /api/v1/transactions/transfer creates transfer
- POST /api/v1/transactions/split creates split expense
- GET /api/v1/transactions?account_id=xxx filters by account
- GET /api/v1/transactions/search?q=grocery searches
- POST /api/v1/transactions/{id}/attachments handles file upload
- GET /api/v1/categories returns category list
- OpenAPI docs at /docs show all endpoints
</success_criteria>

<output>
After completion, create `.planning/phases/03-transaction-domain/03-06-SUMMARY.md`
</output>
