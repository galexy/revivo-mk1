---
phase: 03-transaction-domain
plan: 07
type: execute
wave: 6
depends_on: ["03-06"]
files_modified:
  - tests/integration/test_transaction_api.py
  - tests/integration/test_category_api.py
autonomous: false

must_haves:
  truths:
    - "Integration tests verify transaction CRUD via API"
    - "Integration tests verify category hierarchy works"
    - "Integration tests verify transfer creates mirror transaction"
    - "Integration tests verify split validation"
    - "All Phase 3 success criteria can be manually verified"
  artifacts:
    - path: "tests/integration/test_transaction_api.py"
      provides: "Transaction API integration tests"
      contains: "def test_create_transaction"
    - path: "tests/integration/test_category_api.py"
      provides: "Category API integration tests"
      contains: "def test_create_category"
  key_links:
    - from: "tests/integration/test_transaction_api.py"
      to: "API endpoints"
      via: "FastAPI TestClient"
      pattern: "TestClient"
---

<objective>
Create integration tests for Transaction and Category APIs and verify all Phase 3 success criteria.

Purpose: Ensure the complete transaction domain works end-to-end, from API to database, with proper validation and business rules.

Output: Passing integration tests and verified Phase 3 success criteria.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-transaction-domain/03-CONTEXT.md
@.planning/phases/03-transaction-domain/03-06-SUMMARY.md

# Existing test patterns
@tests/integration/test_account_api.py
@tests/conftest.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create category API integration tests</name>
  <files>tests/integration/test_category_api.py</files>
  <action>
Create integration tests for Category API following the existing test patterns:

```python
"""Integration tests for Category API endpoints."""
import pytest
from fastapi.testclient import TestClient

from src.adapters.api.app import create_app
from src.domain.model.category import SYSTEM_CATEGORY_UNCATEGORIZED


@pytest.fixture
def client(test_db_session):
    """Create test client with database session."""
    app = create_app()
    with TestClient(app) as client:
        yield client


class TestCategoryAPI:
    """Tests for /api/v1/categories endpoints."""

    def test_list_categories_creates_uncategorized(self, client):
        """GET /categories should create Uncategorized system category if missing."""
        response = client.get("/api/v1/categories")

        assert response.status_code == 200
        data = response.json()
        assert "categories" in data
        assert "total" in data

        # Should have at least Uncategorized
        names = [c["name"] for c in data["categories"]]
        assert SYSTEM_CATEGORY_UNCATEGORIZED in names

        # Verify Uncategorized is marked as system
        uncategorized = next(c for c in data["categories"] if c["name"] == SYSTEM_CATEGORY_UNCATEGORIZED)
        assert uncategorized["is_system"] is True

    def test_create_category(self, client):
        """POST /categories should create a new category."""
        response = client.post(
            "/api/v1/categories",
            json={"name": "Food & Dining", "icon": "üçî"},
        )

        assert response.status_code == 201
        data = response.json()
        assert data["name"] == "Food & Dining"
        assert data["icon"] == "üçî"
        assert data["is_system"] is False
        assert data["parent_id"] is None
        assert "id" in data
        assert data["id"].startswith("cat_")

    def test_create_subcategory(self, client):
        """POST /categories should create subcategory with parent."""
        # Create parent
        parent_response = client.post(
            "/api/v1/categories",
            json={"name": "Food & Dining"},
        )
        assert parent_response.status_code == 201
        parent_id = parent_response.json()["id"]

        # Create child
        child_response = client.post(
            "/api/v1/categories",
            json={"name": "Restaurants", "parent_id": parent_id},
        )

        assert child_response.status_code == 201
        data = child_response.json()
        assert data["name"] == "Restaurants"
        assert data["parent_id"] == parent_id

    def test_get_category_tree(self, client):
        """GET /categories/tree should return hierarchical structure."""
        # Create parent and child
        parent_response = client.post(
            "/api/v1/categories",
            json={"name": "Entertainment"},
        )
        parent_id = parent_response.json()["id"]

        client.post(
            "/api/v1/categories",
            json={"name": "Movies", "parent_id": parent_id},
        )
        client.post(
            "/api/v1/categories",
            json={"name": "Games", "parent_id": parent_id},
        )

        # Get tree
        response = client.get("/api/v1/categories/tree")

        assert response.status_code == 200
        data = response.json()
        assert "root" in data
        assert "children" in data

        # Entertainment should be in root
        root_names = [c["name"] for c in data["root"]]
        assert "Entertainment" in root_names

        # Movies and Games should be children of Entertainment
        if parent_id in data["children"]:
            child_names = [c["name"] for c in data["children"][parent_id]]
            assert "Movies" in child_names
            assert "Games" in child_names

    def test_cannot_delete_system_category(self, client):
        """DELETE system category should fail."""
        # First get categories to find Uncategorized
        list_response = client.get("/api/v1/categories")
        categories = list_response.json()["categories"]
        uncategorized = next(c for c in categories if c["is_system"])

        # Try to delete
        response = client.delete(f"/api/v1/categories/{uncategorized['id']}")

        assert response.status_code == 400
        assert "CANNOT_DELETE_SYSTEM" in response.json()["detail"]["code"]

    def test_cannot_modify_system_category(self, client):
        """PATCH system category should fail."""
        # Get Uncategorized
        list_response = client.get("/api/v1/categories")
        categories = list_response.json()["categories"]
        uncategorized = next(c for c in categories if c["is_system"])

        # Try to rename
        response = client.patch(
            f"/api/v1/categories/{uncategorized['id']}",
            json={"name": "New Name"},
        )

        assert response.status_code == 400

    def test_update_category_name(self, client):
        """PATCH /categories/{id} should update name."""
        # Create category
        create_response = client.post(
            "/api/v1/categories",
            json={"name": "Old Name"},
        )
        category_id = create_response.json()["id"]

        # Update
        response = client.patch(
            f"/api/v1/categories/{category_id}",
            json={"name": "New Name"},
        )

        assert response.status_code == 200
        assert response.json()["name"] == "New Name"

    def test_delete_category(self, client):
        """DELETE /categories/{id} should delete category."""
        # Create category
        create_response = client.post(
            "/api/v1/categories",
            json={"name": "To Delete"},
        )
        category_id = create_response.json()["id"]

        # Delete
        response = client.delete(f"/api/v1/categories/{category_id}")
        assert response.status_code == 204

        # Verify gone
        get_response = client.get(f"/api/v1/categories/{category_id}")
        assert get_response.status_code == 404
```
  </action>
  <verify>
```bash
cd /workspace && pytest tests/integration/test_category_api.py -v --tb=short -x 2>&1 | head -50
```
  </verify>
  <done>
Category API integration tests created covering CRUD operations, hierarchy, and system category protection.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create transaction API integration tests</name>
  <files>tests/integration/test_transaction_api.py</files>
  <action>
Create comprehensive integration tests for Transaction API:

```python
"""Integration tests for Transaction API endpoints."""
from datetime import date
from decimal import Decimal

import pytest
from fastapi.testclient import TestClient

from src.adapters.api.app import create_app
from src.domain.model.transaction_types import TransactionStatus


@pytest.fixture
def client(test_db_session):
    """Create test client with database session."""
    app = create_app()
    with TestClient(app) as client:
        yield client


@pytest.fixture
def test_account(client):
    """Create a test account for transactions."""
    response = client.post(
        "/api/v1/accounts",
        json={
            "name": "Test Checking",
            "account_type": "checking",
            "opening_balance": {"amount": "1000.00", "currency": "USD"},
        },
    )
    assert response.status_code == 201
    return response.json()


@pytest.fixture
def test_category(client):
    """Create a test category for transactions."""
    response = client.post(
        "/api/v1/categories",
        json={"name": "Groceries"},
    )
    assert response.status_code == 201
    return response.json()


class TestTransactionAPI:
    """Tests for /api/v1/transactions endpoints."""

    def test_create_simple_expense(self, client, test_account, test_category):
        """POST /transactions should create expense with single split."""
        response = client.post(
            "/api/v1/transactions",
            json={
                "account_id": test_account["id"],
                "effective_date": date.today().isoformat(),
                "amount": {"amount": "-50.00", "currency": "USD"},
                "splits": [
                    {
                        "amount": {"amount": "-50.00", "currency": "USD"},
                        "category_id": test_category["id"],
                        "memo": "Weekly groceries",
                    }
                ],
                "payee_name": "Whole Foods",
                "memo": "Weekly shopping",
            },
        )

        assert response.status_code == 201
        data = response.json()
        assert data["id"].startswith("txn_")
        assert data["account_id"] == test_account["id"]
        assert Decimal(data["amount"]["amount"]) == Decimal("-50.00")
        assert data["payee_name"] == "Whole Foods"
        assert len(data["splits"]) == 1
        assert data["splits"][0]["category_id"] == test_category["id"]
        assert data["status"] == "pending"
        assert data["is_mirror"] is False

    def test_create_split_transaction(self, client, test_account):
        """POST /transactions should create multi-split transaction."""
        # Create two categories
        cat1 = client.post("/api/v1/categories", json={"name": "Food"}).json()
        cat2 = client.post("/api/v1/categories", json={"name": "Household"}).json()

        response = client.post(
            "/api/v1/transactions",
            json={
                "account_id": test_account["id"],
                "effective_date": date.today().isoformat(),
                "amount": {"amount": "-100.00", "currency": "USD"},
                "splits": [
                    {
                        "amount": {"amount": "-70.00", "currency": "USD"},
                        "category_id": cat1["id"],
                        "memo": "Food items",
                    },
                    {
                        "amount": {"amount": "-30.00", "currency": "USD"},
                        "category_id": cat2["id"],
                        "memo": "Household items",
                    },
                ],
                "payee_name": "Target",
            },
        )

        assert response.status_code == 201
        data = response.json()
        assert len(data["splits"]) == 2
        split_amounts = [Decimal(s["amount"]["amount"]) for s in data["splits"]]
        assert Decimal("-70.00") in split_amounts
        assert Decimal("-30.00") in split_amounts

    def test_create_transfer_creates_mirror(self, client, test_account):
        """POST /transactions with transfer split should create mirror."""
        # Create second account
        savings = client.post(
            "/api/v1/accounts",
            json={
                "name": "Savings",
                "account_type": "savings",
                "opening_balance": {"amount": "0.00", "currency": "USD"},
            },
        ).json()

        # Create transfer from checking to savings
        response = client.post(
            "/api/v1/transactions",
            json={
                "account_id": test_account["id"],
                "effective_date": date.today().isoformat(),
                "amount": {"amount": "-500.00", "currency": "USD"},
                "splits": [
                    {
                        "amount": {"amount": "-500.00", "currency": "USD"},
                        "transfer_account_id": savings["id"],
                        "memo": "Monthly savings transfer",
                    }
                ],
                "memo": "Transfer to savings",
            },
        )

        assert response.status_code == 201
        source_txn = response.json()
        assert source_txn["is_mirror"] is False
        assert source_txn["splits"][0]["transfer_account_id"] == savings["id"]

        # Check for mirror in savings account
        savings_txns = client.get(
            f"/api/v1/transactions?account_id={savings['id']}"
        ).json()

        # Should have one transaction (the mirror)
        assert len(savings_txns["transactions"]) == 1
        mirror = savings_txns["transactions"][0]
        assert mirror["is_mirror"] is True
        assert mirror["source_transaction_id"] == source_txn["id"]
        # Mirror amount is positive (incoming)
        assert Decimal(mirror["amount"]["amount"]) == Decimal("500.00")

    def test_splits_must_sum_to_amount(self, client, test_account, test_category):
        """POST /transactions should reject if splits don't sum to amount."""
        response = client.post(
            "/api/v1/transactions",
            json={
                "account_id": test_account["id"],
                "effective_date": date.today().isoformat(),
                "amount": {"amount": "-100.00", "currency": "USD"},
                "splits": [
                    {
                        "amount": {"amount": "-50.00", "currency": "USD"},  # Only 50, not 100
                        "category_id": test_category["id"],
                    }
                ],
            },
        )

        assert response.status_code == 400
        assert "INVALID_SPLITS" in response.json()["detail"]["code"]

    def test_cannot_self_transfer(self, client, test_account):
        """POST /transactions should reject transfer to same account."""
        response = client.post(
            "/api/v1/transactions",
            json={
                "account_id": test_account["id"],
                "effective_date": date.today().isoformat(),
                "amount": {"amount": "-100.00", "currency": "USD"},
                "splits": [
                    {
                        "amount": {"amount": "-100.00", "currency": "USD"},
                        "transfer_account_id": test_account["id"],  # Same account!
                    }
                ],
            },
        )

        assert response.status_code == 400
        assert "same account" in response.json()["detail"]["message"].lower()

    def test_get_transaction(self, client, test_account, test_category):
        """GET /transactions/{id} should return transaction with splits."""
        # Create transaction
        create_response = client.post(
            "/api/v1/transactions",
            json={
                "account_id": test_account["id"],
                "effective_date": date.today().isoformat(),
                "amount": {"amount": "-25.00", "currency": "USD"},
                "splits": [
                    {
                        "amount": {"amount": "-25.00", "currency": "USD"},
                        "category_id": test_category["id"],
                    }
                ],
            },
        )
        txn_id = create_response.json()["id"]

        # Get transaction
        response = client.get(f"/api/v1/transactions/{txn_id}")

        assert response.status_code == 200
        data = response.json()
        assert data["id"] == txn_id
        assert len(data["splits"]) == 1

    def test_filter_by_account(self, client, test_account, test_category):
        """GET /transactions?account_id= should filter by account."""
        # Create transaction
        client.post(
            "/api/v1/transactions",
            json={
                "account_id": test_account["id"],
                "effective_date": date.today().isoformat(),
                "amount": {"amount": "-10.00", "currency": "USD"},
                "splits": [{"amount": {"amount": "-10.00", "currency": "USD"}, "category_id": test_category["id"]}],
            },
        )

        # Filter
        response = client.get(f"/api/v1/transactions?account_id={test_account['id']}")

        assert response.status_code == 200
        data = response.json()
        assert data["total"] >= 1
        assert all(t["account_id"] == test_account["id"] for t in data["transactions"])

    def test_filter_by_date_range(self, client, test_account, test_category):
        """GET /transactions?date_from=&date_to= should filter by date."""
        today = date.today()

        # Create transaction for today
        client.post(
            "/api/v1/transactions",
            json={
                "account_id": test_account["id"],
                "effective_date": today.isoformat(),
                "amount": {"amount": "-5.00", "currency": "USD"},
                "splits": [{"amount": {"amount": "-5.00", "currency": "USD"}, "category_id": test_category["id"]}],
            },
        )

        # Filter for today
        response = client.get(
            f"/api/v1/transactions?date_from={today.isoformat()}&date_to={today.isoformat()}"
        )

        assert response.status_code == 200
        data = response.json()
        assert all(t["effective_date"] == today.isoformat() for t in data["transactions"])

    def test_search_transactions(self, client, test_account, test_category):
        """GET /transactions?search= should full-text search."""
        # Create transaction with specific payee
        client.post(
            "/api/v1/transactions",
            json={
                "account_id": test_account["id"],
                "effective_date": date.today().isoformat(),
                "amount": {"amount": "-99.00", "currency": "USD"},
                "splits": [{"amount": {"amount": "-99.00", "currency": "USD"}, "category_id": test_category["id"]}],
                "payee_name": "UniqueSearchPayee123",
            },
        )

        # Search
        response = client.get("/api/v1/transactions?search=UniqueSearchPayee123")

        assert response.status_code == 200
        data = response.json()
        assert data["total"] >= 1
        assert any("UniqueSearchPayee123" in (t.get("payee_name") or "") for t in data["transactions"])

    def test_mark_cleared(self, client, test_account, test_category):
        """POST /transactions/{id}/clear should mark as cleared."""
        # Create transaction
        create_response = client.post(
            "/api/v1/transactions",
            json={
                "account_id": test_account["id"],
                "effective_date": date.today().isoformat(),
                "amount": {"amount": "-15.00", "currency": "USD"},
                "splits": [{"amount": {"amount": "-15.00", "currency": "USD"}, "category_id": test_category["id"]}],
            },
        )
        txn_id = create_response.json()["id"]
        assert create_response.json()["status"] == "pending"

        # Mark cleared
        response = client.post(f"/api/v1/transactions/{txn_id}/clear")

        assert response.status_code == 200
        assert response.json()["status"] == "cleared"

    def test_mark_reconciled(self, client, test_account, test_category):
        """POST /transactions/{id}/reconcile should mark as reconciled."""
        # Create and clear transaction
        create_response = client.post(
            "/api/v1/transactions",
            json={
                "account_id": test_account["id"],
                "effective_date": date.today().isoformat(),
                "amount": {"amount": "-20.00", "currency": "USD"},
                "splits": [{"amount": {"amount": "-20.00", "currency": "USD"}, "category_id": test_category["id"]}],
            },
        )
        txn_id = create_response.json()["id"]

        # Clear first
        client.post(f"/api/v1/transactions/{txn_id}/clear")

        # Then reconcile
        response = client.post(f"/api/v1/transactions/{txn_id}/reconcile")

        assert response.status_code == 200
        assert response.json()["status"] == "reconciled"

    def test_delete_transaction(self, client, test_account, test_category):
        """DELETE /transactions/{id} should delete transaction."""
        # Create transaction
        create_response = client.post(
            "/api/v1/transactions",
            json={
                "account_id": test_account["id"],
                "effective_date": date.today().isoformat(),
                "amount": {"amount": "-30.00", "currency": "USD"},
                "splits": [{"amount": {"amount": "-30.00", "currency": "USD"}, "category_id": test_category["id"]}],
            },
        )
        txn_id = create_response.json()["id"]

        # Delete
        response = client.delete(f"/api/v1/transactions/{txn_id}")
        assert response.status_code == 204

        # Verify gone
        get_response = client.get(f"/api/v1/transactions/{txn_id}")
        assert get_response.status_code == 404

    def test_delete_source_deletes_mirrors(self, client, test_account):
        """DELETE source transaction should also delete its mirrors."""
        # Create savings account
        savings = client.post(
            "/api/v1/accounts",
            json={
                "name": "Savings2",
                "account_type": "savings",
                "opening_balance": {"amount": "0.00", "currency": "USD"},
            },
        ).json()

        # Create transfer
        source = client.post(
            "/api/v1/transactions",
            json={
                "account_id": test_account["id"],
                "effective_date": date.today().isoformat(),
                "amount": {"amount": "-200.00", "currency": "USD"},
                "splits": [
                    {
                        "amount": {"amount": "-200.00", "currency": "USD"},
                        "transfer_account_id": savings["id"],
                    }
                ],
            },
        ).json()

        # Get mirror
        savings_txns = client.get(f"/api/v1/transactions?account_id={savings['id']}").json()
        assert len(savings_txns["transactions"]) == 1
        mirror_id = savings_txns["transactions"][0]["id"]

        # Delete source
        response = client.delete(f"/api/v1/transactions/{source['id']}")
        assert response.status_code == 204

        # Verify mirror also gone
        mirror_response = client.get(f"/api/v1/transactions/{mirror_id}")
        assert mirror_response.status_code == 404

    def test_cannot_delete_mirror_directly(self, client, test_account):
        """DELETE mirror transaction should fail."""
        # Create savings and transfer
        savings = client.post(
            "/api/v1/accounts",
            json={
                "name": "Savings3",
                "account_type": "savings",
                "opening_balance": {"amount": "0.00", "currency": "USD"},
            },
        ).json()

        client.post(
            "/api/v1/transactions",
            json={
                "account_id": test_account["id"],
                "effective_date": date.today().isoformat(),
                "amount": {"amount": "-150.00", "currency": "USD"},
                "splits": [
                    {
                        "amount": {"amount": "-150.00", "currency": "USD"},
                        "transfer_account_id": savings["id"],
                    }
                ],
            },
        )

        # Get mirror
        savings_txns = client.get(f"/api/v1/transactions?account_id={savings['id']}").json()
        mirror_id = savings_txns["transactions"][0]["id"]

        # Try to delete mirror directly
        response = client.delete(f"/api/v1/transactions/{mirror_id}")

        assert response.status_code == 400
        assert "CANNOT_DELETE_MIRROR" in response.json()["detail"]["code"]

    def test_auto_creates_payee(self, client, test_account, test_category):
        """Creating transaction with new payee should auto-create it."""
        unique_payee = f"NewPayee_{date.today().isoformat()}"

        response = client.post(
            "/api/v1/transactions",
            json={
                "account_id": test_account["id"],
                "effective_date": date.today().isoformat(),
                "amount": {"amount": "-45.00", "currency": "USD"},
                "splits": [{"amount": {"amount": "-45.00", "currency": "USD"}, "category_id": test_category["id"]}],
                "payee_name": unique_payee,
            },
        )

        assert response.status_code == 201
        data = response.json()
        assert data["payee_name"] == unique_payee
        assert data["payee_id"] is not None
        assert data["payee_id"].startswith("payee_")
```
  </action>
  <verify>
```bash
cd /workspace && pytest tests/integration/test_transaction_api.py -v --tb=short -x 2>&1 | head -80
```
  </verify>
  <done>
Transaction API integration tests created covering CRUD, splits validation, transfers with mirrors, search, filter, and status progression.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete Transaction Domain implementation:
1. Domain primitives (types, enums, SplitLine, Payee)
2. Transaction aggregate with always-split model
3. Category entity with hierarchy
4. Database tables and migration
5. ORM mappers and repositories
6. Application services with business logic
7. REST API endpoints
8. Integration tests
  </what-built>
  <how-to-verify>
**Phase 3 Success Criteria Verification:**

1. **User can create, edit, and delete transactions with date, amount, payee, category, and account**
   ```bash
   # Start API server
   cd /workspace && uvicorn src.adapters.api.app:create_app --factory --reload &

   # Create expense
   curl -X POST http://localhost:8000/api/v1/transactions \
     -H "Content-Type: application/json" \
     -d '{
       "account_id": "<ACCOUNT_ID>",
       "effective_date": "2026-01-31",
       "amount": {"amount": "-75.50", "currency": "USD"},
       "splits": [{"amount": {"amount": "-75.50", "currency": "USD"}, "category_id": "<CATEGORY_ID>"}],
       "payee_name": "Test Store"
     }'

   # Edit transaction (update memo)
   curl -X PATCH http://localhost:8000/api/v1/transactions/<TXN_ID> \
     -H "Content-Type: application/json" \
     -d '{"memo": "Updated memo"}'

   # Delete transaction
   curl -X DELETE http://localhost:8000/api/v1/transactions/<TXN_ID>
   ```

2. **User can split a transaction across multiple categories**
   ```bash
   curl -X POST http://localhost:8000/api/v1/transactions \
     -H "Content-Type: application/json" \
     -d '{
       "account_id": "<ACCOUNT_ID>",
       "effective_date": "2026-01-31",
       "amount": {"amount": "-100.00", "currency": "USD"},
       "splits": [
         {"amount": {"amount": "-60.00", "currency": "USD"}, "category_id": "<CAT1_ID>", "memo": "Food"},
         {"amount": {"amount": "-40.00", "currency": "USD"}, "category_id": "<CAT2_ID>", "memo": "Household"}
       ],
       "payee_name": "Costco"
     }'
   ```

3. **User can record a transfer between two accounts**
   ```bash
   # Transfer from checking to savings
   curl -X POST http://localhost:8000/api/v1/transactions \
     -H "Content-Type: application/json" \
     -d '{
       "account_id": "<CHECKING_ID>",
       "effective_date": "2026-01-31",
       "amount": {"amount": "-500.00", "currency": "USD"},
       "splits": [{"amount": {"amount": "-500.00", "currency": "USD"}, "transfer_account_id": "<SAVINGS_ID>"}],
       "memo": "Monthly savings"
     }'

   # Verify mirror created in savings account
   curl http://localhost:8000/api/v1/transactions?account_id=<SAVINGS_ID>
   # Should show transaction with is_mirror=true and positive amount
   ```

4. **Attachments are DEFERRED** - Not in Phase 3 scope per CONTEXT.md

5. **User can search and filter transactions**
   ```bash
   # Search by payee/memo
   curl "http://localhost:8000/api/v1/transactions?search=Costco"

   # Filter by date range
   curl "http://localhost:8000/api/v1/transactions?date_from=2026-01-01&date_to=2026-01-31"

   # Filter by account
   curl "http://localhost:8000/api/v1/transactions?account_id=<ACCOUNT_ID>"

   # Filter by category
   curl "http://localhost:8000/api/v1/transactions?category_id=<CATEGORY_ID>"
   ```

**Run all integration tests:**
```bash
cd /workspace && pytest tests/integration/ -v --tb=short
```

**Verify lint-imports passes:**
```bash
cd /workspace && lint-imports
```
  </how-to-verify>
  <resume-signal>Type "approved" if all success criteria verified, or describe any issues found.</resume-signal>
</task>

</tasks>

<verification>
Run full test suite:

```bash
cd /workspace && pytest tests/ -v --tb=short
```

Verify lint-imports:

```bash
cd /workspace && lint-imports
```

Verify migration applies cleanly to fresh database:

```bash
cd /workspace && alembic downgrade base && alembic upgrade head
```
</verification>

<success_criteria>
**Phase 3 Success Criteria (from ROADMAP.md):**

1. [x] User can create, edit, and delete transactions with date, amount, payee, category, and account
2. [x] User can split a transaction across multiple categories with specific amounts
3. [x] User can record a transfer between two accounts as a single transaction that affects both balances
4. [DEFERRED] User can attach receipt files to transactions - EXCLUDED per CONTEXT.md
5. [x] User can search and filter transactions by payee, category, amount, date, or account

**Requirements Coverage:**

| Requirement | Status | Implementation |
|-------------|--------|----------------|
| TRAN-01 | Covered | POST /api/v1/transactions |
| TRAN-02 | Covered | PATCH /api/v1/transactions/{id} |
| TRAN-03 | Covered | DELETE /api/v1/transactions/{id} |
| TRAN-04 | Covered | splits[].category_id |
| TRAN-05 | Covered | Multiple splits with category_id |
| TRAN-06 | Covered | splits[].transfer_account_id + mirror |
| TRAN-07 | DEFERRED | Attachments out of scope |
| TRAN-08 | DEFERRED | Attachments out of scope |
| TRAN-09 | Covered | GET /transactions?search= |
| TRAN-10 | Covered | GET /transactions?account_id=&category_id=&date_from= |
| TRAN-11 | Covered | GET /transactions?account_id= ordered by effective_date |
| TRAN-12 | Covered | Money value object with Decimal |
| TRAN-13 | FUTURE | Negative balance prevention (service has validation hook) |
</success_criteria>

<output>
After completion, create `.planning/phases/03-transaction-domain/03-07-SUMMARY.md`
</output>
