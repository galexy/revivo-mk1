---
phase: 03-transaction-domain
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/domain/model/transaction.py
  - src/domain/model/category.py
  - src/domain/ports/transaction_repository.py
  - src/domain/ports/category_repository.py
  - src/domain/ports/payee_repository.py
autonomous: true

must_haves:
  truths:
    - "Transaction aggregate always has at least one split line"
    - "Transaction validates splits sum exactly to transaction amount"
    - "Transfer splits automatically create mirror transactions"
    - "Category entity supports hierarchical parent/child structure"
    - "System category 'Uncategorized' is protected from modification"
  artifacts:
    - path: "src/domain/model/transaction.py"
      provides: "Transaction aggregate with always-split model"
      contains: "class Transaction"
    - path: "src/domain/model/category.py"
      provides: "Category entity with hierarchy support"
      contains: "class Category"
    - path: "src/domain/ports/transaction_repository.py"
      provides: "TransactionRepository protocol"
      contains: "class TransactionRepository"
    - path: "src/domain/ports/category_repository.py"
      provides: "CategoryRepository protocol"
      contains: "class CategoryRepository"
    - path: "src/domain/ports/payee_repository.py"
      provides: "PayeeRepository protocol"
      contains: "class PayeeRepository"
  key_links:
    - from: "src/domain/model/transaction.py"
      to: "src/domain/model/split_line.py"
      via: "SplitLine import"
      pattern: "from.*split_line import SplitLine"
    - from: "src/domain/model/transaction.py"
      to: "src/domain/events/transaction_events.py"
      via: "Domain event imports"
      pattern: "from.*transaction_events import"
---

<objective>
Create Transaction aggregate and Category entity following the CONTEXT decisions, with repository protocols for persistence.

Purpose: Implement the core domain models for financial transactions with the always-split model, mirror transaction pattern for transfers, and hierarchical categories.

Output: Complete domain models ready for persistence layer implementation in Plans 03-04.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-transaction-domain/03-CONTEXT.md
@.planning/phases/03-transaction-domain/03-01-SUMMARY.md

# Domain patterns to follow
@src/domain/model/account.py
@src/domain/model/entity_id.py
@src/domain/ports/account_repository.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Transaction aggregate root</name>
  <files>src/domain/model/transaction.py</files>
  <action>
Create Transaction aggregate following the CONTEXT decisions:

```python
"""Transaction aggregate root entity.

CONTEXT DECISIONS (override research):
1. Always-split model: Every transaction has 1+ split lines (even single-category)
2. Transaction amount = net flow to account (positive = inflow, negative = outflow)
3. Split amounts are SIGNED (positive = income, negative = expense)
4. All splits must sum exactly to transaction amount
5. Transfer splits create mirror transactions (mirrors are incoming, positive)
6. Dual dates: effective_date (logical) and posted_date (cleared)
7. Status: PENDING -> CLEARED -> RECONCILED
8. Check number for paper check tracking
"""
from dataclasses import dataclass, field
from datetime import UTC, datetime, date
from decimal import Decimal
from typing import Self

from src.domain.events.base import DomainEvent
from src.domain.events.transaction_events import (
    TransactionCreated,
    TransactionUpdated,
    TransactionDeleted,
    TransactionStatusChanged,
)
from src.domain.model.entity_id import AccountId, CategoryId, PayeeId, TransactionId, UserId
from src.domain.model.money import Money
from src.domain.model.split_line import SplitLine
from src.domain.model.transaction_types import TransactionStatus, TransactionSource


@dataclass(eq=False)
class Transaction:
    """Transaction aggregate root - always-split model.

    Every transaction has 1+ split lines. Single-category transactions
    have one split. Transfer splits create mirror transactions automatically.

    Key invariants:
    - sum(split.amount) == self.amount (always)
    - Transfer splits must be negative (outgoing)
    - Mirror transactions are incoming (positive amount)
    """
    id: TransactionId
    user_id: UserId
    account_id: AccountId  # Primary account

    # Dates per CONTEXT
    effective_date: date  # When transaction logically occurred
    posted_date: date | None  # When cleared/posted (None = pending)

    # Amount: net flow to account (positive = inflow, negative = outflow)
    amount: Money

    # Status progression: PENDING -> CLEARED -> RECONCILED
    status: TransactionStatus

    # Source for Phase 6 foundation
    source: TransactionSource

    # Always-split model: 1+ split lines
    splits: list[SplitLine] = field(default_factory=list)

    # Payee (managed entity)
    payee_id: PayeeId | None = None
    payee_name: str | None = None  # Denormalized for display

    # Description and reference
    memo: str | None = None  # Transaction-level memo
    check_number: str | None = None  # Paper check tracking

    # Mirror transaction link (for transfer targets)
    source_transaction_id: TransactionId | None = None  # If this is a mirror
    is_mirror: bool = False

    # Audit
    created_at: datetime = field(default_factory=lambda: datetime.now(UTC))
    updated_at: datetime = field(default_factory=lambda: datetime.now(UTC))

    # Domain events
    _events: list[DomainEvent] = field(default_factory=list, repr=False)

    @property
    def events(self) -> list[DomainEvent]:
        return list(self._events)

    def clear_events(self) -> None:
        self._events.clear()

    # --- Validation ---

    def _validate_splits_sum(self) -> None:
        """Validate that splits sum exactly to transaction amount."""
        if not self.splits:
            raise ValueError("Transaction must have at least one split")

        total = sum((s.amount.amount for s in self.splits), Decimal("0"))
        if total != self.amount.amount:
            raise ValueError(
                f"Splits sum ({total}) must equal transaction amount ({self.amount.amount})"
            )

    def _validate_no_self_transfer(self) -> None:
        """Validate no transfer split targets own account."""
        for split in self.splits:
            if split.transfer_account_id == self.account_id:
                raise ValueError("Cannot transfer to same account")

    def _validate_no_circular_transfers(self) -> None:
        """Validate no A->B->A circular transfers in same transaction."""
        target_accounts = [s.transfer_account_id for s in self.splits if s.is_transfer]
        if len(target_accounts) != len(set(target_accounts)):
            raise ValueError("Duplicate transfer targets not allowed")

    # --- Factory Methods ---

    @classmethod
    def create(
        cls,
        user_id: UserId,
        account_id: AccountId,
        effective_date: date,
        amount: Money,
        splits: list[SplitLine],
        payee_id: PayeeId | None = None,
        payee_name: str | None = None,
        memo: str | None = None,
        check_number: str | None = None,
        posted_date: date | None = None,
        source: TransactionSource = TransactionSource.MANUAL,
    ) -> Self:
        """Create a transaction with split lines.

        Args:
            user_id: Owner of transaction
            account_id: Primary account affected
            effective_date: When transaction logically occurred
            amount: Net flow (positive = inflow, negative = outflow)
            splits: 1+ split lines that sum to amount
            payee_id: Optional managed payee reference
            payee_name: Payee display name
            memo: Transaction-level memo
            check_number: For paper check tracking
            posted_date: When cleared (defaults to effective_date for manual)
            source: MANUAL or DOWNLOADED
        """
        txn = cls(
            id=TransactionId.generate(),
            user_id=user_id,
            account_id=account_id,
            effective_date=effective_date,
            posted_date=posted_date or effective_date,  # Default per CONTEXT
            amount=amount,
            status=TransactionStatus.PENDING,
            source=source,
            splits=splits,
            payee_id=payee_id,
            payee_name=payee_name,
            memo=memo,
            check_number=check_number,
        )

        # Validate invariants
        txn._validate_splits_sum()
        txn._validate_no_self_transfer()
        txn._validate_no_circular_transfers()

        txn._events.append(
            TransactionCreated(
                aggregate_id=str(txn.id),
                aggregate_type="Transaction",
                account_id=str(account_id),
                amount=str(amount.amount),
                currency=amount.currency,
                is_mirror=False,
            )
        )
        return txn

    @classmethod
    def create_mirror(
        cls,
        source_transaction: "Transaction",
        target_account_id: AccountId,
        amount: Money,
        effective_date: date,
    ) -> Self:
        """Create a mirror transaction for transfer target.

        Per CONTEXT:
        - Mirror is always incoming (positive amount)
        - No splits on mirrors
        - Inherits memo from source
        - Effective date syncs with source; posted_date independent
        """
        # Mirror amount is positive (incoming to target account)
        if amount.is_negative():
            amount = Money(-amount.amount, amount.currency)

        # Create single split for categorization (Uncategorized/Transfer)
        mirror_split = SplitLine(
            amount=amount,
            category_id=None,  # Will be "Uncategorized" or "Transfer" meta-category
            transfer_account_id=None,  # Mirrors don't have transfer splits
            memo=source_transaction.memo,
        )

        mirror = cls(
            id=TransactionId.generate(),
            user_id=source_transaction.user_id,
            account_id=target_account_id,
            effective_date=effective_date,
            posted_date=None,  # Independent from source per CONTEXT
            amount=amount,
            status=TransactionStatus.PENDING,
            source=source_transaction.source,
            splits=[mirror_split],
            payee_id=source_transaction.payee_id,
            payee_name=source_transaction.payee_name,
            memo=source_transaction.memo,
            source_transaction_id=source_transaction.id,
            is_mirror=True,
        )

        mirror._events.append(
            TransactionCreated(
                aggregate_id=str(mirror.id),
                aggregate_type="Transaction",
                account_id=str(target_account_id),
                amount=str(amount.amount),
                currency=amount.currency,
                is_mirror=True,
            )
        )
        return mirror

    # --- Query Properties ---

    @property
    def is_expense(self) -> bool:
        """Transaction is expense (negative net flow)."""
        return self.amount.is_negative()

    @property
    def is_income(self) -> bool:
        """Transaction is income (positive net flow)."""
        return not self.amount.is_negative() and not self.amount.is_zero()

    @property
    def has_transfer_splits(self) -> bool:
        """Transaction has at least one transfer split."""
        return any(s.is_transfer for s in self.splits)

    @property
    def transfer_account_ids(self) -> list[AccountId]:
        """Get all target account IDs from transfer splits."""
        return [s.transfer_account_id for s in self.splits if s.is_transfer and s.transfer_account_id]

    # --- Mutation Methods ---

    def update_memo(self, new_memo: str | None) -> None:
        """Update transaction memo."""
        old_memo = self.memo
        self.memo = new_memo
        self.updated_at = datetime.now(UTC)
        self._events.append(
            TransactionUpdated(
                aggregate_id=str(self.id),
                aggregate_type="Transaction",
                field="memo",
                old_value=old_memo,
                new_value=new_memo,
            )
        )

    def update_payee(self, payee_id: PayeeId | None, payee_name: str | None) -> None:
        """Update transaction payee."""
        old_payee = self.payee_name
        self.payee_id = payee_id
        self.payee_name = payee_name
        self.updated_at = datetime.now(UTC)
        self._events.append(
            TransactionUpdated(
                aggregate_id=str(self.id),
                aggregate_type="Transaction",
                field="payee",
                old_value=old_payee,
                new_value=payee_name,
            )
        )

    def update_check_number(self, check_number: str | None) -> None:
        """Update check number."""
        old_check = self.check_number
        self.check_number = check_number
        self.updated_at = datetime.now(UTC)
        self._events.append(
            TransactionUpdated(
                aggregate_id=str(self.id),
                aggregate_type="Transaction",
                field="check_number",
                old_value=old_check,
                new_value=check_number,
            )
        )

    def update_effective_date(self, new_date: date) -> None:
        """Update effective date."""
        old_date = self.effective_date
        self.effective_date = new_date
        self.updated_at = datetime.now(UTC)
        self._events.append(
            TransactionUpdated(
                aggregate_id=str(self.id),
                aggregate_type="Transaction",
                field="effective_date",
                old_value=old_date.isoformat(),
                new_value=new_date.isoformat(),
            )
        )

    def update_posted_date(self, new_date: date | None) -> None:
        """Update posted date."""
        old_date = self.posted_date
        self.posted_date = new_date
        self.updated_at = datetime.now(UTC)
        self._events.append(
            TransactionUpdated(
                aggregate_id=str(self.id),
                aggregate_type="Transaction",
                field="posted_date",
                old_value=old_date.isoformat() if old_date else None,
                new_value=new_date.isoformat() if new_date else None,
            )
        )

    def mark_cleared(self, posted_date: date | None = None) -> None:
        """Mark transaction as cleared."""
        if self.status == TransactionStatus.CLEARED:
            raise ValueError("Transaction is already cleared")
        if self.status == TransactionStatus.RECONCILED:
            raise ValueError("Cannot change status from reconciled to cleared")

        old_status = self.status
        self.status = TransactionStatus.CLEARED
        if posted_date:
            self.posted_date = posted_date
        self.updated_at = datetime.now(UTC)

        self._events.append(
            TransactionStatusChanged(
                aggregate_id=str(self.id),
                aggregate_type="Transaction",
                old_status=old_status.value,
                new_status=TransactionStatus.CLEARED.value,
            )
        )

    def mark_reconciled(self) -> None:
        """Mark transaction as reconciled."""
        if self.status == TransactionStatus.RECONCILED:
            raise ValueError("Transaction is already reconciled")

        old_status = self.status
        self.status = TransactionStatus.RECONCILED
        self.updated_at = datetime.now(UTC)

        self._events.append(
            TransactionStatusChanged(
                aggregate_id=str(self.id),
                aggregate_type="Transaction",
                old_status=old_status.value,
                new_status=TransactionStatus.RECONCILED.value,
            )
        )

    def update_splits(self, new_splits: list[SplitLine], new_amount: Money) -> None:
        """Update splits and amount together (must remain balanced).

        For editing split allocations. Both splits and amount must change together
        to maintain the invariant: sum(splits) == amount.
        """
        old_amount = self.amount
        self.splits = new_splits
        self.amount = new_amount

        # Validate invariants
        self._validate_splits_sum()
        self._validate_no_self_transfer()
        self._validate_no_circular_transfers()

        self.updated_at = datetime.now(UTC)
        self._events.append(
            TransactionUpdated(
                aggregate_id=str(self.id),
                aggregate_type="Transaction",
                field="splits",
                old_value=str(old_amount.amount),
                new_value=str(new_amount.amount),
            )
        )

    def delete(self) -> None:
        """Mark transaction for deletion (emits event)."""
        self._events.append(
            TransactionDeleted(
                aggregate_id=str(self.id),
                aggregate_type="Transaction",
                was_mirror=self.is_mirror,
            )
        )
```

Key design decisions:
- Always-split model: splits list never empty
- Signed amounts throughout
- Mirror transactions for transfers
- Dual dates (effective_date, posted_date)
- Status progression validation
- No SQLAlchemy imports (pure domain)
  </action>
  <verify>
```bash
cd /workspace && python -c "
from datetime import date
from decimal import Decimal
from src.domain.model.transaction import Transaction
from src.domain.model.split_line import SplitLine
from src.domain.model.money import Money
from src.domain.model.entity_id import UserId, AccountId, CategoryId
from src.domain.model.transaction_types import TransactionStatus

user_id = UserId.generate()
account_id = AccountId.generate()
category_id = CategoryId.generate()

# Test 1: Simple expense (one split)
expense_split = SplitLine(
    amount=Money(Decimal('-50.00'), 'USD'),
    category_id=category_id
)
txn = Transaction.create(
    user_id=user_id,
    account_id=account_id,
    effective_date=date.today(),
    amount=Money(Decimal('-50.00'), 'USD'),
    splits=[expense_split],
    payee_name='Grocery Store'
)
assert len(txn.splits) == 1
assert txn.is_expense
assert not txn.is_mirror
print('Test 1 passed: Simple expense')

# Test 2: Split transaction (multiple categories)
split1 = SplitLine(amount=Money(Decimal('-30.00'), 'USD'), category_id=CategoryId.generate())
split2 = SplitLine(amount=Money(Decimal('-20.00'), 'USD'), category_id=CategoryId.generate())
txn2 = Transaction.create(
    user_id=user_id,
    account_id=account_id,
    effective_date=date.today(),
    amount=Money(Decimal('-50.00'), 'USD'),
    splits=[split1, split2]
)
assert len(txn2.splits) == 2
print('Test 2 passed: Split transaction')

# Test 3: Transfer split
target_account = AccountId.generate()
transfer_split = SplitLine(
    amount=Money(Decimal('-100.00'), 'USD'),
    transfer_account_id=target_account
)
txn3 = Transaction.create(
    user_id=user_id,
    account_id=account_id,
    effective_date=date.today(),
    amount=Money(Decimal('-100.00'), 'USD'),
    splits=[transfer_split]
)
assert txn3.has_transfer_splits
assert target_account in txn3.transfer_account_ids
print('Test 3 passed: Transfer split')

# Test 4: Mirror transaction
mirror = Transaction.create_mirror(
    source_transaction=txn3,
    target_account_id=target_account,
    amount=Money(Decimal('-100.00'), 'USD'),  # Will be negated to positive
    effective_date=date.today()
)
assert mirror.is_mirror
assert mirror.source_transaction_id == txn3.id
assert not mirror.amount.is_negative()  # Mirror is incoming (positive)
print('Test 4 passed: Mirror transaction')

# Test 5: Status progression
assert txn.status == TransactionStatus.PENDING
txn.mark_cleared()
assert txn.status == TransactionStatus.CLEARED
txn.mark_reconciled()
assert txn.status == TransactionStatus.RECONCILED
print('Test 5 passed: Status progression')

# Test 6: Validation - splits must sum to amount
try:
    bad_split = SplitLine(amount=Money(Decimal('-30.00'), 'USD'), category_id=category_id)
    Transaction.create(
        user_id=user_id,
        account_id=account_id,
        effective_date=date.today(),
        amount=Money(Decimal('-50.00'), 'USD'),
        splits=[bad_split]  # Only -30, not -50
    )
    assert False, 'Should have raised ValueError'
except ValueError as e:
    assert 'sum' in str(e).lower()
print('Test 6 passed: Validation - splits sum')

# Test 7: No self-transfer
try:
    self_transfer = SplitLine(
        amount=Money(Decimal('-50.00'), 'USD'),
        transfer_account_id=account_id  # Same as transaction account
    )
    Transaction.create(
        user_id=user_id,
        account_id=account_id,
        effective_date=date.today(),
        amount=Money(Decimal('-50.00'), 'USD'),
        splits=[self_transfer]
    )
    assert False, 'Should have raised ValueError'
except ValueError as e:
    assert 'same account' in str(e).lower()
print('Test 7 passed: No self-transfer')

print('\\nAll Transaction tests passed!')
"
```
  </verify>
  <done>
Transaction aggregate created with always-split model, signed amounts, mirror transactions for transfers, dual dates, status progression, and proper validation. All invariants enforced.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Category entity with hierarchy</name>
  <files>src/domain/model/category.py</files>
  <action>
Create Category entity following CONTEXT decisions:

```python
"""Category entity for transaction categorization.

CONTEXT DECISIONS:
1. Hierarchical structure (parent/child categories)
2. Transactions can be assigned to any level (parent or leaf)
3. System category "Uncategorized" always exists, cannot be modified/deleted
4. Two category types based on hierarchy depth (Claude's discretion: 2 levels)
"""
from dataclasses import dataclass, field
from datetime import UTC, datetime
from typing import Self

from src.domain.events.base import DomainEvent
from src.domain.events.transaction_events import (
    CategoryCreated,
    CategoryUpdated,
    CategoryDeleted,
)
from src.domain.model.entity_id import CategoryId, UserId


# System category names that cannot be modified
SYSTEM_CATEGORY_UNCATEGORIZED = "Uncategorized"


@dataclass(eq=False)
class Category:
    """Category entity for organizing transactions.

    Supports two-level hierarchy: parent categories and child categories.
    System categories (is_system=True) cannot be modified or deleted.
    """
    id: CategoryId
    user_id: UserId
    name: str

    # Hierarchy - parent_id is None for top-level categories
    parent_id: CategoryId | None = None

    # Category metadata
    is_system: bool = False  # System categories are protected
    is_hidden: bool = False  # Hide from normal views
    sort_order: int = 0
    icon: str | None = None  # Emoji or icon name

    # Audit
    created_at: datetime = field(default_factory=lambda: datetime.now(UTC))
    updated_at: datetime = field(default_factory=lambda: datetime.now(UTC))

    # Domain events
    _events: list[DomainEvent] = field(default_factory=list, repr=False)

    @property
    def events(self) -> list[DomainEvent]:
        return list(self._events)

    def clear_events(self) -> None:
        self._events.clear()

    @property
    def is_top_level(self) -> bool:
        """Check if this is a top-level (parent) category."""
        return self.parent_id is None

    # --- Factory Methods ---

    @classmethod
    def create(
        cls,
        user_id: UserId,
        name: str,
        parent_id: CategoryId | None = None,
        icon: str | None = None,
        sort_order: int = 0,
    ) -> Self:
        """Create a new user category."""
        if not name or not name.strip():
            raise ValueError("Category name cannot be empty")

        category = cls(
            id=CategoryId.generate(),
            user_id=user_id,
            name=name.strip(),
            parent_id=parent_id,
            is_system=False,
            icon=icon,
            sort_order=sort_order,
        )

        category._events.append(
            CategoryCreated(
                aggregate_id=str(category.id),
                aggregate_type="Category",
                category_name=name,
                parent_id=str(parent_id) if parent_id else None,
                is_system=False,
            )
        )
        return category

    @classmethod
    def create_system_category(
        cls,
        user_id: UserId,
        name: str,
    ) -> Self:
        """Create a system category (protected, cannot be modified).

        Used for "Uncategorized" and potentially "Transfer" meta-category.
        """
        category = cls(
            id=CategoryId.generate(),
            user_id=user_id,
            name=name,
            parent_id=None,  # System categories are always top-level
            is_system=True,
            is_hidden=False,
            sort_order=-1,  # Sort first
        )

        category._events.append(
            CategoryCreated(
                aggregate_id=str(category.id),
                aggregate_type="Category",
                category_name=name,
                parent_id=None,
                is_system=True,
            )
        )
        return category

    # --- Mutation Methods ---

    def update_name(self, new_name: str) -> None:
        """Update category name."""
        if self.is_system:
            raise ValueError("Cannot modify system category")
        if not new_name or not new_name.strip():
            raise ValueError("Category name cannot be empty")

        old_name = self.name
        self.name = new_name.strip()
        self.updated_at = datetime.now(UTC)

        self._events.append(
            CategoryUpdated(
                aggregate_id=str(self.id),
                aggregate_type="Category",
                field="name",
                old_value=old_name,
                new_value=self.name,
            )
        )

    def update_parent(self, new_parent_id: CategoryId | None) -> None:
        """Move category to different parent (or make top-level)."""
        if self.is_system:
            raise ValueError("Cannot modify system category")
        # Prevent setting self as parent (would create cycle)
        if new_parent_id == self.id:
            raise ValueError("Category cannot be its own parent")

        old_parent = str(self.parent_id) if self.parent_id else None
        self.parent_id = new_parent_id
        self.updated_at = datetime.now(UTC)

        self._events.append(
            CategoryUpdated(
                aggregate_id=str(self.id),
                aggregate_type="Category",
                field="parent_id",
                old_value=old_parent,
                new_value=str(new_parent_id) if new_parent_id else None,
            )
        )

    def update_icon(self, icon: str | None) -> None:
        """Update category icon."""
        if self.is_system:
            raise ValueError("Cannot modify system category")

        old_icon = self.icon
        self.icon = icon
        self.updated_at = datetime.now(UTC)

        self._events.append(
            CategoryUpdated(
                aggregate_id=str(self.id),
                aggregate_type="Category",
                field="icon",
                old_value=old_icon,
                new_value=icon,
            )
        )

    def update_sort_order(self, sort_order: int) -> None:
        """Update category sort order."""
        old_order = self.sort_order
        self.sort_order = sort_order
        self.updated_at = datetime.now(UTC)

        self._events.append(
            CategoryUpdated(
                aggregate_id=str(self.id),
                aggregate_type="Category",
                field="sort_order",
                old_value=str(old_order),
                new_value=str(sort_order),
            )
        )

    def hide(self) -> None:
        """Hide category from normal views."""
        if self.is_system:
            raise ValueError("Cannot hide system category")
        self.is_hidden = True
        self.updated_at = datetime.now(UTC)

    def unhide(self) -> None:
        """Show category in normal views."""
        self.is_hidden = False
        self.updated_at = datetime.now(UTC)

    def delete(self) -> None:
        """Mark category for deletion (emits event).

        System categories cannot be deleted.
        Caller must handle reassignment of transactions using this category.
        """
        if self.is_system:
            raise ValueError("Cannot delete system category")

        self._events.append(
            CategoryDeleted(
                aggregate_id=str(self.id),
                aggregate_type="Category",
            )
        )
```

Key design:
- Two-level hierarchy (parent_id for subcategories)
- System categories protected from modification/deletion
- is_hidden for soft-hiding categories
- sort_order for custom ordering
  </action>
  <verify>
```bash
cd /workspace && python -c "
from src.domain.model.category import Category, SYSTEM_CATEGORY_UNCATEGORIZED
from src.domain.model.entity_id import CategoryId, UserId

user_id = UserId.generate()

# Test 1: Create user category
cat = Category.create(user_id=user_id, name='Food & Dining')
assert cat.name == 'Food & Dining'
assert not cat.is_system
assert cat.is_top_level
print('Test 1 passed: User category')

# Test 2: Create subcategory
sub = Category.create(user_id=user_id, name='Restaurants', parent_id=cat.id)
assert sub.parent_id == cat.id
assert not sub.is_top_level
print('Test 2 passed: Subcategory')

# Test 3: System category (Uncategorized)
sys_cat = Category.create_system_category(user_id=user_id, name=SYSTEM_CATEGORY_UNCATEGORIZED)
assert sys_cat.is_system
assert sys_cat.name == 'Uncategorized'
print('Test 3 passed: System category')

# Test 4: Cannot modify system category
try:
    sys_cat.update_name('Something Else')
    assert False, 'Should have raised ValueError'
except ValueError as e:
    assert 'system' in str(e).lower()
print('Test 4 passed: Cannot modify system')

# Test 5: Cannot delete system category
try:
    sys_cat.delete()
    assert False, 'Should have raised ValueError'
except ValueError as e:
    assert 'system' in str(e).lower()
print('Test 5 passed: Cannot delete system')

# Test 6: Update user category
cat.update_name('Food')
assert cat.name == 'Food'
print('Test 6 passed: Update category')

# Test 7: Move subcategory
new_parent = Category.create(user_id=user_id, name='Entertainment')
sub.update_parent(new_parent.id)
assert sub.parent_id == new_parent.id
print('Test 7 passed: Move subcategory')

print('\\nAll Category tests passed!')
"
```
  </verify>
  <done>
Category entity created with hierarchical structure, system category protection, and proper mutation methods with domain events.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create repository protocols</name>
  <files>
    src/domain/ports/transaction_repository.py
    src/domain/ports/category_repository.py
    src/domain/ports/payee_repository.py
  </files>
  <action>
Create repository protocols following the account_repository.py pattern:

**transaction_repository.py:**
```python
"""Transaction repository protocol.

Defines the interface for transaction persistence following the ports/adapters pattern.
"""
from datetime import date
from decimal import Decimal
from typing import Protocol

from src.domain.model.entity_id import AccountId, CategoryId, TransactionId, UserId
from src.domain.model.transaction import Transaction


class TransactionRepository(Protocol):
    """Repository protocol for Transaction aggregate."""

    def add(self, transaction: Transaction) -> None:
        """Add a new transaction."""
        ...

    def get(self, transaction_id: TransactionId) -> Transaction | None:
        """Get transaction by ID."""
        ...

    def get_by_account(
        self,
        account_id: AccountId,
        limit: int = 100,
        offset: int = 0,
    ) -> list[Transaction]:
        """Get transactions for an account (chronological by effective_date)."""
        ...

    def get_by_user(
        self,
        user_id: UserId,
        limit: int = 100,
        offset: int = 0,
    ) -> list[Transaction]:
        """Get all transactions for a user."""
        ...

    def get_mirrors_for_source(
        self,
        source_transaction_id: TransactionId,
    ) -> list[Transaction]:
        """Get mirror transactions for a source transaction."""
        ...

    def search(
        self,
        user_id: UserId,
        query: str,
        limit: int = 50,
        offset: int = 0,
    ) -> list[Transaction]:
        """Full-text search on payee and memo."""
        ...

    def filter(
        self,
        user_id: UserId,
        account_id: AccountId | None = None,
        category_id: CategoryId | None = None,
        date_from: date | None = None,
        date_to: date | None = None,
        amount_min: Decimal | None = None,
        amount_max: Decimal | None = None,
        limit: int = 100,
        offset: int = 0,
    ) -> list[Transaction]:
        """Filter transactions by various criteria."""
        ...

    def count_by_account(self, account_id: AccountId) -> int:
        """Count transactions for an account (for deletion validation)."""
        ...

    def update(self, transaction: Transaction) -> None:
        """Update an existing transaction."""
        ...

    def delete(self, transaction_id: TransactionId) -> None:
        """Delete a transaction."""
        ...
```

**category_repository.py:**
```python
"""Category repository protocol."""
from typing import Protocol

from src.domain.model.category import Category
from src.domain.model.entity_id import CategoryId, UserId


class CategoryRepository(Protocol):
    """Repository protocol for Category entity."""

    def add(self, category: Category) -> None:
        """Add a new category."""
        ...

    def get(self, category_id: CategoryId) -> Category | None:
        """Get category by ID."""
        ...

    def get_by_user(self, user_id: UserId) -> list[Category]:
        """Get all categories for a user (including system categories)."""
        ...

    def get_children(self, parent_id: CategoryId) -> list[Category]:
        """Get child categories of a parent."""
        ...

    def get_system_category(self, user_id: UserId, name: str) -> Category | None:
        """Get a system category by name (e.g., 'Uncategorized')."""
        ...

    def get_or_create_uncategorized(self, user_id: UserId) -> Category:
        """Get or create the 'Uncategorized' system category for a user."""
        ...

    def update(self, category: Category) -> None:
        """Update an existing category."""
        ...

    def delete(self, category_id: CategoryId) -> None:
        """Delete a category."""
        ...

    def count_transactions(self, category_id: CategoryId) -> int:
        """Count transactions using this category (for deletion validation)."""
        ...
```

**payee_repository.py:**
```python
"""Payee repository protocol."""
from typing import Protocol

from src.domain.model.entity_id import PayeeId, UserId
from src.domain.model.payee import Payee


class PayeeRepository(Protocol):
    """Repository protocol for Payee entity."""

    def add(self, payee: Payee) -> None:
        """Add a new payee."""
        ...

    def get(self, payee_id: PayeeId) -> Payee | None:
        """Get payee by ID."""
        ...

    def get_by_user(self, user_id: UserId) -> list[Payee]:
        """Get all payees for a user."""
        ...

    def find_by_name(self, user_id: UserId, name: str) -> Payee | None:
        """Find payee by normalized name (case-insensitive)."""
        ...

    def search(
        self,
        user_id: UserId,
        query: str,
        limit: int = 10,
    ) -> list[Payee]:
        """Search payees by name prefix for autocomplete."""
        ...

    def get_or_create(self, user_id: UserId, name: str) -> Payee:
        """Get existing payee or create new one (for auto-creation pattern)."""
        ...

    def update(self, payee: Payee) -> None:
        """Update an existing payee."""
        ...

    def delete(self, payee_id: PayeeId) -> None:
        """Delete a payee."""
        ...
```
  </action>
  <verify>
```bash
cd /workspace && python -c "
# Verify protocols are importable and follow Protocol pattern
from src.domain.ports.transaction_repository import TransactionRepository
from src.domain.ports.category_repository import CategoryRepository
from src.domain.ports.payee_repository import PayeeRepository
from typing import get_type_hints

# Check TransactionRepository has expected methods
tr_methods = ['add', 'get', 'get_by_account', 'get_by_user', 'search', 'filter', 'update', 'delete']
for method in tr_methods:
    assert hasattr(TransactionRepository, method), f'Missing {method}'
print('TransactionRepository protocol verified')

# Check CategoryRepository
cr_methods = ['add', 'get', 'get_by_user', 'get_children', 'get_or_create_uncategorized', 'update', 'delete']
for method in cr_methods:
    assert hasattr(CategoryRepository, method), f'Missing {method}'
print('CategoryRepository protocol verified')

# Check PayeeRepository
pr_methods = ['add', 'get', 'get_by_user', 'find_by_name', 'search', 'get_or_create', 'update', 'delete']
for method in pr_methods:
    assert hasattr(PayeeRepository, method), f'Missing {method}'
print('PayeeRepository protocol verified')

print('\\nAll repository protocols verified!')
"
```
  </verify>
  <done>
TransactionRepository, CategoryRepository, and PayeeRepository protocols created with all required methods for CRUD, search, and filtering operations.
  </done>
</task>

</tasks>

<verification>
Run import-linter to verify domain layer independence:

```bash
cd /workspace && lint-imports
```

Verify all new domain models have no infrastructure imports:

```bash
cd /workspace && grep -r "from sqlalchemy\|from fastapi\|from pydantic" src/domain/ && echo "FAIL: Found infrastructure imports" || echo "PASS: No infrastructure imports"
```
</verification>

<success_criteria>
1. Transaction aggregate enforces always-split model (1+ splits)
2. Transaction validates splits sum to transaction amount
3. Mirror transactions created with correct properties
4. Status progression validated (PENDING -> CLEARED -> RECONCILED)
5. Category entity supports hierarchical parent/child structure
6. System categories (Uncategorized) protected from modification
7. Repository protocols define complete interface
8. Domain layer has zero infrastructure imports
</success_criteria>

<output>
After completion, create `.planning/phases/03-transaction-domain/03-02-SUMMARY.md`
</output>
