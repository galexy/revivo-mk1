---
phase: 03-transaction-domain
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/domain/model/transaction.py
  - src/domain/model/category.py
  - src/domain/model/__init__.py
  - src/domain/ports/transaction_repository.py
  - src/domain/ports/category_repository.py
autonomous: true

must_haves:
  truths:
    - "Transaction aggregate has factory methods for expense, income, transfer, and split"
    - "Transaction validates that split lines sum to total amount"
    - "Transfer transactions link from_account and to_account"
    - "Category entity tracks hierarchy with parent_id"
  artifacts:
    - path: "src/domain/model/transaction.py"
      provides: "Transaction aggregate root"
      contains: "class Transaction"
      min_lines: 150
    - path: "src/domain/model/category.py"
      provides: "Category entity"
      contains: "class Category"
    - path: "src/domain/ports/transaction_repository.py"
      provides: "TransactionRepository protocol"
      contains: "class TransactionRepository"
    - path: "src/domain/ports/category_repository.py"
      provides: "CategoryRepository protocol"
      contains: "class CategoryRepository"
  key_links:
    - from: "src/domain/model/transaction.py"
      to: "src/domain/model/transaction_types.py"
      via: "import enums"
      pattern: "from.*transaction_types import"
    - from: "src/domain/model/transaction.py"
      to: "src/domain/events/transaction_events.py"
      via: "import events"
      pattern: "from.*transaction_events import"
---

<objective>
Create Transaction aggregate root and Category entity with repository protocols

Purpose: Transaction is the core aggregate for Phase 3. It models single-entry accounting with factory methods for expense, income, transfer, and split transactions. Category provides organization. Repository protocols define persistence contracts.

Output: Complete Transaction aggregate and Category entity ready for persistence layer
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/03-transaction-domain/03-RESEARCH.md

@src/domain/model/account.py
@src/domain/model/entity_id.py
@src/domain/model/money.py
@src/domain/ports/account_repository.py
@src/domain/ports/repository.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Transaction aggregate root</name>
  <files>src/domain/model/transaction.py</files>
  <action>
Create Transaction aggregate following the pattern from account.py and the detailed example in 03-RESEARCH.md:

1. Class structure: @dataclass(eq=False) - identity by ID, not field comparison
2. Core fields:
   - id: TransactionId
   - user_id: UserId
   - transaction_type: TransactionType
   - status: TransactionStatus
   - date: datetime (user-specified transaction date)
   - amount: Money (always positive - type determines direction)

3. Account linkage:
   - account_id: AccountId (primary account, or source for transfers)
   - transfer_account_id: AccountId | None (destination for transfers only)

4. Categorization:
   - category_id: CategoryId | None (null for transfers and splits)
   - split_lines: list[SplitLine] = field(default_factory=list)

5. Description fields:
   - payee: str | None
   - description: str | None
   - reference_number: str | None (check number, confirmation code)

6. Reconciliation:
   - cleared_at: datetime | None

7. Audit:
   - created_at: datetime (UTC default)
   - updated_at: datetime (UTC default)

8. Events:
   - _events: list[DomainEvent] = field(default_factory=list, repr=False)
   - events property (returns copy)
   - clear_events() method

9. Properties:
   - is_split -> bool (len(split_lines) > 0)
   - is_transfer -> bool (transaction_type == TRANSFER)

10. Factory methods (each validates input and emits TransactionCreated event):
    - create_expense(user_id, account_id, amount, date, category_id=None, payee=None, description=None)
    - create_income(user_id, account_id, amount, date, category_id=None, payee=None, description=None)
    - create_transfer(user_id, from_account_id, to_account_id, amount, date, description=None)
    - create_split_expense(user_id, account_id, total_amount, split_lines, date, payee=None, description=None)

11. Mutation methods (each validates and emits TransactionUpdated event):
    - update_payee(new_payee)
    - update_category(new_category_id) - raises if split or transfer
    - update_date(new_date)
    - update_amount(new_amount) - validates positive
    - update_description(new_description)
    - mark_cleared() - changes status, sets cleared_at

12. Private validation:
    - _validate_split_total() - ensures split_lines sum equals amount

Key validations:
- All amounts must be positive (not zero, not negative)
- Transfers must have different from/to accounts
- Split transactions must have at least one split line
- Split line totals must equal transaction amount
  </action>
  <verify>
Run: `python -c "
from src.domain.model.transaction import Transaction
from src.domain.model.entity_id import UserId, AccountId, CategoryId
from src.domain.model.money import Money
from src.domain.model.split_line import SplitLine
from datetime import datetime, UTC
from decimal import Decimal

user = UserId.generate()
acct = AccountId.generate()

# Test expense
expense = Transaction.create_expense(
    user_id=user,
    account_id=acct,
    amount=Money(Decimal('100'), 'USD'),
    date=datetime.now(UTC),
    payee='Grocery Store'
)
print(f'Expense: {expense.transaction_type}, {expense.amount}')

# Test transfer
acct2 = AccountId.generate()
transfer = Transaction.create_transfer(
    user_id=user,
    from_account_id=acct,
    to_account_id=acct2,
    amount=Money(Decimal('50'), 'USD'),
    date=datetime.now(UTC)
)
print(f'Transfer: {transfer.is_transfer}, from={transfer.account_id.prefix}, to={transfer.transfer_account_id.prefix}')

# Test split
cat1, cat2 = CategoryId.generate(), CategoryId.generate()
split = Transaction.create_split_expense(
    user_id=user,
    account_id=acct,
    total_amount=Money(Decimal('100'), 'USD'),
    split_lines=[
        SplitLine(amount=Money(Decimal('70'), 'USD'), category_id=cat1),
        SplitLine(amount=Money(Decimal('30'), 'USD'), category_id=cat2),
    ],
    date=datetime.now(UTC)
)
print(f'Split: {split.is_split}, lines={len(split.split_lines)}')
print('Events:', [type(e).__name__ for e in expense.events])
"`
  </verify>
  <done>Transaction aggregate with all factory methods and validations works correctly</done>
</task>

<task type="auto">
  <name>Task 2: Create Category entity and repository protocols</name>
  <files>
src/domain/model/category.py
src/domain/ports/transaction_repository.py
src/domain/ports/category_repository.py
  </files>
  <action>
Create category.py:
- @dataclass(eq=False) following Account pattern
- Fields:
  - id: CategoryId
  - user_id: UserId
  - name: str
  - category_type: str = "expense" (values: "expense", "income", "both")
  - parent_id: CategoryId | None = None (for hierarchy)
  - is_system: bool = False (system categories can't be deleted)
  - sort_order: int = 0
  - icon: str | None = None (emoji or icon name)
  - created_at: datetime (UTC default)
  - updated_at: datetime (UTC default)
- Methods:
  - update_name(new_name) - validates non-empty
  - update_parent(parent_id) - allows None to make root category
- Factory method: create(user_id, name, category_type="expense", parent_id=None)

Create transaction_repository.py (Protocol):
- add(transaction: Transaction) -> None
- get(transaction_id: TransactionId) -> Transaction | None
- get_by_account(account_id: AccountId, limit: int = 100, offset: int = 0) -> list[Transaction]
- get_by_user(user_id: UserId, limit: int = 100, offset: int = 0) -> list[Transaction]
- delete(transaction_id: TransactionId) -> None
- search(user_id: UserId, query: str, limit: int = 50, offset: int = 0) -> list[Transaction]
- filter(user_id: UserId, params: TransactionFilterParams) -> list[Transaction]
- calculate_account_balance(account_id: AccountId) -> Money

Create category_repository.py (Protocol):
- add(category: Category) -> None
- get(category_id: CategoryId) -> Category | None
- get_by_user(user_id: UserId) -> list[Category]
- get_children(parent_id: CategoryId) -> list[Category]
- delete(category_id: CategoryId) -> None

Use typing.Protocol for structural subtyping (not ABC), following existing account_repository.py pattern.
  </action>
  <verify>
Run: `python -c "
from src.domain.model.category import Category
from src.domain.model.entity_id import UserId, CategoryId
from src.domain.ports.transaction_repository import TransactionRepository
from src.domain.ports.category_repository import CategoryRepository

# Test Category
user = UserId.generate()
cat = Category.create(user_id=user, name='Groceries', category_type='expense')
print(f'Category: {cat.name}, type={cat.category_type}')

# Test update
cat.update_name('Food & Groceries')
print(f'Updated: {cat.name}')

# Verify protocols are importable (runtime_checkable)
print(f'TransactionRepository: {TransactionRepository.__protocol_attrs__}')
"`
  </verify>
  <done>Category entity and repository protocols defined correctly</done>
</task>

<task type="auto">
  <name>Task 3: Update domain model exports</name>
  <files>
src/domain/model/__init__.py
src/domain/ports/__init__.py
  </files>
  <action>
Update src/domain/model/__init__.py to export new types:
- From transaction_types: TransactionType, TransactionStatus
- From split_line: SplitLine
- From attachment: Attachment, AttachmentId
- From transaction: Transaction
- From category: Category

Update src/domain/ports/__init__.py to export new protocols:
- From transaction_repository: TransactionRepository
- From category_repository: CategoryRepository

Follow existing export patterns in these files. Ensure all public types are accessible from the package root.
  </action>
  <verify>
Run: `python -c "
# Test model exports
from src.domain.model import (
    Transaction, TransactionType, TransactionStatus,
    SplitLine, Attachment, AttachmentId, Category
)
print('Model exports OK')

# Test port exports
from src.domain.ports import TransactionRepository, CategoryRepository
print('Port exports OK')
"`
  </verify>
  <done>All new types exported from domain packages</done>
</task>

</tasks>

<verification>
All tasks completed:
1. Transaction aggregate has factory methods for expense, income, transfer, split
2. Transaction validates split line totals
3. Category entity with hierarchy support
4. Repository protocols defined as typing.Protocol
5. All exports work from package __init__.py
6. `lint-imports` passes (no infrastructure imports in domain)
</verification>

<success_criteria>
- Transaction.create_expense() creates valid expense
- Transaction.create_income() creates valid income
- Transaction.create_transfer() links two accounts
- Transaction.create_split_expense() validates split totals
- Category.create() creates valid category
- TransactionRepository protocol defined with search and filter methods
- CategoryRepository protocol defined
- lint-imports passes (domain has no infrastructure imports)
</success_criteria>

<output>
After completion, create `.planning/phases/03-transaction-domain/03-02-SUMMARY.md`
</output>
