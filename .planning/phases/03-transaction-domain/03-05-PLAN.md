---
phase: 03-transaction-domain
plan: 05
type: execute
wave: 4
depends_on: ["03-03", "03-04"]
files_modified:
  - src/application/services/transaction_service.py
  - src/application/services/category_service.py
  - src/adapters/storage/__init__.py
  - src/adapters/storage/file_storage.py
autonomous: true

must_haves:
  truths:
    - "TransactionService validates account and category ownership"
    - "TransactionService prevents negative balance on checking/savings accounts"
    - "TransactionService handles file attachments via FileStorage"
    - "CategoryService manages category CRUD with hierarchy"
  artifacts:
    - path: "src/application/services/transaction_service.py"
      provides: "Transaction use case orchestration"
      contains: "class TransactionService"
      min_lines: 150
    - path: "src/application/services/category_service.py"
      provides: "Category use case orchestration"
      contains: "class CategoryService"
    - path: "src/adapters/storage/file_storage.py"
      provides: "Local filesystem storage for attachments"
      contains: "class LocalFileStorage"
  key_links:
    - from: "src/application/services/transaction_service.py"
      to: "src/domain/ports/unit_of_work.py"
      via: "UoW dependency"
      pattern: "def __init__.*uow.*UnitOfWork"
    - from: "src/application/services/transaction_service.py"
      to: "src/adapters/storage/file_storage.py"
      via: "FileStorage dependency"
      pattern: "file_storage"
---

<objective>
Create application services for Transaction and Category domains with file storage

Purpose: Application services orchestrate use cases, validate business rules, and manage transactions (database commits). TransactionService is the core service; CategoryService manages categories; FileStorage handles receipt uploads.

Output: Complete application layer ready for API integration
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/03-transaction-domain/03-RESEARCH.md

@src/application/services/account_service.py
@src/domain/model/account_types.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create FileStorage adapter</name>
  <files>
src/adapters/storage/__init__.py
src/adapters/storage/file_storage.py
  </files>
  <action>
Create the storage adapter package and LocalFileStorage implementation.

Create src/adapters/storage/__init__.py:
```python
from .file_storage import FileStorage, LocalFileStorage

__all__ = ["FileStorage", "LocalFileStorage"]
```

Create src/adapters/storage/file_storage.py following the research document:

```python
import uuid
from pathlib import Path
from typing import BinaryIO, Protocol

import aiofiles


class FileStorage(Protocol):
    """Protocol for file storage operations."""

    async def save(
        self,
        file: BinaryIO,
        user_id: str,
        original_filename: str,
    ) -> str:
        """Save file and return storage path."""
        ...

    def get_full_path(self, storage_path: str) -> Path:
        """Get full filesystem path for a storage path."""
        ...

    def delete(self, storage_path: str) -> None:
        """Delete a file by storage path."""
        ...


class LocalFileStorage:
    """Local filesystem storage for attachments.

    Files stored as: {upload_dir}/{user_id}/{uuid}.{extension}
    """

    ALLOWED_EXTENSIONS = {".jpg", ".jpeg", ".png", ".gif", ".pdf", ".webp"}
    MAX_FILE_SIZE = 10 * 1024 * 1024  # 10MB

    def __init__(self, upload_dir: str | Path):
        self._upload_dir = Path(upload_dir)
        self._upload_dir.mkdir(parents=True, exist_ok=True)

    async def save(
        self,
        file: BinaryIO,
        user_id: str,
        original_filename: str,
    ) -> str:
        """Save file and return storage path (relative to upload_dir).

        Args:
            file: File-like object to save
            user_id: User who owns the file
            original_filename: Original filename for extension

        Returns:
            Relative path where file was saved

        Raises:
            ValueError: If file extension not allowed
        """
        # Create user directory
        user_dir = self._upload_dir / user_id
        user_dir.mkdir(exist_ok=True)

        # Validate and get extension
        ext = Path(original_filename).suffix.lower()
        if ext not in self.ALLOWED_EXTENSIONS:
            raise ValueError(f"File extension '{ext}' not allowed. Allowed: {self.ALLOWED_EXTENSIONS}")

        # Generate unique filename
        unique_name = f"{uuid.uuid4()}{ext}"
        file_path = user_dir / unique_name

        # Read content and validate size
        content = file.read()
        if len(content) > self.MAX_FILE_SIZE:
            raise ValueError(f"File exceeds maximum size of {self.MAX_FILE_SIZE} bytes")

        # Save file asynchronously
        async with aiofiles.open(file_path, "wb") as f:
            await f.write(content)

        # Return relative path
        return f"{user_id}/{unique_name}"

    def get_full_path(self, storage_path: str) -> Path:
        """Get full filesystem path for a storage path."""
        return self._upload_dir / storage_path

    def delete(self, storage_path: str) -> None:
        """Delete a file by storage path."""
        full_path = self.get_full_path(storage_path)
        if full_path.exists():
            full_path.unlink()
```

First add aiofiles to dependencies:
```bash
uv add aiofiles
uv add python-multipart  # For FastAPI file uploads in next plan
```
  </action>
  <verify>
Run: `python -c "
import asyncio
import io
from src.adapters.storage.file_storage import LocalFileStorage

async def test():
    storage = LocalFileStorage('/tmp/test_uploads')

    # Test save
    file_content = b'test content'
    file = io.BytesIO(file_content)
    path = await storage.save(file, 'user123', 'receipt.jpg')
    print(f'Saved to: {path}')

    # Test get_full_path
    full = storage.get_full_path(path)
    print(f'Full path exists: {full.exists()}')

    # Test delete
    storage.delete(path)
    print(f'After delete exists: {full.exists()}')

asyncio.run(test())
"`
  </verify>
  <done>FileStorage protocol and LocalFileStorage implementation working</done>
</task>

<task type="auto">
  <name>Task 2: Create TransactionService</name>
  <files>src/application/services/transaction_service.py</files>
  <action>
Create TransactionService following the pattern from AccountService and research document:

```python
from dataclasses import dataclass
from datetime import datetime
from decimal import Decimal
from typing import TYPE_CHECKING, BinaryIO

from src.domain.model.account_types import AccountType
from src.domain.model.attachment import Attachment
from src.domain.model.entity_id import AccountId, CategoryId, TransactionId, UserId
from src.domain.model.money import Money
from src.domain.model.split_line import SplitLine
from src.domain.model.transaction import Transaction
from src.domain.model.transaction_types import TransactionType

if TYPE_CHECKING:
    from src.adapters.storage.file_storage import FileStorage
    from src.domain.ports.unit_of_work import UnitOfWork


@dataclass(frozen=True, slots=True)
class TransactionError:
    """Error result for transaction operations."""
    code: str
    message: str


class TransactionService:
    """Application service for transaction use cases."""

    # Account types that can have negative balance
    NEGATIVE_BALANCE_ALLOWED = {AccountType.CREDIT_CARD, AccountType.LOAN}

    def __init__(self, uow: "UnitOfWork", file_storage: "FileStorage") -> None:
        self._uow = uow
        self._file_storage = file_storage

    def create_expense(
        self,
        user_id: UserId,
        account_id: AccountId,
        amount: Money,
        date: datetime,
        category_id: CategoryId | None = None,
        payee: str | None = None,
        description: str | None = None,
    ) -> Transaction | TransactionError:
        """Create an expense transaction (TRAN-01)."""
        with self._uow:
            # Validate account ownership
            account = self._uow.accounts.get(account_id)
            if account is None:
                return TransactionError("ACCOUNT_NOT_FOUND", f"Account {account_id} not found")
            if account.user_id != user_id:
                return TransactionError("ACCOUNT_NOT_OWNED", "Account does not belong to user")

            # Validate category if provided (TRAN-04)
            if category_id:
                category = self._uow.categories.get(category_id)
                if category is None:
                    return TransactionError("CATEGORY_NOT_FOUND", f"Category {category_id} not found")
                if category.user_id != user_id:
                    return TransactionError("CATEGORY_NOT_OWNED", "Category does not belong to user")

            # Check negative balance prevention (TRAN-13)
            if account.account_type not in self.NEGATIVE_BALANCE_ALLOWED:
                current_balance = self._calculate_balance(account_id)
                projected = current_balance - amount
                if projected.is_negative():
                    return TransactionError(
                        "INSUFFICIENT_BALANCE",
                        f"Expense would result in negative balance ({projected})"
                    )

            # Create transaction
            txn = Transaction.create_expense(
                user_id=user_id,
                account_id=account_id,
                amount=amount,
                date=date,
                category_id=category_id,
                payee=payee,
                description=description,
            )

            self._uow.transactions.add(txn)
            self._uow.collect_events(txn.events)
            txn.clear_events()
            self._uow.commit()

            return txn

    def create_income(self, ...) -> Transaction | TransactionError:
        """Create an income transaction."""
        # Similar to create_expense but no negative balance check

    def create_transfer(
        self,
        user_id: UserId,
        from_account_id: AccountId,
        to_account_id: AccountId,
        amount: Money,
        date: datetime,
        description: str | None = None,
    ) -> Transaction | TransactionError:
        """Create a transfer between accounts (TRAN-06)."""
        # Validate both accounts, check balance on source
        # Create single Transaction with both accounts

    def create_split_expense(
        self,
        user_id: UserId,
        account_id: AccountId,
        total_amount: Money,
        split_lines: list[SplitLine],
        date: datetime,
        payee: str | None = None,
        description: str | None = None,
    ) -> Transaction | TransactionError:
        """Create a split expense transaction (TRAN-05)."""
        # Validate all categories in split_lines belong to user

    def update_transaction(
        self,
        user_id: UserId,
        transaction_id: TransactionId,
        payee: str | None = ...,  # Sentinel to detect "not provided"
        category_id: CategoryId | None = ...,
        date: datetime | None = None,
        amount: Money | None = None,
        description: str | None = ...,
    ) -> Transaction | TransactionError:
        """Update transaction properties (TRAN-02)."""
        # Validate ownership, apply updates, emit events

    def delete_transaction(
        self,
        user_id: UserId,
        transaction_id: TransactionId,
    ) -> None | TransactionError:
        """Delete a transaction (TRAN-03)."""
        # Validate ownership, delete attachments files, delete transaction

    async def add_attachment(
        self,
        user_id: UserId,
        transaction_id: TransactionId,
        file: BinaryIO,
        filename: str,
        content_type: str,
    ) -> Attachment | TransactionError:
        """Add attachment to transaction (TRAN-07)."""
        with self._uow:
            # Validate transaction ownership
            txn = self._uow.transactions.get(transaction_id)
            if txn is None:
                return TransactionError("TRANSACTION_NOT_FOUND", "Transaction not found")
            if txn.user_id != user_id:
                return TransactionError("TRANSACTION_NOT_OWNED", "Transaction does not belong to user")

            # Get file size
            file.seek(0, 2)  # Seek to end
            size_bytes = file.tell()
            file.seek(0)  # Reset to start

            # Save file
            storage_path = await self._file_storage.save(file, str(user_id), filename)

            # Create attachment
            attachment = Attachment.create(
                transaction_id=transaction_id,
                user_id=user_id,
                filename=filename,
                storage_path=storage_path,
                content_type=content_type,
                size_bytes=size_bytes,
            )

            self._uow.attachments.add(attachment)
            self._uow.commit()

            return attachment

    def get_attachments(
        self,
        user_id: UserId,
        transaction_id: TransactionId,
    ) -> list[Attachment] | TransactionError:
        """Get all attachments for a transaction (TRAN-08)."""
        # Validate ownership, return attachments

    def search_transactions(
        self,
        user_id: UserId,
        query: str,
        limit: int = 50,
        offset: int = 0,
    ) -> list[Transaction]:
        """Full-text search on transactions (TRAN-09)."""
        with self._uow:
            return self._uow.transactions.search(user_id, query, limit, offset)

    def list_transactions(
        self,
        user_id: UserId,
        account_id: AccountId | None = None,
        category_id: CategoryId | None = None,
        date_from: datetime | None = None,
        date_to: datetime | None = None,
        limit: int = 100,
        offset: int = 0,
    ) -> list[Transaction]:
        """List and filter transactions (TRAN-10, TRAN-11)."""
        # Build filter params, call repository

    def _calculate_balance(self, account_id: AccountId) -> Money:
        """Get current account balance including opening balance."""
        account = self._uow.accounts.get(account_id)
        opening = account.opening_balance if account else Money(Decimal("0"), "USD")
        txn_balance = self._uow.transactions.calculate_account_balance(account_id)
        return opening + txn_balance
```

Implement all methods following patterns above. Use TYPE_CHECKING imports to avoid circular dependencies.
  </action>
  <verify>
Run: `python -c "
from src.application.services.transaction_service import TransactionService, TransactionError
methods = [m for m in dir(TransactionService) if not m.startswith('_')]
print('TransactionService methods:', methods)
print('TransactionError fields:', TransactionError.__dataclass_fields__.keys())
"`
  </verify>
  <done>TransactionService with all CRUD, search, filter, and attachment methods</done>
</task>

<task type="auto">
  <name>Task 3: Create CategoryService</name>
  <files>src/application/services/category_service.py</files>
  <action>
Create CategoryService for category management:

```python
from dataclasses import dataclass
from typing import TYPE_CHECKING

from src.domain.model.category import Category
from src.domain.model.entity_id import CategoryId, UserId

if TYPE_CHECKING:
    from src.domain.ports.unit_of_work import UnitOfWork


@dataclass(frozen=True, slots=True)
class CategoryError:
    """Error result for category operations."""
    code: str
    message: str


class CategoryService:
    """Application service for category use cases."""

    def __init__(self, uow: "UnitOfWork") -> None:
        self._uow = uow

    def create_category(
        self,
        user_id: UserId,
        name: str,
        category_type: str = "expense",
        parent_id: CategoryId | None = None,
    ) -> Category | CategoryError:
        """Create a new category."""
        with self._uow:
            # Validate parent if provided
            if parent_id:
                parent = self._uow.categories.get(parent_id)
                if parent is None:
                    return CategoryError("PARENT_NOT_FOUND", "Parent category not found")
                if parent.user_id != user_id:
                    return CategoryError("PARENT_NOT_OWNED", "Parent category does not belong to user")

            category = Category.create(
                user_id=user_id,
                name=name,
                category_type=category_type,
                parent_id=parent_id,
            )

            self._uow.categories.add(category)
            self._uow.commit()

            return category

    def update_category(
        self,
        user_id: UserId,
        category_id: CategoryId,
        name: str | None = None,
        parent_id: CategoryId | None = ...,  # Sentinel
    ) -> Category | CategoryError:
        """Update category properties."""
        with self._uow:
            category = self._uow.categories.get(category_id)
            if category is None:
                return CategoryError("CATEGORY_NOT_FOUND", "Category not found")
            if category.user_id != user_id:
                return CategoryError("CATEGORY_NOT_OWNED", "Category does not belong to user")
            if category.is_system:
                return CategoryError("SYSTEM_CATEGORY", "Cannot modify system category")

            if name is not None:
                category.update_name(name)

            if parent_id is not ...:
                if parent_id is not None:
                    parent = self._uow.categories.get(parent_id)
                    if parent is None:
                        return CategoryError("PARENT_NOT_FOUND", "Parent category not found")
                    if parent.user_id != user_id:
                        return CategoryError("PARENT_NOT_OWNED", "Parent does not belong to user")
                category.update_parent(parent_id)

            self._uow.commit()
            return category

    def delete_category(
        self,
        user_id: UserId,
        category_id: CategoryId,
    ) -> None | CategoryError:
        """Delete a category."""
        with self._uow:
            category = self._uow.categories.get(category_id)
            if category is None:
                return CategoryError("CATEGORY_NOT_FOUND", "Category not found")
            if category.user_id != user_id:
                return CategoryError("CATEGORY_NOT_OWNED", "Category does not belong to user")
            if category.is_system:
                return CategoryError("SYSTEM_CATEGORY", "Cannot delete system category")

            # Check if category has children
            children = self._uow.categories.get_children(category_id)
            if children:
                return CategoryError("HAS_CHILDREN", "Category has child categories")

            self._uow.categories.delete(category_id)
            self._uow.commit()
            return None

    def list_categories(self, user_id: UserId) -> list[Category]:
        """Get all categories for a user."""
        with self._uow:
            return self._uow.categories.get_by_user(user_id)

    def get_category(self, user_id: UserId, category_id: CategoryId) -> Category | CategoryError:
        """Get a single category."""
        with self._uow:
            category = self._uow.categories.get(category_id)
            if category is None:
                return CategoryError("CATEGORY_NOT_FOUND", "Category not found")
            if category.user_id != user_id:
                return CategoryError("CATEGORY_NOT_OWNED", "Category does not belong to user")
            return category
```
  </action>
  <verify>
Run: `python -c "
from src.application.services.category_service import CategoryService, CategoryError
methods = [m for m in dir(CategoryService) if not m.startswith('_')]
print('CategoryService methods:', methods)
"`
  </verify>
  <done>CategoryService with CRUD operations</done>
</task>

</tasks>

<verification>
All tasks completed:
1. FileStorage protocol and LocalFileStorage work
2. TransactionService covers TRAN-01 through TRAN-13
3. CategoryService covers category CRUD
4. Dependencies added (aiofiles, python-multipart)
5. `pytest tests/` passes
</verification>

<success_criteria>
- TransactionService.create_expense validates account ownership
- TransactionService prevents negative balance on checking/savings (TRAN-13)
- TransactionService.add_attachment saves file via FileStorage
- TransactionService.search_transactions uses full-text search (TRAN-09)
- CategoryService prevents deleting categories with children
- CategoryService prevents modifying system categories
- All services use UoW context manager for transactions
</success_criteria>

<output>
After completion, create `.planning/phases/03-transaction-domain/03-05-SUMMARY.md`
</output>
