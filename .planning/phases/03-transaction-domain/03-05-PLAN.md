---
phase: 03-transaction-domain
plan: 05
type: execute
wave: 4
depends_on: ["03-04"]
files_modified:
  - src/application/services/transaction_service.py
  - src/application/services/category_service.py
autonomous: true

must_haves:
  truths:
    - "TransactionService creates transactions with auto-payee creation"
    - "TransactionService creates mirror transactions for transfers"
    - "TransactionService validates accounts and categories belong to user"
    - "CategoryService ensures 'Uncategorized' system category exists"
    - "Services use UnitOfWork for transaction boundaries"
  artifacts:
    - path: "src/application/services/transaction_service.py"
      provides: "TransactionService with full CRUD and validation"
      contains: "class TransactionService"
    - path: "src/application/services/category_service.py"
      provides: "CategoryService with hierarchy support"
      contains: "class CategoryService"
  key_links:
    - from: "src/application/services/transaction_service.py"
      to: "src/domain/ports/unit_of_work.py"
      via: "UnitOfWork context manager"
      pattern: "with self._uow"
    - from: "src/application/services/transaction_service.py"
      to: "src/domain/model/transaction.py"
      via: "Transaction.create factory"
      pattern: "Transaction.create"
---

<objective>
Create application services for Transaction and Category domains that orchestrate use cases and enforce business rules.

Purpose: Implement the application layer that coordinates domain operations, manages transaction boundaries, and handles cross-aggregate concerns like mirror transaction creation.

Output: Services ready for REST API endpoints in Plan 06.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/03-transaction-domain/03-CONTEXT.md
@.planning/phases/03-transaction-domain/03-04-SUMMARY.md

# Existing service pattern
@src/application/services/account_service.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CategoryService</name>
  <files>src/application/services/category_service.py</files>
  <action>
Create CategoryService following the AccountService pattern:

```python
"""Application service for Category use cases.

Handles category CRUD, hierarchy management, and system category initialization.
"""
from dataclasses import dataclass
from typing import TYPE_CHECKING

from src.domain.model.category import Category, SYSTEM_CATEGORY_UNCATEGORIZED
from src.domain.model.entity_id import CategoryId, UserId

if TYPE_CHECKING:
    from src.domain.ports.unit_of_work import UnitOfWork


@dataclass(frozen=True, slots=True)
class CategoryError:
    """Error result for category operations."""
    code: str
    message: str


class CategoryService:
    """Application service for category management."""

    def __init__(self, uow: "UnitOfWork") -> None:
        self._uow = uow

    def ensure_system_categories(self, user_id: UserId) -> Category:
        """Ensure system categories exist for user.

        Creates 'Uncategorized' if it doesn't exist.
        Returns the Uncategorized category.
        """
        with self._uow:
            category = self._uow.categories.get_or_create_uncategorized(user_id)
            self._uow.commit()
            return category

    def create_category(
        self,
        user_id: UserId,
        name: str,
        parent_id: CategoryId | None = None,
        icon: str | None = None,
    ) -> Category | CategoryError:
        """Create a new user category."""
        with self._uow:
            # Validate parent exists and belongs to user
            if parent_id:
                parent = self._uow.categories.get(parent_id)
                if parent is None:
                    return CategoryError("PARENT_NOT_FOUND", f"Parent category not found")
                if parent.user_id != user_id:
                    return CategoryError("PARENT_NOT_OWNED", "Parent category does not belong to user")
                # Prevent nesting system categories
                if parent.is_system:
                    return CategoryError("CANNOT_NEST_UNDER_SYSTEM", "Cannot create subcategory under system category")

            category = Category.create(
                user_id=user_id,
                name=name,
                parent_id=parent_id,
                icon=icon,
            )

            self._uow.categories.add(category)
            self._uow.collect_events(category.events)
            category.clear_events()
            self._uow.commit()

            return category

    def get_category(self, category_id: CategoryId) -> Category | None:
        """Get a category by ID."""
        with self._uow:
            return self._uow.categories.get(category_id)

    def get_user_categories(self, user_id: UserId) -> list[Category]:
        """Get all categories for a user."""
        with self._uow:
            return self._uow.categories.get_by_user(user_id)

    def get_category_tree(self, user_id: UserId) -> dict:
        """Get categories organized as a tree structure.

        Returns dict with 'root' categories and 'children' mapping.
        """
        with self._uow:
            all_categories = self._uow.categories.get_by_user(user_id)

            # Organize into tree
            root_categories = []
            children_by_parent: dict[str, list[Category]] = {}

            for cat in all_categories:
                if cat.parent_id is None:
                    root_categories.append(cat)
                else:
                    parent_key = str(cat.parent_id)
                    if parent_key not in children_by_parent:
                        children_by_parent[parent_key] = []
                    children_by_parent[parent_key].append(cat)

            return {
                "root": root_categories,
                "children": children_by_parent,
            }

    def update_category_name(
        self,
        user_id: UserId,
        category_id: CategoryId,
        new_name: str,
    ) -> Category | CategoryError:
        """Update category name."""
        with self._uow:
            category = self._uow.categories.get(category_id)
            if category is None:
                return CategoryError("NOT_FOUND", "Category not found")
            if category.user_id != user_id:
                return CategoryError("NOT_OWNED", "Category does not belong to user")

            try:
                category.update_name(new_name)
            except ValueError as e:
                return CategoryError("VALIDATION_ERROR", str(e))

            self._uow.collect_events(category.events)
            category.clear_events()
            self._uow.commit()

            return category

    def update_category_parent(
        self,
        user_id: UserId,
        category_id: CategoryId,
        new_parent_id: CategoryId | None,
    ) -> Category | CategoryError:
        """Move category to a new parent (or make top-level)."""
        with self._uow:
            category = self._uow.categories.get(category_id)
            if category is None:
                return CategoryError("NOT_FOUND", "Category not found")
            if category.user_id != user_id:
                return CategoryError("NOT_OWNED", "Category does not belong to user")

            # Validate new parent
            if new_parent_id:
                new_parent = self._uow.categories.get(new_parent_id)
                if new_parent is None:
                    return CategoryError("PARENT_NOT_FOUND", "New parent category not found")
                if new_parent.user_id != user_id:
                    return CategoryError("PARENT_NOT_OWNED", "New parent does not belong to user")
                # Check for circular reference
                if new_parent_id == category_id:
                    return CategoryError("CIRCULAR_REFERENCE", "Category cannot be its own parent")
                # TODO: Check deeper circular references if unlimited depth

            try:
                category.update_parent(new_parent_id)
            except ValueError as e:
                return CategoryError("VALIDATION_ERROR", str(e))

            self._uow.collect_events(category.events)
            category.clear_events()
            self._uow.commit()

            return category

    def delete_category(
        self,
        user_id: UserId,
        category_id: CategoryId,
        reassign_to: CategoryId | None = None,
    ) -> bool | CategoryError:
        """Delete a category.

        Args:
            user_id: User making the request
            category_id: Category to delete
            reassign_to: Category to reassign transactions to (defaults to Uncategorized)

        Returns:
            True if deleted, or CategoryError
        """
        with self._uow:
            category = self._uow.categories.get(category_id)
            if category is None:
                return CategoryError("NOT_FOUND", "Category not found")
            if category.user_id != user_id:
                return CategoryError("NOT_OWNED", "Category does not belong to user")
            if category.is_system:
                return CategoryError("CANNOT_DELETE_SYSTEM", "Cannot delete system category")

            # Check for child categories
            children = self._uow.categories.get_children(category_id)
            if children:
                return CategoryError("HAS_CHILDREN", "Cannot delete category with subcategories")

            # Get or create Uncategorized for reassignment
            if reassign_to is None:
                uncategorized = self._uow.categories.get_or_create_uncategorized(user_id)
                reassign_to = uncategorized.id

            # TODO: Reassign transactions (will be added when transaction filter by category works)
            # For now, just check if there are transactions
            txn_count = self._uow.categories.count_transactions(category_id)
            if txn_count > 0:
                return CategoryError(
                    "HAS_TRANSACTIONS",
                    f"Category has {txn_count} transaction(s). Reassign them first."
                )

            category.delete()
            self._uow.collect_events(category.events)
            self._uow.categories.delete(category_id)
            self._uow.commit()

            return True
```
  </action>
  <verify>
```bash
cd /workspace && python -c "
from src.application.services.category_service import CategoryService, CategoryError

# Verify class has expected methods
methods = [
    'ensure_system_categories',
    'create_category',
    'get_category',
    'get_user_categories',
    'get_category_tree',
    'update_category_name',
    'update_category_parent',
    'delete_category',
]
for m in methods:
    assert hasattr(CategoryService, m), f'Missing method: {m}'

# Verify CategoryError
error = CategoryError('CODE', 'message')
assert error.code == 'CODE'
assert error.message == 'message'

print('CategoryService verified!')
"
```
  </verify>
  <done>
CategoryService created with CRUD operations, hierarchy management, and system category initialization. Uses UnitOfWork for transaction boundaries.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create TransactionService</name>
  <files>src/application/services/transaction_service.py</files>
  <action>
Create TransactionService with full CRUD, mirror transaction creation, and validation:

```python
"""Application service for Transaction use cases.

Handles transaction CRUD, mirror transaction management, and business validations.
Per CONTEXT: auto-payee creation, mirror transactions for transfers, status progression.
"""
from dataclasses import dataclass
from datetime import date
from decimal import Decimal
from typing import TYPE_CHECKING

from src.domain.events.transaction_events import MirrorTransactionCreated, MirrorTransactionDeleted
from src.domain.model.entity_id import AccountId, CategoryId, PayeeId, TransactionId, UserId
from src.domain.model.money import Money
from src.domain.model.split_line import SplitLine
from src.domain.model.transaction import Transaction
from src.domain.model.transaction_types import TransactionSource, TransactionStatus

if TYPE_CHECKING:
    from src.domain.ports.unit_of_work import UnitOfWork


@dataclass(frozen=True, slots=True)
class TransactionError:
    """Error result for transaction operations."""
    code: str
    message: str


class TransactionService:
    """Application service for transaction management."""

    def __init__(self, uow: "UnitOfWork") -> None:
        self._uow = uow

    def _validate_account(self, user_id: UserId, account_id: AccountId) -> tuple[bool, str | None]:
        """Validate account exists and belongs to user."""
        account = self._uow.accounts.get(account_id)
        if account is None:
            return False, "Account not found"
        if account.user_id != user_id:
            return False, "Account does not belong to user"
        if not account.is_active:
            return False, "Account is not active"
        return True, None

    def _validate_category(self, user_id: UserId, category_id: CategoryId) -> tuple[bool, str | None]:
        """Validate category exists and belongs to user."""
        category = self._uow.categories.get(category_id)
        if category is None:
            return False, "Category not found"
        if category.user_id != user_id:
            return False, "Category does not belong to user"
        return True, None

    def _validate_splits(
        self,
        user_id: UserId,
        account_id: AccountId,
        splits: list[SplitLine],
        total_amount: Money,
    ) -> tuple[bool, str | None]:
        """Validate splits sum to total and all references are valid."""
        # Check sum
        split_sum = sum((s.amount.amount for s in splits), Decimal("0"))
        if split_sum != total_amount.amount:
            return False, f"Splits sum ({split_sum}) must equal amount ({total_amount.amount})"

        # Validate each split
        for split in splits:
            if split.category_id:
                valid, msg = self._validate_category(user_id, split.category_id)
                if not valid:
                    return False, msg
            if split.transfer_account_id:
                if split.transfer_account_id == account_id:
                    return False, "Cannot transfer to same account"
                valid, msg = self._validate_account(user_id, split.transfer_account_id)
                if not valid:
                    return False, f"Transfer target: {msg}"

        return True, None

    def _get_or_create_payee(
        self,
        user_id: UserId,
        payee_name: str | None,
    ) -> tuple[PayeeId | None, str | None]:
        """Get or create payee by name, returning (payee_id, payee_name)."""
        if not payee_name:
            return None, None

        payee = self._uow.payees.get_or_create(user_id, payee_name)
        payee.record_usage()
        return payee.id, payee.name

    def _create_mirror_transactions(
        self,
        source_transaction: Transaction,
    ) -> list[Transaction]:
        """Create mirror transactions for transfer splits."""
        mirrors = []

        for split in source_transaction.splits:
            if split.is_transfer and split.transfer_account_id:
                # Create mirror (incoming to target account)
                mirror = Transaction.create_mirror(
                    source_transaction=source_transaction,
                    target_account_id=split.transfer_account_id,
                    amount=split.amount,  # Will be negated to positive in create_mirror
                    effective_date=source_transaction.effective_date,
                )

                self._uow.transactions.add(mirror)
                mirrors.append(mirror)

                # Emit event
                self._uow.collect_events([
                    MirrorTransactionCreated(
                        aggregate_id=str(mirror.id),
                        aggregate_type="Transaction",
                        source_transaction_id=str(source_transaction.id),
                        mirror_transaction_id=str(mirror.id),
                        target_account_id=str(split.transfer_account_id),
                    )
                ])

        return mirrors

    def create_transaction(
        self,
        user_id: UserId,
        account_id: AccountId,
        effective_date: date,
        amount: Money,
        splits: list[SplitLine],
        payee_name: str | None = None,
        memo: str | None = None,
        check_number: str | None = None,
        posted_date: date | None = None,
        source: TransactionSource = TransactionSource.MANUAL,
    ) -> Transaction | TransactionError:
        """Create a transaction with splits.

        Per CONTEXT:
        - Every transaction has 1+ splits
        - Auto-creates payee if name provided
        - Auto-creates mirror transactions for transfer splits
        """
        with self._uow:
            # Validate account
            valid, msg = self._validate_account(user_id, account_id)
            if not valid:
                return TransactionError("INVALID_ACCOUNT", msg)

            # Validate splits
            if not splits:
                return TransactionError("NO_SPLITS", "Transaction must have at least one split")
            valid, msg = self._validate_splits(user_id, account_id, splits, amount)
            if not valid:
                return TransactionError("INVALID_SPLITS", msg)

            # Get or create payee
            payee_id, payee_display = self._get_or_create_payee(user_id, payee_name)

            # Create transaction
            try:
                txn = Transaction.create(
                    user_id=user_id,
                    account_id=account_id,
                    effective_date=effective_date,
                    amount=amount,
                    splits=splits,
                    payee_id=payee_id,
                    payee_name=payee_display,
                    memo=memo,
                    check_number=check_number,
                    posted_date=posted_date,
                    source=source,
                )
            except ValueError as e:
                return TransactionError("VALIDATION_ERROR", str(e))

            self._uow.transactions.add(txn)
            self._uow.collect_events(txn.events)
            txn.clear_events()

            # Create mirror transactions for transfers
            mirrors = self._create_mirror_transactions(txn)

            self._uow.commit()

            return txn

    def get_transaction(
        self,
        user_id: UserId,
        transaction_id: TransactionId,
    ) -> Transaction | TransactionError:
        """Get a transaction by ID."""
        with self._uow:
            txn = self._uow.transactions.get(transaction_id)
            if txn is None:
                return TransactionError("NOT_FOUND", "Transaction not found")
            if txn.user_id != user_id:
                return TransactionError("NOT_OWNED", "Transaction does not belong to user")
            return txn

    def get_account_transactions(
        self,
        user_id: UserId,
        account_id: AccountId,
        limit: int = 100,
        offset: int = 0,
    ) -> list[Transaction] | TransactionError:
        """Get transactions for an account."""
        with self._uow:
            # Validate account
            valid, msg = self._validate_account(user_id, account_id)
            if not valid:
                return TransactionError("INVALID_ACCOUNT", msg)

            return self._uow.transactions.get_by_account(account_id, limit, offset)

    def search_transactions(
        self,
        user_id: UserId,
        query: str,
        limit: int = 50,
    ) -> list[Transaction]:
        """Full-text search on transactions."""
        with self._uow:
            return self._uow.transactions.search(user_id, query, limit)

    def filter_transactions(
        self,
        user_id: UserId,
        account_id: AccountId | None = None,
        category_id: CategoryId | None = None,
        date_from: date | None = None,
        date_to: date | None = None,
        amount_min: Decimal | None = None,
        amount_max: Decimal | None = None,
        limit: int = 100,
        offset: int = 0,
    ) -> list[Transaction]:
        """Filter transactions by various criteria."""
        with self._uow:
            return self._uow.transactions.filter(
                user_id=user_id,
                account_id=account_id,
                category_id=category_id,
                date_from=date_from,
                date_to=date_to,
                amount_min=amount_min,
                amount_max=amount_max,
                limit=limit,
                offset=offset,
            )

    def update_transaction_memo(
        self,
        user_id: UserId,
        transaction_id: TransactionId,
        memo: str | None,
    ) -> Transaction | TransactionError:
        """Update transaction memo."""
        with self._uow:
            txn = self._uow.transactions.get(transaction_id)
            if txn is None:
                return TransactionError("NOT_FOUND", "Transaction not found")
            if txn.user_id != user_id:
                return TransactionError("NOT_OWNED", "Transaction does not belong to user")

            # Warn if reconciled (per CONTEXT)
            if txn.status == TransactionStatus.RECONCILED:
                # Still allow, but caller should show warning
                pass

            txn.update_memo(memo)
            self._uow.transactions.update(txn)
            self._uow.collect_events(txn.events)
            txn.clear_events()

            # Update mirrors if this is source transaction
            if not txn.is_mirror:
                mirrors = self._uow.transactions.get_mirrors_for_source(transaction_id)
                for mirror in mirrors:
                    mirror.update_memo(memo)
                    self._uow.transactions.update(mirror)

            self._uow.commit()
            return txn

    def update_transaction_dates(
        self,
        user_id: UserId,
        transaction_id: TransactionId,
        effective_date: date | None = None,
        posted_date: date | None = None,
    ) -> Transaction | TransactionError:
        """Update transaction dates."""
        with self._uow:
            txn = self._uow.transactions.get(transaction_id)
            if txn is None:
                return TransactionError("NOT_FOUND", "Transaction not found")
            if txn.user_id != user_id:
                return TransactionError("NOT_OWNED", "Transaction does not belong to user")

            if effective_date:
                txn.update_effective_date(effective_date)
                # Sync effective date to mirrors (per CONTEXT)
                if not txn.is_mirror:
                    mirrors = self._uow.transactions.get_mirrors_for_source(transaction_id)
                    for mirror in mirrors:
                        mirror.update_effective_date(effective_date)
                        self._uow.transactions.update(mirror)

            if posted_date is not None:
                txn.update_posted_date(posted_date)
                # Posted date is independent on mirrors (per CONTEXT)

            self._uow.transactions.update(txn)
            self._uow.collect_events(txn.events)
            txn.clear_events()
            self._uow.commit()

            return txn

    def mark_transaction_cleared(
        self,
        user_id: UserId,
        transaction_id: TransactionId,
        posted_date: date | None = None,
    ) -> Transaction | TransactionError:
        """Mark transaction as cleared."""
        with self._uow:
            txn = self._uow.transactions.get(transaction_id)
            if txn is None:
                return TransactionError("NOT_FOUND", "Transaction not found")
            if txn.user_id != user_id:
                return TransactionError("NOT_OWNED", "Transaction does not belong to user")

            try:
                txn.mark_cleared(posted_date)
            except ValueError as e:
                return TransactionError("STATUS_ERROR", str(e))

            self._uow.transactions.update(txn)
            self._uow.collect_events(txn.events)
            txn.clear_events()
            self._uow.commit()

            return txn

    def mark_transaction_reconciled(
        self,
        user_id: UserId,
        transaction_id: TransactionId,
    ) -> Transaction | TransactionError:
        """Mark transaction as reconciled."""
        with self._uow:
            txn = self._uow.transactions.get(transaction_id)
            if txn is None:
                return TransactionError("NOT_FOUND", "Transaction not found")
            if txn.user_id != user_id:
                return TransactionError("NOT_OWNED", "Transaction does not belong to user")

            try:
                txn.mark_reconciled()
            except ValueError as e:
                return TransactionError("STATUS_ERROR", str(e))

            self._uow.transactions.update(txn)
            self._uow.collect_events(txn.events)
            txn.clear_events()
            self._uow.commit()

            return txn

    def delete_transaction(
        self,
        user_id: UserId,
        transaction_id: TransactionId,
    ) -> bool | TransactionError:
        """Delete a transaction.

        Per CONTEXT: Deleting a source transaction deletes its mirrors.
        Deleting a mirror is not allowed (must delete source).
        """
        with self._uow:
            txn = self._uow.transactions.get(transaction_id)
            if txn is None:
                return TransactionError("NOT_FOUND", "Transaction not found")
            if txn.user_id != user_id:
                return TransactionError("NOT_OWNED", "Transaction does not belong to user")

            if txn.is_mirror:
                return TransactionError(
                    "CANNOT_DELETE_MIRROR",
                    "Cannot delete mirror transaction. Delete the source transaction instead."
                )

            # Delete mirrors first
            mirrors = self._uow.transactions.get_mirrors_for_source(transaction_id)
            for mirror in mirrors:
                self._uow.collect_events([
                    MirrorTransactionDeleted(
                        aggregate_id=str(mirror.id),
                        aggregate_type="Transaction",
                        source_transaction_id=str(transaction_id),
                        mirror_transaction_id=str(mirror.id),
                    )
                ])
                self._uow.transactions.delete(mirror.id)

            # Delete source transaction
            txn.delete()
            self._uow.collect_events(txn.events)
            self._uow.transactions.delete(transaction_id)
            self._uow.commit()

            return True
```
  </action>
  <verify>
```bash
cd /workspace && python -c "
from src.application.services.transaction_service import TransactionService, TransactionError

# Verify class has expected methods
methods = [
    'create_transaction',
    'get_transaction',
    'get_account_transactions',
    'search_transactions',
    'filter_transactions',
    'update_transaction_memo',
    'update_transaction_dates',
    'mark_transaction_cleared',
    'mark_transaction_reconciled',
    'delete_transaction',
]
for m in methods:
    assert hasattr(TransactionService, m), f'Missing method: {m}'

# Verify TransactionError
error = TransactionError('CODE', 'message')
assert error.code == 'CODE'
assert error.message == 'message'

print('TransactionService verified!')
"
```
  </verify>
  <done>
TransactionService created with full CRUD, auto-payee creation, mirror transaction management, and proper validation. Uses UnitOfWork for transaction boundaries.
  </done>
</task>

</tasks>

<verification>
Verify services can be imported and have correct structure:

```bash
cd /workspace && python -c "
from src.application.services.category_service import CategoryService
from src.application.services.transaction_service import TransactionService
print('Services import successfully!')
"
```

Verify lint-imports passes:

```bash
cd /workspace && lint-imports
```
</verification>

<success_criteria>
1. CategoryService has CRUD and hierarchy methods
2. CategoryService ensures 'Uncategorized' system category
3. TransactionService creates transactions with validation
4. TransactionService auto-creates payees
5. TransactionService creates mirror transactions for transfers
6. TransactionService validates account and category ownership
7. TransactionService propagates edits to mirrors per CONTEXT rules
8. Both services use UnitOfWork pattern
9. Both services emit domain events properly
</success_criteria>

<output>
After completion, create `.planning/phases/03-transaction-domain/03-05-SUMMARY.md`
</output>
