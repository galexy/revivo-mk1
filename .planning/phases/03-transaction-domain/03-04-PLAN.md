---
phase: 03-transaction-domain
plan: 04
type: execute
wave: 3
depends_on: ["03-01", "03-02", "03-03"]
files_modified:
  - src/adapters/persistence/orm/mappers.py
  - src/adapters/persistence/repositories/transaction.py
  - src/adapters/persistence/repositories/category.py
  - src/adapters/persistence/repositories/attachment.py
  - src/domain/ports/unit_of_work.py
autonomous: true

must_haves:
  truths:
    - "Transaction mapper reconstructs Money and SplitLine value objects"
    - "TransactionRepository implements full-text search with tsvector"
    - "TransactionRepository calculates account balance from transactions"
    - "Attachment repository handles file metadata persistence"
  artifacts:
    - path: "src/adapters/persistence/repositories/transaction.py"
      provides: "SqlAlchemyTransactionRepository implementation"
      contains: "class SqlAlchemyTransactionRepository"
      min_lines: 100
    - path: "src/adapters/persistence/repositories/category.py"
      provides: "SqlAlchemyCategoryRepository implementation"
      contains: "class SqlAlchemyCategoryRepository"
    - path: "src/adapters/persistence/repositories/attachment.py"
      provides: "SqlAlchemyAttachmentRepository implementation"
      contains: "class SqlAlchemyAttachmentRepository"
  key_links:
    - from: "src/adapters/persistence/repositories/transaction.py"
      to: "src/domain/ports/transaction_repository.py"
      via: "implements protocol"
      pattern: "TransactionRepository"
    - from: "src/adapters/persistence/orm/mappers.py"
      to: "src/domain/model/transaction.py"
      via: "mapper registration"
      pattern: "mapper_registry\\.map_imperatively.*Transaction"
---

<objective>
Create ORM mappers and repository implementations for Transaction domain

Purpose: Connect Transaction domain to database persistence. Mappers handle domain-to-table conversion; repositories implement the persistence protocols defined in domain layer.

Output: Working persistence layer for transactions, categories, and attachments
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/03-transaction-domain/03-RESEARCH.md

@src/adapters/persistence/orm/mappers.py
@src/adapters/persistence/orm/tables.py
@src/adapters/persistence/repositories/account.py
@src/domain/ports/unit_of_work.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Transaction and Category mappers</name>
  <files>src/adapters/persistence/orm/mappers.py</files>
  <action>
Add imperative mappings following the existing Account mapper pattern:

1. Category mapper:
   - Map Category class to categories table
   - Properties map directly (id, user_id, name, category_type, parent_id, is_system, sort_order, icon, created_at, updated_at)
   - CategoryId type decorator handles conversion

2. Transaction mapper:
   - Map Transaction class to transactions table
   - Direct properties: id, user_id, transaction_type, status, date, account_id, transfer_account_id, category_id, payee, description, reference_number, cleared_at, created_at, updated_at
   - amount/currency: Reconstruct Money value object in repository (not composite)
   - split_lines: Separate relationship, loaded via repository
   - _events: Excluded from mapping (transient)
   - Note: search_vector is managed by application code, not mapped

3. SplitLine - NOT mapped directly:
   - SplitLine is a value object stored in split_lines table
   - Repository reconstructs SplitLines when loading Transaction
   - No mapper needed for value objects

4. Attachment mapper:
   - Map Attachment class to attachments table
   - Direct properties: id, transaction_id, user_id, filename, storage_path, content_type, size_bytes, created_at

Important: Follow the existing pattern of NOT using SQLAlchemy composite() for value objects. The repository layer handles reconstruction of Money and SplitLine objects.

Import the new domain classes at the top of the file:
```python
from src.domain.model.transaction import Transaction
from src.domain.model.category import Category
from src.domain.model.attachment import Attachment
```

Call start_mappers() at module level to register all mappers.
  </action>
  <verify>
Run: `python -c "
from src.adapters.persistence.orm import mappers
from src.domain.model.transaction import Transaction
from src.domain.model.category import Category
from src.domain.model.attachment import Attachment

# Verify mappers are registered
from sqlalchemy.orm import class_mapper
try:
    class_mapper(Transaction)
    print('Transaction mapper: OK')
except:
    print('Transaction mapper: FAILED')

try:
    class_mapper(Category)
    print('Category mapper: OK')
except:
    print('Category mapper: FAILED')

try:
    class_mapper(Attachment)
    print('Attachment mapper: OK')
except:
    print('Attachment mapper: FAILED')
"`

Then verify split_lines reconstruction works with a round-trip test:
```bash
python -c "
import asyncio
from decimal import Decimal
from datetime import datetime, timezone

from src.adapters.persistence.orm.database import sync_session_factory
from src.adapters.persistence.orm import mappers
from src.adapters.persistence.repositories.transaction import SqlAlchemyTransactionRepository
from src.domain.model.transaction import Transaction
from src.domain.model.money import Money
from src.domain.model.split_line import SplitLine
from src.domain.model.entity_id import UserId, AccountId, CategoryId, TransactionId

# Create a transaction with split_lines
session = sync_session_factory()
repo = SqlAlchemyTransactionRepository(session)

# Create test transaction with splits
user_id = UserId.generate()
account_id = AccountId.generate()
cat_id = CategoryId.generate()

txn = Transaction.create_split_expense(
    user_id=user_id,
    account_id=account_id,
    total_amount=Money(Decimal('100.00'), 'USD'),
    split_lines=[
        SplitLine(amount=Money(Decimal('60.00'), 'USD'), category_id=cat_id, memo='Part 1'),
        SplitLine(amount=Money(Decimal('40.00'), 'USD'), category_id=None, memo='Part 2'),
    ],
    date=datetime.now(timezone.utc),
    payee='Test Payee',
)

# Note: This is a structural test - actual DB test requires accounts/categories to exist
# The key is verifying the repository methods exist and split_lines reconstruction logic
print('Transaction created with', len(txn.split_lines), 'split lines')
print('Split line 1 amount:', txn.split_lines[0].amount)
print('Split line 2 amount:', txn.split_lines[1].amount)
print('Repository has _load_split_lines:', hasattr(repo, '_load_split_lines'))
print('Repository has _reconstruct_amount:', hasattr(repo, '_reconstruct_amount'))
"
```
  </verify>
  <done>Transaction, Category, and Attachment mappers registered; split_lines reconstruction method verified</done>
</task>

<task type="auto">
  <name>Task 2: Create TransactionRepository and CategoryRepository</name>
  <files>
src/adapters/persistence/repositories/transaction.py
src/adapters/persistence/repositories/category.py
  </files>
  <action>
Create transaction.py with SqlAlchemyTransactionRepository:
Following the pattern from account.py repository:

```python
class SqlAlchemyTransactionRepository:
    def __init__(self, session: Session) -> None:
        self._session = session

    def add(self, transaction: Transaction) -> None:
        """Add transaction and its split lines."""
        self._session.add(transaction)
        # Handle split_lines separately
        for i, line in enumerate(transaction.split_lines):
            self._session.execute(
                split_lines.insert().values(
                    transaction_id=str(transaction.id),
                    amount=line.amount.amount,
                    currency=line.amount.currency,
                    category_id=str(line.category_id) if line.category_id else None,
                    memo=line.memo
                )
            )
        # Update search vector
        self._update_search_vector(transaction)

    def get(self, transaction_id: TransactionId) -> Transaction | None:
        """Get transaction by ID, including split lines."""
        txn = self._session.get(Transaction, str(transaction_id))
        if txn:
            self._load_split_lines(txn)
            self._reconstruct_amount(txn)
        return txn

    def get_by_account(self, account_id: AccountId, limit: int = 100, offset: int = 0) -> list[Transaction]:
        """Get transactions for an account (as source or transfer destination)."""
        stmt = (
            select(Transaction)
            .where(
                (transactions.c.account_id == str(account_id)) |
                (transactions.c.transfer_account_id == str(account_id))
            )
            .order_by(transactions.c.date.desc())
            .limit(limit)
            .offset(offset)
        )
        result = self._session.execute(stmt).scalars().all()
        for txn in result:
            self._load_split_lines(txn)
            self._reconstruct_amount(txn)
        return list(result)

    def get_by_user(self, user_id: UserId, limit: int = 100, offset: int = 0) -> list[Transaction]:
        """Get all transactions for a user."""
        # Implementation similar to get_by_account

    def delete(self, transaction_id: TransactionId) -> None:
        """Delete transaction (split_lines cascade automatically)."""
        txn = self.get(transaction_id)
        if txn:
            self._session.delete(txn)

    def search(self, user_id: UserId, query: str, limit: int = 50, offset: int = 0) -> list[Transaction]:
        """Full-text search on payee and description using tsvector."""
        from sqlalchemy import func
        ts_query = func.plainto_tsquery('english', query)
        stmt = (
            select(Transaction)
            .where(transactions.c.user_id == str(user_id))
            .where(transactions.c.search_vector.op('@@')(ts_query))
            .order_by(transactions.c.date.desc())
            .limit(limit)
            .offset(offset)
        )
        result = self._session.execute(stmt).scalars().all()
        for txn in result:
            self._load_split_lines(txn)
            self._reconstruct_amount(txn)
        return list(result)

    def calculate_account_balance(self, account_id: AccountId) -> Money:
        """Calculate balance from transactions for an account."""
        # Sum based on transaction type:
        # INCOME to account: +amount
        # EXPENSE from account: -amount
        # TRANSFER from account: -amount
        # TRANSFER to account: +amount
        # See research doc for full implementation

    def _load_split_lines(self, txn: Transaction) -> None:
        """Load and reconstruct SplitLine value objects."""
        stmt = select(split_lines).where(split_lines.c.transaction_id == str(txn.id))
        rows = self._session.execute(stmt).fetchall()
        txn.split_lines = [
            SplitLine(
                amount=Money(row.amount, row.currency),
                category_id=CategoryId.from_string(row.category_id) if row.category_id else None,
                memo=row.memo
            )
            for row in rows
        ]

    def _reconstruct_amount(self, txn: Transaction) -> None:
        """Reconstruct Money value object from table columns."""
        # Access raw columns via inspect or table query
        # Set txn.amount = Money(amount, currency)

    def _update_search_vector(self, txn: Transaction) -> None:
        """Update search_vector for full-text search."""
        from sqlalchemy import func
        searchable = ' '.join(filter(None, [txn.payee, txn.description]))
        stmt = (
            transactions.update()
            .where(transactions.c.id == str(txn.id))
            .values(search_vector=func.to_tsvector('english', searchable))
        )
        self._session.execute(stmt)
```

Create category.py with SqlAlchemyCategoryRepository:
Simpler than transaction, just basic CRUD + get_by_user and get_children.

Import statements need split_lines table and SplitLine class.
  </action>
  <verify>
Run: `python -c "
from src.adapters.persistence.repositories.transaction import SqlAlchemyTransactionRepository
from src.adapters.persistence.repositories.category import SqlAlchemyCategoryRepository
print('TransactionRepository:', [m for m in dir(SqlAlchemyTransactionRepository) if not m.startswith('_')])
print('CategoryRepository:', [m for m in dir(SqlAlchemyCategoryRepository) if not m.startswith('_')])
"`
  </verify>
  <done>Transaction and Category repositories implemented</done>
</task>

<task type="auto">
  <name>Task 3: Create AttachmentRepository and update UnitOfWork</name>
  <files>
src/adapters/persistence/repositories/attachment.py
src/domain/ports/unit_of_work.py
src/adapters/persistence/unit_of_work.py
  </files>
  <action>
Create attachment.py with SqlAlchemyAttachmentRepository:
- add(attachment: Attachment) -> None
- get(attachment_id: AttachmentId) -> Attachment | None
- get_by_transaction(transaction_id: TransactionId) -> list[Attachment]
- delete(attachment_id: AttachmentId) -> None

Update src/domain/ports/unit_of_work.py protocol:
Add properties for new repositories:
```python
@property
def transactions(self) -> TransactionRepository:
    ...

@property
def categories(self) -> CategoryRepository:
    ...

@property
def attachments(self) -> AttachmentRepository:
    ...
```

Update src/adapters/persistence/unit_of_work.py implementation:
Add lazy initialization for new repositories (following the accounts pattern):
```python
@property
def transactions(self) -> SqlAlchemyTransactionRepository:
    if self._transactions is None:
        self._transactions = SqlAlchemyTransactionRepository(self._session)
    return self._transactions

@property
def categories(self) -> SqlAlchemyCategoryRepository:
    if self._categories is None:
        self._categories = SqlAlchemyCategoryRepository(self._session)
    return self._categories

@property
def attachments(self) -> SqlAlchemyAttachmentRepository:
    if self._attachments is None:
        self._attachments = SqlAlchemyAttachmentRepository(self._session)
    return self._attachments
```

Initialize _transactions, _categories, _attachments to None in __init__.
  </action>
  <verify>
Run: `python -c "
from src.adapters.persistence.repositories.attachment import SqlAlchemyAttachmentRepository
from src.adapters.persistence.unit_of_work import SqlAlchemyUnitOfWork
from src.adapters.persistence.orm.database import sync_session_factory

# Test UoW has new properties
uow = SqlAlchemyUnitOfWork(sync_session_factory)
print('UoW transactions:', type(uow.transactions).__name__)
print('UoW categories:', type(uow.categories).__name__)
print('UoW attachments:', type(uow.attachments).__name__)
"`
  </verify>
  <done>AttachmentRepository created and UnitOfWork updated with all new repositories</done>
</task>

</tasks>

<verification>
All tasks completed:
1. Mappers registered for Transaction, Category, Attachment
2. SqlAlchemyTransactionRepository with search and balance calculation
3. SqlAlchemyCategoryRepository with hierarchy support
4. SqlAlchemyAttachmentRepository
5. UnitOfWork exposes all new repositories
6. Split lines reconstruction verified via round-trip test
7. `pytest tests/` passes
</verification>

<success_criteria>
- Transaction mapper handles all fields except _events
- Repository reconstructs Money from amount/currency columns
- Repository reconstructs SplitLine objects from split_lines table
- Full-text search uses tsvector with plainto_tsquery
- calculate_account_balance returns correct Money value
- UnitOfWork.transactions, .categories, .attachments work
- lint-imports passes (repositories in adapters layer only)
</success_criteria>

<output>
After completion, create `.planning/phases/03-transaction-domain/03-04-SUMMARY.md`
</output>
