---
phase: 03-transaction-domain
plan: 04
type: execute
wave: 3
depends_on: ["03-02", "03-03"]
files_modified:
  - src/adapters/persistence/orm/mappers.py
  - src/adapters/persistence/repositories/transaction.py
  - src/adapters/persistence/repositories/category.py
  - src/adapters/persistence/repositories/payee.py
  - src/adapters/persistence/unit_of_work.py
autonomous: true

must_haves:
  truths:
    - "ORM mappers link domain models to database tables"
    - "TransactionRepository loads transactions with their splits"
    - "CategoryRepository can get or create 'Uncategorized' system category"
    - "PayeeRepository supports autocomplete search"
    - "UnitOfWork exposes new repositories"
  artifacts:
    - path: "src/adapters/persistence/repositories/transaction.py"
      provides: "SqlAlchemyTransactionRepository"
      contains: "class SqlAlchemyTransactionRepository"
    - path: "src/adapters/persistence/repositories/category.py"
      provides: "SqlAlchemyCategoryRepository"
      contains: "class SqlAlchemyCategoryRepository"
    - path: "src/adapters/persistence/repositories/payee.py"
      provides: "SqlAlchemyPayeeRepository"
      contains: "class SqlAlchemyPayeeRepository"
  key_links:
    - from: "src/adapters/persistence/orm/mappers.py"
      to: "src/domain/model/transaction.py"
      via: "mapper_registry.map_imperatively"
      pattern: "mapper_registry.map_imperatively.*Transaction"
    - from: "src/adapters/persistence/unit_of_work.py"
      to: "repositories"
      via: "Lazy repository properties"
      pattern: "def transactions.*TransactionRepository"
---

<objective>
Create ORM mappers and repository implementations for Transaction domain entities.

Purpose: Wire domain models to database tables using SQLAlchemy imperative mapping, and implement repository protocols with proper query patterns.

Output: Complete persistence layer ready for application services in Plan 05.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/03-transaction-domain/03-CONTEXT.md
@.planning/phases/03-transaction-domain/03-02-SUMMARY.md
@.planning/phases/03-transaction-domain/03-03-SUMMARY.md

# Existing patterns
@src/adapters/persistence/orm/mappers.py
@src/adapters/persistence/repositories/account.py
@src/adapters/persistence/unit_of_work.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ORM mappers for transaction domain entities</name>
  <files>src/adapters/persistence/orm/mappers.py</files>
  <action>
Add imperative mappings for Category, Payee, Transaction, and SplitLine following the existing Account pattern.

Key considerations:
1. SplitLine is a value object - map it as a relationship on Transaction
2. Transaction.splits loaded eagerly (always needed)
3. Money reconstruction from amount/currency columns (same pattern as Account)
4. No SQLAlchemy imports in domain models

Add to mappers.py:

```python
# Add imports
from src.domain.model.category import Category
from src.domain.model.payee import Payee
from src.domain.model.transaction import Transaction
from src.domain.model.split_line import SplitLine
from src.adapters.persistence.orm.tables import categories, payees, transactions, split_lines


def _configure_category_mapper() -> None:
    """Configure Category entity mapper."""
    mapper_registry.map_imperatively(
        Category,
        categories,
        properties={
            "id": categories.c.id,
            "user_id": categories.c.user_id,
            "name": categories.c.name,
            "parent_id": categories.c.parent_id,
            "is_system": categories.c.is_system,
            "is_hidden": categories.c.is_hidden,
            "sort_order": categories.c.sort_order,
            "icon": categories.c.icon,
            "created_at": categories.c.created_at,
            "updated_at": categories.c.updated_at,
            # Exclude _events - not persisted
        },
        exclude_properties=["_events"],
    )


def _configure_payee_mapper() -> None:
    """Configure Payee entity mapper."""
    mapper_registry.map_imperatively(
        Payee,
        payees,
        properties={
            "id": payees.c.id,
            "user_id": payees.c.user_id,
            "name": payees.c.name,
            "normalized_name": payees.c.normalized_name,
            "default_category_id": payees.c.default_category_id,
            "last_used_at": payees.c.last_used_at,
            "usage_count": payees.c.usage_count,
            "created_at": payees.c.created_at,
            "updated_at": payees.c.updated_at,
        },
    )


def _configure_split_line_mapper() -> None:
    """Configure SplitLine value object mapper.

    SplitLine needs special handling:
    - It's a frozen dataclass (immutable)
    - Money must be reconstructed from amount/currency columns
    - Loaded as relationship from Transaction
    """
    # For frozen dataclasses, we need a custom reconstruction approach
    # SQLAlchemy will populate the columns, then we reconstruct in repository
    pass  # SplitLine handled via composite loading in Transaction repository


def _configure_transaction_mapper() -> None:
    """Configure Transaction aggregate mapper.

    Splits are NOT mapped via relationship because SplitLine is a frozen
    dataclass with Money value object. Instead, splits are loaded manually
    in the repository and reconstructed.
    """
    mapper_registry.map_imperatively(
        Transaction,
        transactions,
        properties={
            "id": transactions.c.id,
            "user_id": transactions.c.user_id,
            "account_id": transactions.c.account_id,
            "effective_date": transactions.c.effective_date,
            "posted_date": transactions.c.posted_date,
            # amount/currency handled in repository (Money reconstruction)
            "status": transactions.c.status,
            "source": transactions.c.source,
            "payee_id": transactions.c.payee_id,
            "payee_name": transactions.c.payee_name,
            "memo": transactions.c.memo,
            "check_number": transactions.c.check_number,
            "source_transaction_id": transactions.c.source_transaction_id,
            "is_mirror": transactions.c.is_mirror,
            "created_at": transactions.c.created_at,
            "updated_at": transactions.c.updated_at,
            # splits loaded manually, amount reconstructed in repository
        },
        exclude_properties=["_events", "splits", "amount"],
    )


# Update configure_mappers to include new mappers
def configure_mappers() -> None:
    """Configure all ORM mappers.

    Called once at application startup.
    """
    _configure_account_mapper()
    _configure_category_mapper()
    _configure_payee_mapper()
    _configure_transaction_mapper()
```

Note: Transaction.splits and Transaction.amount are excluded from the mapper and handled in the repository layer because:
1. SplitLine is a frozen dataclass with Money (immutable value object)
2. Money must be reconstructed from separate amount/currency columns
3. Following the same pattern used for Account's Money fields
  </action>
  <verify>
```bash
cd /workspace && python -c "
from src.adapters.persistence.orm.mappers import configure_mappers
from src.adapters.persistence.orm.base import mapper_registry

# Reset mappers if already configured
mapper_registry.dispose()

# Configure
configure_mappers()

# Verify mappers registered
from src.domain.model.category import Category
from src.domain.model.payee import Payee
from src.domain.model.transaction import Transaction

assert Category in mapper_registry.mappers.keys() or any(
    m.class_ == Category for m in mapper_registry.mappers.values()
), 'Category not mapped'
assert Payee in mapper_registry.mappers.keys() or any(
    m.class_ == Payee for m in mapper_registry.mappers.values()
), 'Payee not mapped'
assert Transaction in mapper_registry.mappers.keys() or any(
    m.class_ == Transaction for m in mapper_registry.mappers.values()
), 'Transaction not mapped'

print('All mappers configured successfully!')
"
```
  </verify>
  <done>
ORM mappers configured for Category, Payee, and Transaction entities with proper exclusions for domain events and value object reconstruction.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create repository implementations</name>
  <files>
    src/adapters/persistence/repositories/transaction.py
    src/adapters/persistence/repositories/category.py
    src/adapters/persistence/repositories/payee.py
  </files>
  <action>
Create repository implementations following the account repository pattern.

**category.py:**
```python
"""SQLAlchemy implementation of CategoryRepository."""
from datetime import UTC, datetime

from sqlalchemy import func, select
from sqlalchemy.orm import Session

from src.domain.model.category import Category, SYSTEM_CATEGORY_UNCATEGORIZED
from src.domain.model.entity_id import CategoryId, UserId
from src.domain.ports.category_repository import CategoryRepository
from src.adapters.persistence.orm.tables import categories, split_lines


class SqlAlchemyCategoryRepository(CategoryRepository):
    """SQLAlchemy implementation of CategoryRepository."""

    def __init__(self, session: Session) -> None:
        self._session = session

    def add(self, category: Category) -> None:
        self._session.add(category)

    def get(self, category_id: CategoryId) -> Category | None:
        return self._session.get(Category, category_id)

    def get_by_user(self, user_id: UserId) -> list[Category]:
        stmt = (
            select(Category)
            .where(Category.user_id == user_id)
            .order_by(Category.sort_order, Category.name)
        )
        return list(self._session.scalars(stmt))

    def get_children(self, parent_id: CategoryId) -> list[Category]:
        stmt = (
            select(Category)
            .where(Category.parent_id == parent_id)
            .order_by(Category.sort_order, Category.name)
        )
        return list(self._session.scalars(stmt))

    def get_system_category(self, user_id: UserId, name: str) -> Category | None:
        stmt = (
            select(Category)
            .where(Category.user_id == user_id)
            .where(Category.is_system == True)
            .where(Category.name == name)
        )
        return self._session.scalar(stmt)

    def get_or_create_uncategorized(self, user_id: UserId) -> Category:
        existing = self.get_system_category(user_id, SYSTEM_CATEGORY_UNCATEGORIZED)
        if existing:
            return existing

        category = Category.create_system_category(user_id, SYSTEM_CATEGORY_UNCATEGORIZED)
        self._session.add(category)
        return category

    def update(self, category: Category) -> None:
        # Managed by session
        pass

    def delete(self, category_id: CategoryId) -> None:
        category = self.get(category_id)
        if category:
            self._session.delete(category)

    def count_transactions(self, category_id: CategoryId) -> int:
        stmt = (
            select(func.count())
            .select_from(split_lines)
            .where(split_lines.c.category_id == str(category_id))
        )
        return self._session.scalar(stmt) or 0
```

**payee.py:**
```python
"""SQLAlchemy implementation of PayeeRepository."""
from sqlalchemy import func, select
from sqlalchemy.orm import Session

from src.domain.model.entity_id import PayeeId, UserId
from src.domain.model.payee import Payee
from src.domain.ports.payee_repository import PayeeRepository


class SqlAlchemyPayeeRepository(PayeeRepository):
    """SQLAlchemy implementation of PayeeRepository."""

    def __init__(self, session: Session) -> None:
        self._session = session

    def add(self, payee: Payee) -> None:
        self._session.add(payee)

    def get(self, payee_id: PayeeId) -> Payee | None:
        return self._session.get(Payee, payee_id)

    def get_by_user(self, user_id: UserId) -> list[Payee]:
        stmt = (
            select(Payee)
            .where(Payee.user_id == user_id)
            .order_by(Payee.usage_count.desc(), Payee.name)
        )
        return list(self._session.scalars(stmt))

    def find_by_name(self, user_id: UserId, name: str) -> Payee | None:
        normalized = name.strip().lower()
        stmt = (
            select(Payee)
            .where(Payee.user_id == user_id)
            .where(Payee.normalized_name == normalized)
        )
        return self._session.scalar(stmt)

    def search(
        self,
        user_id: UserId,
        query: str,
        limit: int = 10,
    ) -> list[Payee]:
        """Search payees by name prefix for autocomplete."""
        normalized_query = query.strip().lower()
        stmt = (
            select(Payee)
            .where(Payee.user_id == user_id)
            .where(Payee.normalized_name.startswith(normalized_query))
            .order_by(Payee.usage_count.desc(), Payee.name)
            .limit(limit)
        )
        return list(self._session.scalars(stmt))

    def get_or_create(self, user_id: UserId, name: str) -> Payee:
        """Get existing payee or create new one."""
        existing = self.find_by_name(user_id, name)
        if existing:
            return existing

        payee = Payee.create(user_id=user_id, name=name)
        self._session.add(payee)
        return payee

    def update(self, payee: Payee) -> None:
        # Managed by session
        pass

    def delete(self, payee_id: PayeeId) -> None:
        payee = self.get(payee_id)
        if payee:
            self._session.delete(payee)
```

**transaction.py:**
```python
"""SQLAlchemy implementation of TransactionRepository."""
from datetime import date
from decimal import Decimal

from sqlalchemy import func, select, and_, or_
from sqlalchemy.orm import Session

from src.domain.model.entity_id import AccountId, CategoryId, TransactionId, UserId
from src.domain.model.money import Money
from src.domain.model.split_line import SplitLine
from src.domain.model.transaction import Transaction
from src.domain.ports.transaction_repository import TransactionRepository
from src.adapters.persistence.orm.tables import transactions, split_lines


class SqlAlchemyTransactionRepository(TransactionRepository):
    """SQLAlchemy implementation of TransactionRepository."""

    def __init__(self, session: Session) -> None:
        self._session = session

    def _load_splits(self, transaction_id: TransactionId) -> list[SplitLine]:
        """Load and reconstruct SplitLine value objects for a transaction."""
        stmt = (
            select(split_lines)
            .where(split_lines.c.transaction_id == str(transaction_id))
            .order_by(split_lines.c.sort_order)
        )
        rows = self._session.execute(stmt).fetchall()

        result = []
        for row in rows:
            amount = Money(row.amount, row.currency)
            category_id = CategoryId.from_string(row.category_id) if row.category_id else None
            transfer_account_id = AccountId.from_string(row.transfer_account_id) if row.transfer_account_id else None

            split = SplitLine(
                amount=amount,
                category_id=category_id,
                transfer_account_id=transfer_account_id,
                memo=row.memo,
            )
            result.append(split)
        return result

    def _save_splits(self, transaction: Transaction) -> None:
        """Save split lines for a transaction."""
        # Delete existing splits
        delete_stmt = split_lines.delete().where(
            split_lines.c.transaction_id == str(transaction.id)
        )
        self._session.execute(delete_stmt)

        # Insert new splits
        for i, split in enumerate(transaction.splits):
            insert_stmt = split_lines.insert().values(
                transaction_id=str(transaction.id),
                amount=split.amount.amount,
                currency=split.amount.currency,
                category_id=str(split.category_id) if split.category_id else None,
                transfer_account_id=str(split.transfer_account_id) if split.transfer_account_id else None,
                memo=split.memo,
                sort_order=i,
            )
            self._session.execute(insert_stmt)

    def _hydrate_transaction(self, txn: Transaction) -> Transaction:
        """Hydrate transaction with splits and Money amount."""
        # Load splits
        txn.splits = self._load_splits(txn.id)

        # Reconstruct amount from database
        stmt = select(transactions.c.amount, transactions.c.currency).where(
            transactions.c.id == str(txn.id)
        )
        row = self._session.execute(stmt).fetchone()
        if row:
            txn.amount = Money(row.amount, row.currency)

        return txn

    def add(self, transaction: Transaction) -> None:
        # First, insert the transaction with amount
        insert_stmt = transactions.insert().values(
            id=str(transaction.id),
            user_id=str(transaction.user_id),
            account_id=str(transaction.account_id),
            effective_date=transaction.effective_date,
            posted_date=transaction.posted_date,
            amount=transaction.amount.amount,
            currency=transaction.amount.currency,
            status=transaction.status.value,
            source=transaction.source.value,
            payee_id=str(transaction.payee_id) if transaction.payee_id else None,
            payee_name=transaction.payee_name,
            memo=transaction.memo,
            check_number=transaction.check_number,
            source_transaction_id=str(transaction.source_transaction_id) if transaction.source_transaction_id else None,
            is_mirror=transaction.is_mirror,
            created_at=transaction.created_at,
            updated_at=transaction.updated_at,
        )
        self._session.execute(insert_stmt)

        # Then save splits
        self._save_splits(transaction)

        # Update search vector
        self._update_search_vector(transaction)

    def _update_search_vector(self, transaction: Transaction) -> None:
        """Update full-text search vector."""
        searchable = " ".join(filter(None, [transaction.payee_name, transaction.memo]))
        if searchable:
            update_stmt = (
                transactions.update()
                .where(transactions.c.id == str(transaction.id))
                .values(search_vector=func.to_tsvector("english", searchable))
            )
            self._session.execute(update_stmt)

    def get(self, transaction_id: TransactionId) -> Transaction | None:
        txn = self._session.get(Transaction, transaction_id)
        if txn:
            return self._hydrate_transaction(txn)
        return None

    def get_by_account(
        self,
        account_id: AccountId,
        limit: int = 100,
        offset: int = 0,
    ) -> list[Transaction]:
        stmt = (
            select(Transaction)
            .where(Transaction.account_id == account_id)
            .order_by(Transaction.effective_date.desc())
            .limit(limit)
            .offset(offset)
        )
        txns = list(self._session.scalars(stmt))
        return [self._hydrate_transaction(t) for t in txns]

    def get_by_user(
        self,
        user_id: UserId,
        limit: int = 100,
        offset: int = 0,
    ) -> list[Transaction]:
        stmt = (
            select(Transaction)
            .where(Transaction.user_id == user_id)
            .order_by(Transaction.effective_date.desc())
            .limit(limit)
            .offset(offset)
        )
        txns = list(self._session.scalars(stmt))
        return [self._hydrate_transaction(t) for t in txns]

    def get_mirrors_for_source(
        self,
        source_transaction_id: TransactionId,
    ) -> list[Transaction]:
        stmt = (
            select(Transaction)
            .where(Transaction.source_transaction_id == source_transaction_id)
        )
        txns = list(self._session.scalars(stmt))
        return [self._hydrate_transaction(t) for t in txns]

    def search(
        self,
        user_id: UserId,
        query: str,
        limit: int = 50,
        offset: int = 0,
    ) -> list[Transaction]:
        """Full-text search on payee and memo."""
        ts_query = func.plainto_tsquery("english", query)
        stmt = (
            select(Transaction)
            .where(Transaction.user_id == user_id)
            .where(transactions.c.search_vector.op("@@")(ts_query))
            .order_by(Transaction.effective_date.desc())
            .limit(limit)
            .offset(offset)
        )
        txns = list(self._session.scalars(stmt))
        return [self._hydrate_transaction(t) for t in txns]

    def filter(
        self,
        user_id: UserId,
        account_id: AccountId | None = None,
        category_id: CategoryId | None = None,
        date_from: date | None = None,
        date_to: date | None = None,
        amount_min: Decimal | None = None,
        amount_max: Decimal | None = None,
        limit: int = 100,
        offset: int = 0,
    ) -> list[Transaction]:
        """Filter transactions by various criteria."""
        conditions = [Transaction.user_id == user_id]

        if account_id:
            conditions.append(Transaction.account_id == account_id)
        if date_from:
            conditions.append(Transaction.effective_date >= date_from)
        if date_to:
            conditions.append(Transaction.effective_date <= date_to)
        if amount_min is not None:
            conditions.append(transactions.c.amount >= amount_min)
        if amount_max is not None:
            conditions.append(transactions.c.amount <= amount_max)

        stmt = (
            select(Transaction)
            .where(and_(*conditions))
            .order_by(Transaction.effective_date.desc())
            .limit(limit)
            .offset(offset)
        )

        # If filtering by category, need to join with split_lines
        if category_id:
            stmt = (
                select(Transaction)
                .join(split_lines, split_lines.c.transaction_id == transactions.c.id)
                .where(and_(*conditions))
                .where(split_lines.c.category_id == str(category_id))
                .distinct()
                .order_by(Transaction.effective_date.desc())
                .limit(limit)
                .offset(offset)
            )

        txns = list(self._session.scalars(stmt))
        return [self._hydrate_transaction(t) for t in txns]

    def count_by_account(self, account_id: AccountId) -> int:
        stmt = (
            select(func.count())
            .select_from(transactions)
            .where(transactions.c.account_id == str(account_id))
        )
        return self._session.scalar(stmt) or 0

    def update(self, transaction: Transaction) -> None:
        """Update transaction and its splits."""
        update_stmt = (
            transactions.update()
            .where(transactions.c.id == str(transaction.id))
            .values(
                effective_date=transaction.effective_date,
                posted_date=transaction.posted_date,
                amount=transaction.amount.amount,
                currency=transaction.amount.currency,
                status=transaction.status.value,
                payee_id=str(transaction.payee_id) if transaction.payee_id else None,
                payee_name=transaction.payee_name,
                memo=transaction.memo,
                check_number=transaction.check_number,
                updated_at=transaction.updated_at,
            )
        )
        self._session.execute(update_stmt)

        # Update splits
        self._save_splits(transaction)

        # Update search vector
        self._update_search_vector(transaction)

    def delete(self, transaction_id: TransactionId) -> None:
        # Splits cascade automatically via FK
        delete_stmt = transactions.delete().where(
            transactions.c.id == str(transaction_id)
        )
        self._session.execute(delete_stmt)
```
  </action>
  <verify>
```bash
cd /workspace && python -c "
from src.adapters.persistence.repositories.category import SqlAlchemyCategoryRepository
from src.adapters.persistence.repositories.payee import SqlAlchemyPayeeRepository
from src.adapters.persistence.repositories.transaction import SqlAlchemyTransactionRepository

# Verify classes have expected methods
cat_methods = ['add', 'get', 'get_by_user', 'get_children', 'get_or_create_uncategorized', 'update', 'delete']
for m in cat_methods:
    assert hasattr(SqlAlchemyCategoryRepository, m), f'Category missing {m}'
print('CategoryRepository implementation verified')

payee_methods = ['add', 'get', 'get_by_user', 'find_by_name', 'search', 'get_or_create', 'update', 'delete']
for m in payee_methods:
    assert hasattr(SqlAlchemyPayeeRepository, m), f'Payee missing {m}'
print('PayeeRepository implementation verified')

txn_methods = ['add', 'get', 'get_by_account', 'get_by_user', 'search', 'filter', 'update', 'delete']
for m in txn_methods:
    assert hasattr(SqlAlchemyTransactionRepository, m), f'Transaction missing {m}'
print('TransactionRepository implementation verified')

print('\\nAll repositories verified!')
"
```
  </verify>
  <done>
Repository implementations created for Category, Payee, and Transaction with proper value object reconstruction and full-text search support.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update UnitOfWork with new repositories</name>
  <files>src/adapters/persistence/unit_of_work.py</files>
  <action>
Update the UnitOfWork class to expose the new repositories following the existing pattern:

```python
# Add imports
from src.adapters.persistence.repositories.category import SqlAlchemyCategoryRepository
from src.adapters.persistence.repositories.payee import SqlAlchemyPayeeRepository
from src.adapters.persistence.repositories.transaction import SqlAlchemyTransactionRepository
from src.domain.ports.category_repository import CategoryRepository
from src.domain.ports.payee_repository import PayeeRepository
from src.domain.ports.transaction_repository import TransactionRepository


class SqlAlchemyUnitOfWork:
    """Unit of Work implementation with all repositories.

    Repositories are lazily initialized on first access.
    """

    def __init__(self, session_factory: sessionmaker) -> None:
        self._session_factory = session_factory
        self._session: Session | None = None
        self._accounts: AccountRepository | None = None
        self._categories: CategoryRepository | None = None
        self._payees: PayeeRepository | None = None
        self._transactions: TransactionRepository | None = None
        self._events: list[DomainEvent] = []

    # ... existing __enter__, __exit__, commit, rollback, collect_events methods ...

    @property
    def accounts(self) -> AccountRepository:
        if self._accounts is None:
            self._accounts = SqlAlchemyAccountRepository(self._session)
        return self._accounts

    @property
    def categories(self) -> CategoryRepository:
        if self._categories is None:
            self._categories = SqlAlchemyCategoryRepository(self._session)
        return self._categories

    @property
    def payees(self) -> PayeeRepository:
        if self._payees is None:
            self._payees = SqlAlchemyPayeeRepository(self._session)
        return self._payees

    @property
    def transactions(self) -> TransactionRepository:
        if self._transactions is None:
            self._transactions = SqlAlchemyTransactionRepository(self._session)
        return self._transactions
```

Also update the UnitOfWork protocol in `src/domain/ports/unit_of_work.py`:

```python
# Add to UnitOfWork protocol
from src.domain.ports.category_repository import CategoryRepository
from src.domain.ports.payee_repository import PayeeRepository
from src.domain.ports.transaction_repository import TransactionRepository

class UnitOfWork(Protocol):
    accounts: AccountRepository
    categories: CategoryRepository
    payees: PayeeRepository
    transactions: TransactionRepository

    # ... existing methods ...
```
  </action>
  <verify>
```bash
cd /workspace && python -c "
from src.adapters.persistence.unit_of_work import SqlAlchemyUnitOfWork
from src.domain.ports.unit_of_work import UnitOfWork

# Verify UnitOfWork has new repository properties
assert hasattr(SqlAlchemyUnitOfWork, 'categories'), 'Missing categories'
assert hasattr(SqlAlchemyUnitOfWork, 'payees'), 'Missing payees'
assert hasattr(SqlAlchemyUnitOfWork, 'transactions'), 'Missing transactions'

print('UnitOfWork updated with new repositories!')

# Verify protocol
from typing import get_type_hints
hints = get_type_hints(UnitOfWork)
assert 'categories' in hints or hasattr(UnitOfWork, 'categories'), 'Protocol missing categories'
assert 'payees' in hints or hasattr(UnitOfWork, 'payees'), 'Protocol missing payees'
assert 'transactions' in hints or hasattr(UnitOfWork, 'transactions'), 'Protocol missing transactions'

print('UnitOfWork protocol updated!')
"
```
  </verify>
  <done>
UnitOfWork updated with lazy-initialized Category, Payee, and Transaction repositories. Protocol updated with new repository properties.
  </done>
</task>

</tasks>

<verification>
Run lint-imports to verify no forbidden imports:

```bash
cd /workspace && lint-imports
```

Run existing tests to ensure no regressions:

```bash
cd /workspace && pytest tests/ -v --tb=short -x
```
</verification>

<success_criteria>
1. ORM mappers configure without errors
2. CategoryRepository loads and saves categories with hierarchy
3. PayeeRepository supports autocomplete search by prefix
4. TransactionRepository loads transactions with hydrated splits
5. TransactionRepository supports full-text search
6. UnitOfWork exposes all new repositories
7. No import violations
8. Existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-transaction-domain/03-04-SUMMARY.md`
</output>
