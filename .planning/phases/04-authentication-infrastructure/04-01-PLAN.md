---
phase: 04-authentication-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/domain/model/entity_id.py
  - src/domain/model/user.py
  - src/domain/model/household.py
  - src/domain/model/__init__.py
  - src/domain/events/user_events.py
  - src/domain/events/__init__.py
autonomous: true

must_haves:
  truths:
    - "User entity exists with email, display_name, password_hash, household_id"
    - "Household entity exists with name and owner_id"
    - "HouseholdId and UserId follow existing TypeID pattern"
    - "Domain events exist for user registration and email verification"
  artifacts:
    - path: "src/domain/model/user.py"
      provides: "User entity with authentication fields"
      contains: "class User"
    - path: "src/domain/model/household.py"
      provides: "Household entity for data scoping"
      contains: "class Household"
    - path: "src/domain/model/entity_id.py"
      provides: "HouseholdId TypeID"
      contains: "class HouseholdId"
    - path: "src/domain/events/user_events.py"
      provides: "User domain events"
      contains: "UserRegistered"
  key_links:
    - from: "src/domain/model/user.py"
      to: "src/domain/model/entity_id.py"
      via: "UserId and HouseholdId imports"
      pattern: "from.*entity_id import.*UserId.*HouseholdId"
---

<objective>
Create User and Household domain entities with supporting ID types and events.

Purpose: Establish the domain model foundation for authentication. User holds identity and credentials, Household enables multi-user data scoping.

Output: Domain entities (User, Household), HouseholdId type, and domain events ready for persistence layer.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-authentication-infrastructure/04-CONTEXT.md
@.planning/phases/04-authentication-infrastructure/04-RESEARCH.md
@src/domain/model/entity_id.py
@src/domain/model/account.py
@src/domain/events/account_events.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add HouseholdId to entity_id.py</name>
  <files>src/domain/model/entity_id.py</files>
  <action>
Add HouseholdId dataclass following the exact pattern of existing ID types (AccountId, UserId, etc.):

```python
@dataclass(frozen=True, slots=True)
class HouseholdId:
    """Identifier for Household aggregate root.

    Format: hh_01h455vb4pex5vsknk084sn02q
    """
    value: str

    @classmethod
    def generate(cls) -> Self:
        """Generate a new HouseholdId."""
        tid = TypeID(prefix="hh")
        return cls(value=str(tid))

    @classmethod
    def from_string(cls, value: str) -> Self:
        """Parse and validate a HouseholdId from string."""
        tid = TypeID.from_string(value)
        if tid.prefix != "hh":
            raise ValueError(f"Expected 'hh' prefix, got '{tid.prefix}'")
        return cls(value=value)

    @property
    def prefix(self) -> str:
        return "hh"

    def __str__(self) -> str:
        return self.value
```

Place after UserId definition to maintain alphabetical grouping of ID types.
  </action>
  <verify>
Run `python -c "from src.domain.model.entity_id import HouseholdId; h = HouseholdId.generate(); print(h)"` to verify import and generation works.
  </verify>
  <done>HouseholdId follows TypeID pattern, generates with "hh_" prefix, parses from string with validation.</done>
</task>

<task type="auto">
  <name>Task 2: Create Household domain entity</name>
  <files>src/domain/model/household.py, src/domain/model/__init__.py</files>
  <action>
Create Household entity following the Account pattern (mutable aggregate with explicit mutation methods):

```python
"""Household aggregate root for multi-user data scoping.

A Household owns all financial data (accounts, transactions, categories).
Users belong to households. Initially one household per user, but the
model supports multiple users per household (future Phase 25).
"""

from dataclasses import dataclass, field
from datetime import UTC, datetime
from typing import Self

from .entity_id import HouseholdId, UserId


@dataclass(eq=False)
class Household:
    """Household aggregate root.

    Owns all financial data. Users are members of households.

    Attributes:
        id: Unique household identifier
        name: Display name (e.g., "Smith Family")
        owner_id: UserId of the household creator/owner
        created_at: When household was created
        updated_at: Last modification timestamp
    """

    id: HouseholdId
    name: str
    owner_id: UserId
    created_at: datetime = field(default_factory=lambda: datetime.now(UTC))
    updated_at: datetime = field(default_factory=lambda: datetime.now(UTC))

    @classmethod
    def create(
        cls,
        name: str,
        owner_id: UserId,
    ) -> Self:
        """Create a new household.

        Args:
            name: Display name for the household
            owner_id: User who owns/created the household

        Returns:
            New Household instance with generated ID
        """
        now = datetime.now(UTC)
        return cls(
            id=HouseholdId.generate(),
            name=name,
            owner_id=owner_id,
            created_at=now,
            updated_at=now,
        )

    def update_name(self, name: str) -> None:
        """Update household display name."""
        self.name = name
        self.updated_at = datetime.now(UTC)
```

Update `src/domain/model/__init__.py` to export Household and HouseholdId.
  </action>
  <verify>
Run `python -c "from src.domain.model import Household, HouseholdId, UserId; u = UserId.generate(); h = Household.create('Test', u); print(h.id, h.name)"` to verify entity creation.
  </verify>
  <done>Household entity exists with id, name, owner_id, timestamps, and create() factory method.</done>
</task>

<task type="auto">
  <name>Task 3: Create User domain entity and events</name>
  <files>src/domain/model/user.py, src/domain/model/__init__.py, src/domain/events/user_events.py, src/domain/events/__init__.py</files>
  <action>
Create User entity following the Account pattern. User stores authentication data and belongs to a household.

**src/domain/model/user.py:**
```python
"""User aggregate root for authentication and identity.

User handles authentication (email, password) and belongs to a Household
for data scoping. The domain model stores password_hash but does NOT
perform hashing - that's infrastructure concern (security adapter).
"""

from dataclasses import dataclass, field
from datetime import UTC, datetime
from typing import Self

from .entity_id import HouseholdId, UserId


@dataclass(eq=False)
class User:
    """User aggregate root.

    Handles authentication and household membership.

    Attributes:
        id: Unique user identifier
        email: Login identifier (unique, normalized to lowercase)
        display_name: User's display name
        password_hash: Argon2 password hash (set by infrastructure)
        household_id: Household this user belongs to
        email_verified: Whether email has been verified
        email_verified_at: When email was verified (None if not verified)
        created_at: When user was created
        updated_at: Last modification timestamp
    """

    id: UserId
    email: str
    display_name: str
    password_hash: str
    household_id: HouseholdId
    email_verified: bool = False
    email_verified_at: datetime | None = None
    created_at: datetime = field(default_factory=lambda: datetime.now(UTC))
    updated_at: datetime = field(default_factory=lambda: datetime.now(UTC))

    # Collected domain events (cleared after persistence)
    _events: list = field(default_factory=list, repr=False, compare=False)

    @classmethod
    def create(
        cls,
        email: str,
        display_name: str,
        password_hash: str,
        household_id: HouseholdId,
    ) -> Self:
        """Create a new user.

        Email is normalized to lowercase. Password hashing must be done
        by the caller (infrastructure concern).

        Args:
            email: User's email address (will be lowercased)
            display_name: User's display name
            password_hash: Pre-hashed password (Argon2)
            household_id: Household this user belongs to

        Returns:
            New User instance with generated ID
        """
        from src.domain.events.user_events import UserRegistered

        now = datetime.now(UTC)
        user = cls(
            id=UserId.generate(),
            email=email.lower().strip(),
            display_name=display_name.strip(),
            password_hash=password_hash,
            household_id=household_id,
            email_verified=False,
            email_verified_at=None,
            created_at=now,
            updated_at=now,
        )
        user._events.append(UserRegistered(
            user_id=str(user.id),
            email=user.email,
            household_id=str(household_id),
            occurred_at=now,
        ))
        return user

    def verify_email(self) -> None:
        """Mark email as verified."""
        from src.domain.events.user_events import EmailVerified

        if self.email_verified:
            return  # Already verified, no-op

        now = datetime.now(UTC)
        self.email_verified = True
        self.email_verified_at = now
        self.updated_at = now
        self._events.append(EmailVerified(
            user_id=str(self.id),
            email=self.email,
            occurred_at=now,
        ))

    def update_display_name(self, name: str) -> None:
        """Update user's display name."""
        self.display_name = name.strip()
        self.updated_at = datetime.now(UTC)

    def collect_events(self) -> list:
        """Return and clear collected domain events."""
        events = self._events.copy()
        self._events.clear()
        return events
```

**src/domain/events/user_events.py:**
```python
"""Domain events for User aggregate."""

from dataclasses import dataclass, field
from datetime import UTC, datetime


@dataclass(frozen=True, slots=True)
class UserRegistered:
    """Emitted when a new user registers."""
    user_id: str
    email: str
    household_id: str
    occurred_at: datetime = field(default_factory=lambda: datetime.now(UTC))


@dataclass(frozen=True, slots=True)
class EmailVerified:
    """Emitted when user verifies their email."""
    user_id: str
    email: str
    occurred_at: datetime = field(default_factory=lambda: datetime.now(UTC))
```

Update `src/domain/model/__init__.py` to export User.
Update `src/domain/events/__init__.py` to export user events.
  </action>
  <verify>
Run `python -c "from src.domain.model import User, Household, UserId, HouseholdId; hh = HouseholdId.generate(); u = User.create('Test@Example.COM', 'Test User', 'hash123', hh); print(u.email, u.household_id); print(u.collect_events())"` to verify entity creation and event emission.
  </verify>
  <done>User entity exists with authentication fields, email normalization, verify_email() method, and emits UserRegistered/EmailVerified events.</done>
</task>

</tasks>

<verification>
All domain entities follow existing patterns:
1. `python -c "from src.domain.model import HouseholdId, Household, User, UserId"` - imports work
2. `python -c "from src.domain.events.user_events import UserRegistered, EmailVerified"` - events importable
3. `make lint` passes (no infrastructure imports in domain)
4. Domain layer remains pure (check with import-linter: `lint-imports`)
</verification>

<success_criteria>
- HouseholdId follows TypeID pattern with "hh_" prefix
- Household entity has create() factory, name, owner_id
- User entity has create() factory, email normalization, verify_email()
- User emits UserRegistered on create, EmailVerified on verify
- All exports added to __init__.py files
- No infrastructure imports in domain layer
</success_criteria>

<output>
After completion, create `.planning/phases/04-authentication-infrastructure/04-01-SUMMARY.md`
</output>
