---
phase: 04-authentication-infrastructure
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/domain/model/entity_id.py
  - src/domain/model/user.py
  - src/domain/model/household.py
  - src/domain/model/__init__.py
  - src/domain/events/user_events.py
  - src/domain/events/__init__.py
  - tests/unit/domain/test_user.py
  - tests/unit/domain/test_household.py
autonomous: true

must_haves:
  truths:
    - "User entity exists with email, display_name, password_hash, household_id"
    - "Household entity exists with name and owner_id"
    - "HouseholdId and UserId follow existing TypeID pattern"
    - "Domain events exist for user registration and email verification"
  artifacts:
    - path: "src/domain/model/user.py"
      provides: "User entity with authentication fields"
      contains: "class User"
    - path: "src/domain/model/household.py"
      provides: "Household entity for data scoping"
      contains: "class Household"
    - path: "src/domain/model/entity_id.py"
      provides: "HouseholdId TypeID"
      contains: "class HouseholdId"
    - path: "src/domain/events/user_events.py"
      provides: "User domain events"
      contains: "UserRegistered"
  key_links:
    - from: "src/domain/model/user.py"
      to: "src/domain/model/entity_id.py"
      via: "UserId and HouseholdId imports"
      pattern: "from.*entity_id import.*UserId.*HouseholdId"
---

<objective>
Create User and Household domain entities with supporting ID types and events using TDD.

Purpose: Establish the domain model foundation for authentication. User holds identity and credentials, Household enables multi-user data scoping. TDD ensures behavior is specified before implementation.

Output: Domain entities (User, Household), HouseholdId type, domain events, and comprehensive unit tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-authentication-infrastructure/04-CONTEXT.md
@.planning/phases/04-authentication-infrastructure/04-RESEARCH.md
@src/domain/model/entity_id.py
@src/domain/model/account.py
@src/domain/events/account_events.py
</context>

<tasks>

<task id="1">
  <title>Write failing tests for HouseholdId</title>
  <type>test</type>
  <files>tests/unit/domain/test_household.py</files>
  <action>
Create test file with tests for HouseholdId following existing TypeID patterns:

```python
"""Tests for Household domain model."""

import pytest

class TestHouseholdId:
    """Tests for HouseholdId TypeID."""

    def test_generate_creates_valid_id(self) -> None:
        """Generated HouseholdId has 'hh_' prefix."""
        from src.domain.model.entity_id import HouseholdId

        hh_id = HouseholdId.generate()

        assert str(hh_id).startswith("hh_")
        assert len(str(hh_id)) > 10  # TypeID format

    def test_from_string_parses_valid_id(self) -> None:
        """HouseholdId can be parsed from valid string."""
        from src.domain.model.entity_id import HouseholdId

        original = HouseholdId.generate()
        parsed = HouseholdId.from_string(str(original))

        assert str(parsed) == str(original)

    def test_from_string_rejects_wrong_prefix(self) -> None:
        """HouseholdId rejects non-hh prefixes."""
        from src.domain.model.entity_id import HouseholdId

        with pytest.raises(ValueError, match="hh"):
            HouseholdId.from_string("user_01h455vb4pex5vsknk084sn02q")

    def test_prefix_property_returns_hh(self) -> None:
        """HouseholdId.prefix returns 'hh'."""
        from src.domain.model.entity_id import HouseholdId

        hh_id = HouseholdId.generate()

        assert hh_id.prefix == "hh"
```
  </action>
  <verify>pytest tests/unit/domain/test_household.py::TestHouseholdId -x (should FAIL - HouseholdId doesn't exist)</verify>
  <done>Test file exists with 4 tests for HouseholdId, all fail with ImportError</done>
</task>

<task id="2">
  <title>Implement HouseholdId to pass tests</title>
  <type>impl</type>
  <files>src/domain/model/entity_id.py</files>
  <action>
Add HouseholdId dataclass following the exact pattern of existing ID types (AccountId, UserId):

```python
@dataclass(frozen=True, slots=True)
class HouseholdId:
    """Identifier for Household aggregate root.

    Format: hh_01h455vb4pex5vsknk084sn02q
    """
    value: str

    @classmethod
    def generate(cls) -> Self:
        """Generate a new HouseholdId."""
        tid = TypeID(prefix="hh")
        return cls(value=str(tid))

    @classmethod
    def from_string(cls, value: str) -> Self:
        """Parse and validate a HouseholdId from string."""
        tid = TypeID.from_string(value)
        if tid.prefix != "hh":
            raise ValueError(f"Expected 'hh' prefix, got '{tid.prefix}'")
        return cls(value=value)

    @property
    def prefix(self) -> str:
        return "hh"

    def __str__(self) -> str:
        return self.value
```

Place after UserId definition to maintain alphabetical grouping of ID types.
  </action>
  <verify>pytest tests/unit/domain/test_household.py::TestHouseholdId -x (should PASS)</verify>
  <done>HouseholdId follows TypeID pattern, all 4 tests pass</done>
</task>

<task id="3">
  <title>Write failing tests for Household entity</title>
  <type>test</type>
  <files>tests/unit/domain/test_household.py</files>
  <action>
Add tests for Household entity to the existing test file:

```python
class TestHousehold:
    """Tests for Household aggregate root."""

    def test_create_generates_id(self) -> None:
        """Household.create() generates a new HouseholdId."""
        from src.domain.model.entity_id import UserId
        from src.domain.model.household import Household

        owner_id = UserId.generate()
        household = Household.create(name="Smith Family", owner_id=owner_id)

        assert household.id is not None
        assert str(household.id).startswith("hh_")

    def test_create_stores_name_and_owner(self) -> None:
        """Household.create() stores name and owner_id."""
        from src.domain.model.entity_id import UserId
        from src.domain.model.household import Household

        owner_id = UserId.generate()
        household = Household.create(name="Test Household", owner_id=owner_id)

        assert household.name == "Test Household"
        assert household.owner_id == owner_id

    def test_create_sets_timestamps(self) -> None:
        """Household.create() sets created_at and updated_at."""
        from src.domain.model.entity_id import UserId
        from src.domain.model.household import Household

        owner_id = UserId.generate()
        household = Household.create(name="Test", owner_id=owner_id)

        assert household.created_at is not None
        assert household.updated_at is not None
        assert household.created_at == household.updated_at

    def test_update_name_changes_name_and_updated_at(self) -> None:
        """update_name() changes name and updates timestamp."""
        from src.domain.model.entity_id import UserId
        from src.domain.model.household import Household
        import time

        owner_id = UserId.generate()
        household = Household.create(name="Old Name", owner_id=owner_id)
        old_updated = household.updated_at

        time.sleep(0.01)  # Ensure timestamp changes
        household.update_name("New Name")

        assert household.name == "New Name"
        assert household.updated_at > old_updated
```
  </action>
  <verify>pytest tests/unit/domain/test_household.py::TestHousehold -x (should FAIL - Household doesn't exist)</verify>
  <done>Test file has 4 tests for Household entity, all fail with ImportError</done>
</task>

<task id="4">
  <title>Implement Household entity to pass tests</title>
  <type>impl</type>
  <files>src/domain/model/household.py, src/domain/model/__init__.py</files>
  <action>
Create Household entity following the Account pattern:

**src/domain/model/household.py:**
```python
"""Household aggregate root for multi-user data scoping.

A Household owns all financial data (accounts, transactions, categories).
Users belong to households. Initially one household per user, but the
model supports multiple users per household (future Phase 25).
"""

from dataclasses import dataclass, field
from datetime import UTC, datetime
from typing import Self

from .entity_id import HouseholdId, UserId


@dataclass(eq=False)
class Household:
    """Household aggregate root.

    Owns all financial data. Users are members of households.

    Attributes:
        id: Unique household identifier
        name: Display name (e.g., "Smith Family")
        owner_id: UserId of the household creator/owner
        created_at: When household was created
        updated_at: Last modification timestamp
    """

    id: HouseholdId
    name: str
    owner_id: UserId
    created_at: datetime = field(default_factory=lambda: datetime.now(UTC))
    updated_at: datetime = field(default_factory=lambda: datetime.now(UTC))

    @classmethod
    def create(
        cls,
        name: str,
        owner_id: UserId,
    ) -> Self:
        """Create a new household.

        Args:
            name: Display name for the household
            owner_id: User who owns/created the household

        Returns:
            New Household instance with generated ID
        """
        now = datetime.now(UTC)
        return cls(
            id=HouseholdId.generate(),
            name=name,
            owner_id=owner_id,
            created_at=now,
            updated_at=now,
        )

    def update_name(self, name: str) -> None:
        """Update household display name."""
        self.name = name
        self.updated_at = datetime.now(UTC)
```

Update `src/domain/model/__init__.py` to export Household and HouseholdId.
  </action>
  <verify>pytest tests/unit/domain/test_household.py -x (should PASS - all Household tests)</verify>
  <done>Household entity exists with create() factory and update_name(), all tests pass</done>
</task>

<task id="5">
  <title>Write failing tests for User entity and events</title>
  <type>test</type>
  <files>tests/unit/domain/test_user.py</files>
  <action>
Create test file for User entity:

```python
"""Tests for User domain model."""

import pytest


class TestUserCreate:
    """Tests for User.create() factory method."""

    def test_create_generates_id(self) -> None:
        """User.create() generates a new UserId."""
        from src.domain.model.entity_id import HouseholdId
        from src.domain.model.user import User

        hh_id = HouseholdId.generate()
        user = User.create(
            email="test@example.com",
            display_name="Test User",
            password_hash="hashed_password",
            household_id=hh_id,
        )

        assert user.id is not None
        assert str(user.id).startswith("user_")

    def test_create_normalizes_email_to_lowercase(self) -> None:
        """User.create() lowercases and strips email."""
        from src.domain.model.entity_id import HouseholdId
        from src.domain.model.user import User

        hh_id = HouseholdId.generate()
        user = User.create(
            email="  Test@Example.COM  ",
            display_name="Test",
            password_hash="hash",
            household_id=hh_id,
        )

        assert user.email == "test@example.com"

    def test_create_strips_display_name(self) -> None:
        """User.create() strips whitespace from display_name."""
        from src.domain.model.entity_id import HouseholdId
        from src.domain.model.user import User

        hh_id = HouseholdId.generate()
        user = User.create(
            email="test@example.com",
            display_name="  Test User  ",
            password_hash="hash",
            household_id=hh_id,
        )

        assert user.display_name == "Test User"

    def test_create_sets_email_verified_false(self) -> None:
        """User.create() sets email_verified to False."""
        from src.domain.model.entity_id import HouseholdId
        from src.domain.model.user import User

        hh_id = HouseholdId.generate()
        user = User.create(
            email="test@example.com",
            display_name="Test",
            password_hash="hash",
            household_id=hh_id,
        )

        assert user.email_verified is False
        assert user.email_verified_at is None

    def test_create_emits_user_registered_event(self) -> None:
        """User.create() emits UserRegistered domain event."""
        from src.domain.model.entity_id import HouseholdId
        from src.domain.model.user import User
        from src.domain.events.user_events import UserRegistered

        hh_id = HouseholdId.generate()
        user = User.create(
            email="test@example.com",
            display_name="Test",
            password_hash="hash",
            household_id=hh_id,
        )

        events = user.collect_events()

        assert len(events) == 1
        assert isinstance(events[0], UserRegistered)
        assert events[0].email == "test@example.com"
        assert events[0].user_id == str(user.id)


class TestUserVerifyEmail:
    """Tests for User.verify_email() method."""

    def test_verify_email_sets_verified_true(self) -> None:
        """verify_email() sets email_verified to True."""
        from src.domain.model.entity_id import HouseholdId
        from src.domain.model.user import User

        hh_id = HouseholdId.generate()
        user = User.create("test@example.com", "Test", "hash", hh_id)
        user.collect_events()  # Clear registration event

        user.verify_email()

        assert user.email_verified is True
        assert user.email_verified_at is not None

    def test_verify_email_emits_email_verified_event(self) -> None:
        """verify_email() emits EmailVerified domain event."""
        from src.domain.model.entity_id import HouseholdId
        from src.domain.model.user import User
        from src.domain.events.user_events import EmailVerified

        hh_id = HouseholdId.generate()
        user = User.create("test@example.com", "Test", "hash", hh_id)
        user.collect_events()  # Clear registration event

        user.verify_email()
        events = user.collect_events()

        assert len(events) == 1
        assert isinstance(events[0], EmailVerified)
        assert events[0].email == "test@example.com"

    def test_verify_email_is_idempotent(self) -> None:
        """verify_email() on already verified user is a no-op."""
        from src.domain.model.entity_id import HouseholdId
        from src.domain.model.user import User

        hh_id = HouseholdId.generate()
        user = User.create("test@example.com", "Test", "hash", hh_id)
        user.collect_events()

        user.verify_email()
        first_verified_at = user.email_verified_at
        user.collect_events()  # Clear first event

        user.verify_email()  # Second call
        events = user.collect_events()

        assert len(events) == 0  # No new event
        assert user.email_verified_at == first_verified_at  # Timestamp unchanged


class TestUserCollectEvents:
    """Tests for User.collect_events() method."""

    def test_collect_events_clears_after_collection(self) -> None:
        """collect_events() clears the event list."""
        from src.domain.model.entity_id import HouseholdId
        from src.domain.model.user import User

        hh_id = HouseholdId.generate()
        user = User.create("test@example.com", "Test", "hash", hh_id)

        first = user.collect_events()
        second = user.collect_events()

        assert len(first) == 1
        assert len(second) == 0
```
  </action>
  <verify>pytest tests/unit/domain/test_user.py -x (should FAIL - User doesn't exist)</verify>
  <done>Test file has 9 tests for User entity, all fail with ImportError</done>
</task>

<task id="6">
  <title>Implement User entity and events to pass tests</title>
  <type>impl</type>
  <files>src/domain/model/user.py, src/domain/model/__init__.py, src/domain/events/user_events.py, src/domain/events/__init__.py</files>
  <action>
Create User entity and domain events.

**src/domain/events/user_events.py:**
```python
"""Domain events for User aggregate."""

from dataclasses import dataclass, field
from datetime import UTC, datetime


@dataclass(frozen=True, slots=True)
class UserRegistered:
    """Emitted when a new user registers."""
    user_id: str
    email: str
    household_id: str
    occurred_at: datetime = field(default_factory=lambda: datetime.now(UTC))


@dataclass(frozen=True, slots=True)
class EmailVerified:
    """Emitted when user verifies their email."""
    user_id: str
    email: str
    occurred_at: datetime = field(default_factory=lambda: datetime.now(UTC))
```

**src/domain/model/user.py:**
```python
"""User aggregate root for authentication and identity.

User handles authentication (email, password) and belongs to a Household
for data scoping. The domain model stores password_hash but does NOT
perform hashing - that's infrastructure concern (security adapter).
"""

from dataclasses import dataclass, field
from datetime import UTC, datetime
from typing import Self

from .entity_id import HouseholdId, UserId


@dataclass(eq=False)
class User:
    """User aggregate root.

    Handles authentication and household membership.

    Attributes:
        id: Unique user identifier
        email: Login identifier (unique, normalized to lowercase)
        display_name: User's display name
        password_hash: Argon2 password hash (set by infrastructure)
        household_id: Household this user belongs to
        email_verified: Whether email has been verified
        email_verified_at: When email was verified (None if not verified)
        created_at: When user was created
        updated_at: Last modification timestamp
    """

    id: UserId
    email: str
    display_name: str
    password_hash: str
    household_id: HouseholdId
    email_verified: bool = False
    email_verified_at: datetime | None = None
    created_at: datetime = field(default_factory=lambda: datetime.now(UTC))
    updated_at: datetime = field(default_factory=lambda: datetime.now(UTC))

    # Collected domain events (cleared after persistence)
    _events: list = field(default_factory=list, repr=False, compare=False)

    @classmethod
    def create(
        cls,
        email: str,
        display_name: str,
        password_hash: str,
        household_id: HouseholdId,
    ) -> Self:
        """Create a new user.

        Email is normalized to lowercase. Password hashing must be done
        by the caller (infrastructure concern).

        Args:
            email: User's email address (will be lowercased)
            display_name: User's display name
            password_hash: Pre-hashed password (Argon2)
            household_id: Household this user belongs to

        Returns:
            New User instance with generated ID
        """
        from src.domain.events.user_events import UserRegistered

        now = datetime.now(UTC)
        user = cls(
            id=UserId.generate(),
            email=email.lower().strip(),
            display_name=display_name.strip(),
            password_hash=password_hash,
            household_id=household_id,
            email_verified=False,
            email_verified_at=None,
            created_at=now,
            updated_at=now,
        )
        user._events.append(UserRegistered(
            user_id=str(user.id),
            email=user.email,
            household_id=str(household_id),
            occurred_at=now,
        ))
        return user

    def verify_email(self) -> None:
        """Mark email as verified."""
        from src.domain.events.user_events import EmailVerified

        if self.email_verified:
            return  # Already verified, no-op

        now = datetime.now(UTC)
        self.email_verified = True
        self.email_verified_at = now
        self.updated_at = now
        self._events.append(EmailVerified(
            user_id=str(self.id),
            email=self.email,
            occurred_at=now,
        ))

    def update_display_name(self, name: str) -> None:
        """Update user's display name."""
        self.display_name = name.strip()
        self.updated_at = datetime.now(UTC)

    def collect_events(self) -> list:
        """Return and clear collected domain events."""
        events = self._events.copy()
        self._events.clear()
        return events
```

Update `src/domain/model/__init__.py` to export User.
Update `src/domain/events/__init__.py` to export user events.
  </action>
  <verify>pytest tests/unit/domain/test_user.py tests/unit/domain/test_household.py -x (should PASS - all tests)</verify>
  <done>User entity and events implemented, all 13 domain tests pass</done>
</task>

</tasks>

<verification>
All domain entities follow existing patterns:
1. `pytest tests/unit/domain/test_user.py tests/unit/domain/test_household.py -v` - all tests pass
2. `python -c "from src.domain.model import HouseholdId, Household, User, UserId"` - imports work
3. `python -c "from src.domain.events.user_events import UserRegistered, EmailVerified"` - events importable
4. `make lint` passes (no infrastructure imports in domain)
</verification>

<success_criteria>
- HouseholdId follows TypeID pattern with "hh_" prefix (4 tests)
- Household entity has create() factory, name, owner_id (4 tests)
- User entity has create() factory, email normalization, verify_email() (9 tests)
- User emits UserRegistered on create, EmailVerified on verify
- All exports added to __init__.py files
- No infrastructure imports in domain layer
</success_criteria>

<output>
After completion, create `.planning/phases/04-authentication-infrastructure/04-01-SUMMARY.md`
</output>
