---
phase: 04-authentication-infrastructure
plan: 08
type: tdd
wave: 4
depends_on: ["04-06", "04-07"]
files_modified:
  - tests/conftest.py
  - tests/integration/api/test_auth.py
autonomous: true

must_haves:
  truths:
    - "Auth tests verify registration, login, refresh, verify-email flows"
    - "Test fixtures create authenticated user context"
  artifacts:
    - path: "tests/integration/api/test_auth.py"
      provides: "Authentication endpoint tests"
      contains: "test_register"
    - path: "tests/conftest.py"
      provides: "Auth fixtures for tests"
      contains: "auth_headers"
  key_links:
    - from: "tests/integration/api/test_auth.py"
      to: "tests/conftest.py"
      via: "auth fixtures"
      pattern: "registered_user|auth_headers|auth_tokens"
---

<objective>
Create authentication test fixtures and auth endpoint integration tests.

Purpose: Verify authentication works end-to-end. Write auth endpoint tests first (RED), then ensure the full system passes (GREEN). Fixtures provide reusable authenticated context for all future tests.

Output: Auth endpoint tests (14+ tests), reusable auth fixtures in conftest.py.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-authentication-infrastructure/04-CONTEXT.md
@.planning/phases/04-authentication-infrastructure/04-RESEARCH.md
@tests/conftest.py
</context>

<tasks>

<task id="1">
  <title>Write auth test fixtures and auth endpoint tests</title>
  <type>test</type>
  <files>tests/conftest.py, tests/integration/api/test_auth.py</files>
  <action>
**Add auth fixtures to tests/conftest.py:**

```python
@pytest.fixture
def test_user_data() -> dict:
    """Test user credentials."""
    return {
        "email": f"test_{uuid.uuid4().hex[:8]}@example.com",
        "password": "TestPassword123!",
        "display_name": "Test User",
    }

@pytest.fixture
def registered_user(client: TestClient, test_user_data: dict) -> dict:
    """Register a test user and verify their email."""
    # Register
    response = client.post("/auth/register", json=test_user_data)
    assert response.status_code == 202

    # Verify email
    from src.adapters.security.tokens import generate_verification_token
    verification_token = generate_verification_token(test_user_data["email"])
    response = client.get(f"/auth/verify?token={verification_token}")
    assert response.status_code == 200

    return {**test_user_data, "user_id": response.json()["user_id"]}

@pytest.fixture
def auth_tokens(client: TestClient, registered_user: dict) -> dict:
    """Login and return tokens."""
    response = client.post(
        "/auth/token",
        data={"username": registered_user["email"], "password": registered_user["password"]},
    )
    assert response.status_code == 200
    return response.json()

@pytest.fixture
def auth_headers(auth_tokens: dict) -> dict:
    """Authorization headers for authenticated requests."""
    return {"Authorization": f"Bearer {auth_tokens['access_token']}"}
```

**Create tests/integration/api/test_auth.py:**

```python
"""Authentication endpoint integration tests."""

class TestRegistration:
    def test_register_success(self, client) -> None:
        """Registration returns 202."""
        # POST /auth/register with valid data -> 202

    def test_register_weak_password_rejected(self, client) -> None:
        """Weak password returns 422."""

    def test_register_invalid_email_rejected(self, client) -> None:
        """Invalid email returns 422."""

    def test_register_duplicate_email_returns_202(self, client, registered_user) -> None:
        """Duplicate email returns 202 (enumeration protection)."""

class TestLogin:
    def test_login_success(self, client, registered_user) -> None:
        """Login returns access token and sets refresh cookie."""

    def test_login_wrong_password(self, client, registered_user) -> None:
        """Wrong password returns 401."""

    def test_login_nonexistent_email(self, client) -> None:
        """Nonexistent email returns 401."""

    def test_login_unverified_email(self, client) -> None:
        """Unverified email returns 401."""

class TestTokenRefresh:
    def test_refresh_success(self, client, registered_user) -> None:
        """Refresh returns new access token."""

    def test_refresh_without_cookie(self, client) -> None:
        """Refresh without cookie returns 401."""

class TestEmailVerification:
    def test_verify_success(self, client) -> None:
        """Valid token verifies email."""

    def test_verify_invalid_token(self, client) -> None:
        """Invalid token returns 400."""

class TestProtectedRoutes:
    def test_accounts_requires_auth(self, client) -> None:
        """Accounts returns 401 without token."""

    def test_accounts_with_valid_token(self, client, auth_headers) -> None:
        """Accounts works with valid token."""

    def test_accounts_with_invalid_token(self, client) -> None:
        """Invalid token returns 401."""
```

Write full test implementations following the patterns described above.
  </action>
  <verify>pytest tests/integration/api/test_auth.py -x -v (should FAIL or PASS depending on system state -- tests exercise real auth flow)</verify>
  <done>Auth endpoint tests and fixtures exist, covering register, login, refresh, verify, route protection (14+ tests)</done>
</task>

<task id="2">
  <title>Fix any auth integration failures to make tests green</title>
  <type>impl</type>
  <files>tests/integration/api/test_auth.py, tests/conftest.py</files>
  <action>
Run auth tests and fix any failures. This is the GREEN phase -- iterate on test code or fixture setup until all 14+ auth tests pass.

Common issues to watch for:
- Fixture ordering (registered_user must complete before auth_tokens)
- Cookie extraction for refresh token tests
- Correct endpoint paths (/auth/register, /auth/token, /auth/refresh, /auth/verify)
- Test database cleanup between tests (session-scoped setup with per-test rollback)

Do NOT modify application code in this task -- only test code. If application code bugs are found, document them for separate fixing.
  </action>
  <verify>pytest tests/integration/api/test_auth.py -v (all 14+ auth tests PASS)</verify>
  <done>All auth endpoint tests pass. Auth fixtures (registered_user, auth_tokens, auth_headers) work correctly.</done>
</task>

</tasks>

<verification>
Auth test suite is complete:
1. `pytest tests/integration/api/test_auth.py -v` - all auth tests pass
2. Auth fixtures chain correctly: test_user_data -> registered_user -> auth_tokens -> auth_headers
3. Tests cover: register (4), login (4), refresh (2), verify (2), route protection (3)
</verification>

<success_criteria>
- Auth fixtures: registered_user, auth_tokens, auth_headers work correctly
- Auth tests cover: register, login, refresh, verify, error cases (14+ tests)
- Tests verify route protection (401 without token)
- All auth tests pass: `pytest tests/integration/api/test_auth.py -v`
</success_criteria>

<output>
After completion, create `.planning/phases/04-authentication-infrastructure/04-08-SUMMARY.md`
</output>
