---
phase: 04-authentication-infrastructure
plan: 08
type: tdd
wave: 4
depends_on: ["04-06", "04-07"]
files_modified:
  - tests/conftest.py
  - tests/integration/api/test_accounts.py
  - tests/integration/api/test_transactions.py
  - tests/integration/api/test_categories.py
  - tests/integration/api/test_auth.py
autonomous: true

must_haves:
  truths:
    - "Auth tests verify registration, login, refresh, verify-email flows"
    - "Existing E2E tests use real auth flow (register, login, use JWT)"
    - "Test fixtures create authenticated user context"
    - "All existing tests pass with authentication"
  artifacts:
    - path: "tests/integration/api/test_auth.py"
      provides: "Authentication endpoint tests"
      contains: "test_register"
    - path: "tests/conftest.py"
      provides: "Auth fixtures for tests"
      contains: "auth_headers"
  key_links:
    - from: "tests/integration/api/test_accounts.py"
      to: "tests/conftest.py"
      via: "auth fixture"
      pattern: "auth_headers|authenticated_client"
---

<objective>
Create authentication integration tests and update existing E2E tests to use real auth flow using TDD.

Purpose: Verify authentication works end-to-end. Write auth endpoint tests first (RED), then ensure the full system passes (GREEN), then update existing tests to use auth fixtures.

Output: Auth endpoint tests, updated fixtures, all tests passing.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-authentication-infrastructure/04-CONTEXT.md
@.planning/phases/04-authentication-infrastructure/04-RESEARCH.md
@tests/conftest.py
@tests/integration/api/test_accounts.py
@tests/integration/api/test_transactions.py
</context>

<tasks>

<task id="1">
  <title>Write auth test fixtures and auth endpoint tests</title>
  <type>test</type>
  <files>tests/conftest.py, tests/integration/api/test_auth.py</files>
  <action>
**Add auth fixtures to tests/conftest.py:**

```python
@pytest.fixture
def test_user_data() -> dict:
    """Test user credentials."""
    return {
        "email": f"test_{uuid.uuid4().hex[:8]}@example.com",
        "password": "TestPassword123!",
        "display_name": "Test User",
    }

@pytest.fixture
def registered_user(client: TestClient, test_user_data: dict) -> dict:
    """Register a test user and verify their email."""
    # Register
    response = client.post("/auth/register", json=test_user_data)
    assert response.status_code == 202

    # Verify email
    from src.adapters.security.tokens import generate_verification_token
    verification_token = generate_verification_token(test_user_data["email"])
    response = client.get(f"/auth/verify?token={verification_token}")
    assert response.status_code == 200

    return {**test_user_data, "user_id": response.json()["user_id"]}

@pytest.fixture
def auth_tokens(client: TestClient, registered_user: dict) -> dict:
    """Login and return tokens."""
    response = client.post(
        "/auth/token",
        data={"username": registered_user["email"], "password": registered_user["password"]},
    )
    assert response.status_code == 200
    return response.json()

@pytest.fixture
def auth_headers(auth_tokens: dict) -> dict:
    """Authorization headers for authenticated requests."""
    return {"Authorization": f"Bearer {auth_tokens['access_token']}"}
```

**Create tests/integration/api/test_auth.py:**

```python
"""Authentication endpoint integration tests."""

class TestRegistration:
    def test_register_success(self, client) -> None:
        """Registration returns 202."""
        # POST /auth/register with valid data -> 202

    def test_register_weak_password_rejected(self, client) -> None:
        """Weak password returns 422."""

    def test_register_invalid_email_rejected(self, client) -> None:
        """Invalid email returns 422."""

    def test_register_duplicate_email_returns_202(self, client, registered_user) -> None:
        """Duplicate email returns 202 (enumeration protection)."""

class TestLogin:
    def test_login_success(self, client, registered_user) -> None:
        """Login returns access token and sets refresh cookie."""

    def test_login_wrong_password(self, client, registered_user) -> None:
        """Wrong password returns 401."""

    def test_login_nonexistent_email(self, client) -> None:
        """Nonexistent email returns 401."""

    def test_login_unverified_email(self, client) -> None:
        """Unverified email returns 401."""

class TestTokenRefresh:
    def test_refresh_success(self, client, registered_user) -> None:
        """Refresh returns new access token."""

    def test_refresh_without_cookie(self, client) -> None:
        """Refresh without cookie returns 401."""

class TestEmailVerification:
    def test_verify_success(self, client) -> None:
        """Valid token verifies email."""

    def test_verify_invalid_token(self, client) -> None:
        """Invalid token returns 400."""

class TestProtectedRoutes:
    def test_accounts_requires_auth(self, client) -> None:
        """Accounts returns 401 without token."""

    def test_accounts_with_valid_token(self, client, auth_headers) -> None:
        """Accounts works with valid token."""

    def test_accounts_with_invalid_token(self, client) -> None:
        """Invalid token returns 401."""
```

Write full test implementations following the patterns described above.
  </action>
  <verify>pytest tests/integration/api/test_auth.py -x (should FAIL or PASS depending on system state -- tests exercise real auth flow)</verify>
  <done>Auth endpoint tests and fixtures exist, covering register, login, refresh, verify, route protection</done>
</task>

<task id="2">
  <title>Fix any integration failures and update existing E2E tests</title>
  <type>impl</type>
  <files>tests/integration/api/test_accounts.py, tests/integration/api/test_transactions.py, tests/integration/api/test_categories.py</files>
  <action>
**Update all existing integration tests to use auth_headers fixture:**

1. Add `auth_headers` parameter to all test methods that call protected endpoints:
```python
def test_create_checking_account(
    self, client: TestClient, auth_headers: dict
) -> None:
    response = client.post(
        "/api/v1/accounts/checking",
        json={...},
        headers=auth_headers,  # Add this
    )
```

2. For tests that verify household isolation, create two users and verify one can't see the other's data.

3. Add household isolation test:
```python
class TestHouseholdIsolation:
    def test_cannot_access_other_household_account(
        self, client, auth_headers
    ) -> None:
        """Accessing another household's account returns 404."""
        # Create account with first user
        # Register + login as second user
        # Try to access first user's account -> 404
```

4. Run tests incrementally -- fix one file at a time, ensure it passes.
  </action>
  <verify>pytest tests/integration/api/ -v (all tests should PASS with authentication)</verify>
  <done>All existing E2E tests use real auth flow, household isolation verified, all tests pass</done>
</task>

</tasks>

<verification>
Test suite is complete:
1. `pytest tests/integration/api/test_auth.py -v` - all auth tests pass
2. `pytest tests/integration/api/test_accounts.py -v` - all account tests pass with auth
3. `pytest tests/integration/api/test_transactions.py -v` - all transaction tests pass
4. `pytest tests/integration/api/test_categories.py -v` - all category tests pass
5. Household isolation test confirms cross-household returns 404
</verification>

<success_criteria>
- Auth fixtures: registered_user, auth_tokens, auth_headers work correctly
- Auth tests cover: register, login, refresh, verify, error cases (14+ tests)
- All existing tests updated to use auth_headers
- Tests verify route protection (401 without token)
- Household isolation test verifies 404 for cross-household access
- All tests pass: `pytest tests/integration/api/ -v`
</success_criteria>

<output>
After completion, create `.planning/phases/04-authentication-infrastructure/04-08-SUMMARY.md`
</output>
