---
phase: 04-authentication-infrastructure
plan: 08
type: execute
wave: 4
depends_on: ["04-06", "04-07"]
files_modified:
  - tests/conftest.py
  - tests/integration/api/test_accounts.py
  - tests/integration/api/test_transactions.py
  - tests/integration/api/test_categories.py
  - tests/integration/api/test_auth.py
autonomous: true

must_haves:
  truths:
    - "Auth tests verify registration, login, refresh, verify-email flows"
    - "Existing E2E tests use real auth flow (register, login, use JWT)"
    - "Test fixtures create authenticated user context"
    - "All existing tests pass with authentication"
  artifacts:
    - path: "tests/integration/api/test_auth.py"
      provides: "Authentication endpoint tests"
      contains: "test_register"
    - path: "tests/conftest.py"
      provides: "Auth fixtures for tests"
      contains: "auth_headers"
  key_links:
    - from: "tests/integration/api/test_accounts.py"
      to: "tests/conftest.py"
      via: "auth fixture"
      pattern: "auth_headers|authenticated_client"
---

<objective>
Create authentication tests and update existing E2E tests to use real auth flow.

Purpose: Verify authentication works end-to-end and ensure all existing tests pass with the new auth requirements.

Output: Auth endpoint tests, updated fixtures, all tests passing.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-authentication-infrastructure/04-CONTEXT.md
@.planning/phases/04-authentication-infrastructure/04-RESEARCH.md
@tests/conftest.py
@tests/integration/api/test_accounts.py
@tests/integration/api/test_transactions.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create auth test fixtures in conftest.py</name>
  <files>tests/conftest.py</files>
  <action>
Add fixtures for authenticated testing.

Add imports:
```python
from src.adapters.security.tokens import generate_verification_token
from src.application.services.auth_service import AuthService
```

Add test user fixture:
```python
@pytest.fixture
def test_user_data() -> dict:
    """Test user credentials."""
    return {
        "email": f"test_{uuid.uuid4().hex[:8]}@example.com",
        "password": "TestPassword123!",
        "display_name": "Test User",
    }


@pytest.fixture
def registered_user(client: TestClient, test_user_data: dict) -> dict:
    """Register a test user and verify their email.

    Returns dict with user data including user_id.
    """
    # Register
    response = client.post("/auth/register", json=test_user_data)
    assert response.status_code == 202

    # Verify email (get token from service directly - in real app, email would be sent)
    verification_token = generate_verification_token(test_user_data["email"])
    response = client.get(f"/auth/verify?token={verification_token}")
    assert response.status_code == 200

    return {
        **test_user_data,
        "user_id": response.json()["user_id"],
    }


@pytest.fixture
def auth_tokens(client: TestClient, registered_user: dict) -> dict:
    """Login and return tokens.

    Returns dict with access_token.
    Refresh token is set as cookie automatically.
    """
    response = client.post(
        "/auth/token",
        data={
            "username": registered_user["email"],
            "password": registered_user["password"],
        },
    )
    assert response.status_code == 200
    return response.json()


@pytest.fixture
def auth_headers(auth_tokens: dict) -> dict:
    """Authorization headers for authenticated requests."""
    return {"Authorization": f"Bearer {auth_tokens['access_token']}"}


@pytest.fixture
def authenticated_client(client: TestClient, auth_headers: dict) -> TestClient:
    """Client with auth headers set.

    Note: For tests that need the client AND headers separately,
    use client + auth_headers fixtures directly.
    """
    # Add default headers to client
    client.headers.update(auth_headers)
    return client
```

These fixtures chain: test_user_data -> registered_user -> auth_tokens -> auth_headers
  </action>
  <verify>
Run a simple test to verify fixtures work: `pytest tests/conftest.py -v --collect-only` to see fixtures are defined.
  </verify>
  <done>Auth fixtures provide registered_user, auth_tokens, auth_headers for all tests.</done>
</task>

<task type="auto">
  <name>Task 2: Create authentication endpoint tests</name>
  <files>tests/integration/api/test_auth.py</files>
  <action>
Create comprehensive tests for authentication endpoints.

```python
"""Authentication endpoint tests.

Tests cover:
- Registration flow
- Login flow
- Token refresh
- Email verification
- Error handling
"""

import pytest
from fastapi.testclient import TestClient

from src.adapters.security.tokens import generate_verification_token


class TestRegistration:
    """Tests for POST /auth/register."""

    def test_register_success(self, client: TestClient) -> None:
        """Registration returns 202 with user info."""
        response = client.post(
            "/auth/register",
            json={
                "email": "newuser@example.com",
                "password": "ValidPass123!",
                "display_name": "New User",
            },
        )
        assert response.status_code == 202
        data = response.json()
        assert data["email"] == "newuser@example.com"
        assert "user_id" in data

    def test_register_weak_password_rejected(self, client: TestClient) -> None:
        """Registration fails with weak password."""
        response = client.post(
            "/auth/register",
            json={
                "email": "test@example.com",
                "password": "weak",
                "display_name": "Test",
            },
        )
        assert response.status_code == 422
        assert "8 characters" in str(response.json())

    def test_register_invalid_email_rejected(self, client: TestClient) -> None:
        """Registration fails with invalid email."""
        response = client.post(
            "/auth/register",
            json={
                "email": "not-an-email",
                "password": "ValidPass123!",
                "display_name": "Test",
            },
        )
        assert response.status_code == 422

    def test_register_duplicate_email_returns_202(
        self, client: TestClient, registered_user: dict
    ) -> None:
        """Duplicate email registration returns 202 (enumeration protection)."""
        response = client.post(
            "/auth/register",
            json={
                "email": registered_user["email"],
                "password": "AnotherPass123!",
                "display_name": "Another User",
            },
        )
        # Returns 202 to prevent email enumeration
        assert response.status_code == 202


class TestLogin:
    """Tests for POST /auth/token."""

    def test_login_success(
        self, client: TestClient, registered_user: dict
    ) -> None:
        """Login returns access token and sets refresh cookie."""
        response = client.post(
            "/auth/token",
            data={
                "username": registered_user["email"],
                "password": registered_user["password"],
            },
        )
        assert response.status_code == 200
        data = response.json()
        assert "access_token" in data
        assert data["token_type"] == "bearer"
        assert "refresh_token" in response.cookies

    def test_login_wrong_password(
        self, client: TestClient, registered_user: dict
    ) -> None:
        """Wrong password returns 401."""
        response = client.post(
            "/auth/token",
            data={
                "username": registered_user["email"],
                "password": "WrongPassword123!",
            },
        )
        assert response.status_code == 401
        assert response.json()["detail"] == "Invalid credentials"

    def test_login_nonexistent_email(self, client: TestClient) -> None:
        """Nonexistent email returns 401 (same as wrong password)."""
        response = client.post(
            "/auth/token",
            data={
                "username": "nobody@example.com",
                "password": "SomePass123!",
            },
        )
        assert response.status_code == 401
        assert response.json()["detail"] == "Invalid credentials"

    def test_login_unverified_email(self, client: TestClient) -> None:
        """Login fails for unverified email."""
        # Register but don't verify
        client.post(
            "/auth/register",
            json={
                "email": "unverified@example.com",
                "password": "ValidPass123!",
                "display_name": "Unverified",
            },
        )

        response = client.post(
            "/auth/token",
            data={
                "username": "unverified@example.com",
                "password": "ValidPass123!",
            },
        )
        assert response.status_code == 401


class TestTokenRefresh:
    """Tests for POST /auth/refresh."""

    def test_refresh_success(
        self, client: TestClient, registered_user: dict
    ) -> None:
        """Refresh returns new access token and rotates refresh token."""
        # Login first
        login_response = client.post(
            "/auth/token",
            data={
                "username": registered_user["email"],
                "password": registered_user["password"],
            },
        )
        old_access_token = login_response.json()["access_token"]

        # Refresh
        response = client.post("/auth/refresh")
        assert response.status_code == 200
        data = response.json()
        assert "access_token" in data
        assert data["access_token"] != old_access_token  # New token

    def test_refresh_without_cookie(self, client: TestClient) -> None:
        """Refresh without cookie returns 401."""
        # Clear cookies
        client.cookies.clear()
        response = client.post("/auth/refresh")
        assert response.status_code == 401


class TestEmailVerification:
    """Tests for GET /auth/verify."""

    def test_verify_success(self, client: TestClient) -> None:
        """Valid token verifies email."""
        # Register
        client.post(
            "/auth/register",
            json={
                "email": "verify@example.com",
                "password": "ValidPass123!",
                "display_name": "Verify Me",
            },
        )

        # Generate and use token
        token = generate_verification_token("verify@example.com")
        response = client.get(f"/auth/verify?token={token}")
        assert response.status_code == 200
        assert response.json()["message"] == "Email verified successfully. You can now log in."

    def test_verify_invalid_token(self, client: TestClient) -> None:
        """Invalid token returns 400."""
        response = client.get("/auth/verify?token=invalid-token")
        assert response.status_code == 400


class TestProtectedRoutes:
    """Tests for route protection."""

    def test_accounts_requires_auth(self, client: TestClient) -> None:
        """Accounts endpoint returns 401 without token."""
        response = client.get("/api/v1/accounts")
        assert response.status_code == 401
        assert response.json()["detail"] == "Not authenticated"

    def test_accounts_with_valid_token(
        self, client: TestClient, auth_headers: dict
    ) -> None:
        """Accounts endpoint works with valid token."""
        response = client.get("/api/v1/accounts", headers=auth_headers)
        assert response.status_code == 200

    def test_accounts_with_invalid_token(self, client: TestClient) -> None:
        """Invalid token returns 401."""
        response = client.get(
            "/api/v1/accounts",
            headers={"Authorization": "Bearer invalid-token"},
        )
        assert response.status_code == 401
```
  </action>
  <verify>
Run auth tests: `pytest tests/integration/api/test_auth.py -v`
  </verify>
  <done>Auth endpoint tests cover registration, login, refresh, verify-email, and route protection.</done>
</task>

<task type="auto">
  <name>Task 3: Update existing E2E tests to use auth</name>
  <files>tests/integration/api/test_accounts.py, tests/integration/api/test_transactions.py, tests/integration/api/test_categories.py</files>
  <action>
Update all existing integration tests to use auth_headers fixture.

**Pattern for all test files:**

1. Add `auth_headers` parameter to all test methods that call protected endpoints:
```python
def test_create_checking_account(
    self, client: TestClient, auth_headers: dict
) -> None:
    response = client.post(
        "/api/v1/accounts/checking",
        json={...},
        headers=auth_headers,  # Add this
    )
```

2. For tests that need to share data across requests in the same test, use the same auth_headers.

3. For tests that verify household isolation, create two users and verify one can't see the other's data.

**test_accounts.py example updates:**

```python
class TestCreateCheckingAccount:
    def test_create_with_minimal_fields(
        self, client: TestClient, auth_headers: dict
    ) -> None:
        response = client.post(
            "/api/v1/accounts/checking",
            json={
                "name": "My Checking",
                "opening_balance": {"amount": "1000.00", "currency": "USD"},
            },
            headers=auth_headers,
        )
        assert response.status_code == 201
```

**Important:** Run tests incrementally - fix one file at a time and ensure it passes before moving to the next.

**Add household isolation test:**

```python
class TestHouseholdIsolation:
    """Tests that users can only see their own household's data."""

    def test_cannot_access_other_household_account(
        self, client: TestClient, auth_headers: dict
    ) -> None:
        """Accessing another household's account returns 404."""
        # Create account with first user
        create_response = client.post(
            "/api/v1/accounts/checking",
            json={
                "name": "My Account",
                "opening_balance": {"amount": "100.00", "currency": "USD"},
            },
            headers=auth_headers,
        )
        account_id = create_response.json()["id"]

        # Register and login as second user
        client.post(
            "/auth/register",
            json={
                "email": "other@example.com",
                "password": "OtherPass123!",
                "display_name": "Other User",
            },
        )
        from src.adapters.security.tokens import generate_verification_token
        token = generate_verification_token("other@example.com")
        client.get(f"/auth/verify?token={token}")

        login_response = client.post(
            "/auth/token",
            data={"username": "other@example.com", "password": "OtherPass123!"},
        )
        other_headers = {
            "Authorization": f"Bearer {login_response.json()['access_token']}"
        }

        # Try to access first user's account
        response = client.get(
            f"/api/v1/accounts/{account_id}",
            headers=other_headers,
        )
        assert response.status_code == 404  # Not 403 - prevents probing
```
  </action>
  <verify>
Run all tests: `pytest tests/integration/api/ -v`
All tests should pass with authentication.
  </verify>
  <done>All existing E2E tests use real auth flow, household isolation verified, all tests pass.</done>
</task>

</tasks>

<verification>
Test suite is complete:
1. `pytest tests/integration/api/test_auth.py -v` - all auth tests pass
2. `pytest tests/integration/api/test_accounts.py -v` - all account tests pass with auth
3. `pytest tests/integration/api/test_transactions.py -v` - all transaction tests pass
4. `pytest tests/integration/api/test_categories.py -v` - all category tests pass
5. Household isolation test confirms cross-household returns 404
</verification>

<success_criteria>
- Auth fixtures: registered_user, auth_tokens, auth_headers work correctly
- Auth tests cover: register, login, refresh, verify, error cases
- All existing tests updated to use auth_headers
- Tests verify route protection (401 without token)
- Household isolation test verifies 404 for cross-household access
- All tests pass: `pytest tests/integration/api/ -v`
</success_criteria>

<output>
After completion, create `.planning/phases/04-authentication-infrastructure/04-08-SUMMARY.md`
</output>
