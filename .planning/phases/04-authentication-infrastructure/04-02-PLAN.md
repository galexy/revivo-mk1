---
phase: 04-authentication-infrastructure
plan: 02
type: tdd
wave: 1
depends_on: []
files_modified:
  - pyproject.toml
  - src/adapters/security/password.py
  - src/adapters/security/jwt.py
  - src/adapters/security/tokens.py
  - src/adapters/security/__init__.py
  - tests/unit/adapters/security/test_password.py
  - tests/unit/adapters/security/test_jwt.py
  - tests/unit/adapters/security/test_tokens.py
autonomous: true

must_haves:
  truths:
    - "Passwords can be hashed with Argon2 and verified"
    - "Access tokens can be created and decoded with PyJWT"
    - "Email verification tokens can be generated and validated with expiry"
    - "JWT decoding rejects expired/invalid tokens"
  artifacts:
    - path: "src/adapters/security/password.py"
      provides: "Password hashing with pwdlib/Argon2"
      contains: "hash_password"
    - path: "src/adapters/security/jwt.py"
      provides: "JWT creation and validation"
      contains: "create_access_token"
    - path: "src/adapters/security/tokens.py"
      provides: "Email verification tokens"
      contains: "generate_verification_token"
  key_links:
    - from: "src/adapters/security/jwt.py"
      to: "environment"
      via: "JWT_SECRET from os.environ"
      pattern: "os\\.environ.*JWT_SECRET"
---

<objective>
Create security infrastructure for password hashing, JWT tokens, and email verification tokens using TDD.

Purpose: Provide the cryptographic primitives needed for authentication. TDD ensures each function's behavior is specified before implementation, critical for security code.

Output: Password hashing, JWT creation/validation, timed token generation utilities with comprehensive tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-authentication-infrastructure/04-CONTEXT.md
@.planning/phases/04-authentication-infrastructure/04-RESEARCH.md
@src/adapters/security/encryption.py
</context>

<tasks>

<task id="1">
  <title>Add auth dependencies to pyproject.toml</title>
  <type>auto</type>
  <files>pyproject.toml</files>
  <action>
Add the authentication dependencies to the dependencies list in pyproject.toml:

```toml
# Add to dependencies list (after existing entries):
    "PyJWT>=2.11.0",
    "pwdlib[argon2]>=0.3.0",
    "itsdangerous>=2.2.0",
    "python-multipart>=0.0.9",
```

These are per RESEARCH.md recommendations:
- PyJWT: JWT encoding/decoding (NOT python-jose - abandoned/vulnerable)
- pwdlib[argon2]: Password hashing (NOT passlib - deprecated)
- itsdangerous: Timed URL-safe tokens for email verification
- python-multipart: Required for OAuth2PasswordRequestForm

After editing, run `uv sync` to install dependencies.
  </action>
  <verify>uv sync && python -c "import jwt; import pwdlib; import itsdangerous; print('Dependencies installed')"</verify>
  <done>PyJWT, pwdlib[argon2], itsdangerous, and python-multipart added and installed</done>
</task>

<task id="2">
  <title>Write failing tests for password hashing</title>
  <type>test</type>
  <files>tests/unit/adapters/security/test_password.py</files>
  <action>
Create test file for password hashing functions:

```python
"""Tests for password hashing infrastructure."""

import pytest


class TestHashPassword:
    """Tests for hash_password function."""

    def test_returns_argon2_hash(self) -> None:
        """hash_password returns an Argon2 hash string."""
        from src.adapters.security.password import hash_password

        result = hash_password("TestPassword123!")

        assert result.startswith("$argon2")

    def test_different_calls_produce_different_hashes(self) -> None:
        """hash_password produces different hashes (salted) for same input."""
        from src.adapters.security.password import hash_password

        hash1 = hash_password("SamePassword")
        hash2 = hash_password("SamePassword")

        assert hash1 != hash2  # Different salts


class TestVerifyPassword:
    """Tests for verify_password function."""

    def test_correct_password_returns_true(self) -> None:
        """verify_password returns True for correct password."""
        from src.adapters.security.password import hash_password, verify_password

        password = "MySecurePassword123!"
        hashed = hash_password(password)

        assert verify_password(password, hashed) is True

    def test_wrong_password_returns_false(self) -> None:
        """verify_password returns False for wrong password."""
        from src.adapters.security.password import hash_password, verify_password

        hashed = hash_password("CorrectPassword")

        assert verify_password("WrongPassword", hashed) is False

    def test_empty_password_returns_false(self) -> None:
        """verify_password returns False for empty password."""
        from src.adapters.security.password import hash_password, verify_password

        hashed = hash_password("RealPassword")

        assert verify_password("", hashed) is False
```
  </action>
  <verify>pytest tests/unit/adapters/security/test_password.py -x (should FAIL - password module doesn't exist)</verify>
  <done>Test file exists with 5 tests for password hashing, all fail with ImportError</done>
</task>

<task id="3">
  <title>Implement password hashing to pass tests</title>
  <type>impl</type>
  <files>src/adapters/security/password.py, src/adapters/security/__init__.py</files>
  <action>
Create password hashing module using pwdlib with Argon2:

**src/adapters/security/password.py:**
```python
"""Password hashing infrastructure using Argon2.

Uses pwdlib with Argon2Hasher (winner of Password Hashing Competition).
This module is infrastructure - domain layer does not depend on it.

IMPORTANT: Do NOT use passlib (deprecated, breaks on Python 3.13+).
"""

from pwdlib import PasswordHash
from pwdlib.hashers.argon2 import Argon2Hasher

# Create password hasher with Argon2 (recommended by FastAPI-Users, pwdlib docs)
_password_hash = PasswordHash((Argon2Hasher(),))


def hash_password(plain_password: str) -> str:
    """Hash a password using Argon2.

    Args:
        plain_password: The plaintext password to hash.

    Returns:
        Argon2 hash string suitable for database storage.
    """
    return _password_hash.hash(plain_password)


def verify_password(plain_password: str, hashed_password: str) -> bool:
    """Verify a password against its hash.

    Uses constant-time comparison to prevent timing attacks.

    Args:
        plain_password: The plaintext password to verify.
        hashed_password: The stored Argon2 hash.

    Returns:
        True if password matches, False otherwise.
    """
    return _password_hash.verify(plain_password, hashed_password)
```

Update `src/adapters/security/__init__.py` to export these functions.
  </action>
  <verify>pytest tests/unit/adapters/security/test_password.py -x (should PASS)</verify>
  <done>Password hashing uses Argon2 via pwdlib, all 5 tests pass</done>
</task>

<task id="4">
  <title>Write failing tests for JWT functions</title>
  <type>test</type>
  <files>tests/unit/adapters/security/test_jwt.py</files>
  <action>
Create test file for JWT creation and decoding:

```python
"""Tests for JWT token infrastructure."""

import os
import pytest
from datetime import timedelta
from unittest.mock import patch


class TestCreateAccessToken:
    """Tests for create_access_token function."""

    def test_creates_valid_jwt_string(self) -> None:
        """create_access_token returns a JWT string with three parts."""
        from src.adapters.security.jwt import create_access_token

        token = create_access_token("user_123", "hh_456")

        parts = token.split(".")
        assert len(parts) == 3  # header.payload.signature

    def test_includes_user_id_in_sub_claim(self) -> None:
        """create_access_token includes user_id as 'sub' claim."""
        from src.adapters.security.jwt import create_access_token, decode_access_token

        token = create_access_token("user_123", "hh_456")
        payload = decode_access_token(token)

        assert payload["sub"] == "user_123"

    def test_includes_household_id_claim(self) -> None:
        """create_access_token includes household_id claim."""
        from src.adapters.security.jwt import create_access_token, decode_access_token

        token = create_access_token("user_123", "hh_456")
        payload = decode_access_token(token)

        assert payload["household_id"] == "hh_456"

    def test_includes_exp_and_iat_claims(self) -> None:
        """create_access_token includes expiration and issued-at claims."""
        from src.adapters.security.jwt import create_access_token, decode_access_token

        token = create_access_token("user_123", "hh_456")
        payload = decode_access_token(token)

        assert "exp" in payload
        assert "iat" in payload


class TestDecodeAccessToken:
    """Tests for decode_access_token function."""

    def test_decodes_valid_token(self) -> None:
        """decode_access_token returns payload for valid token."""
        from src.adapters.security.jwt import create_access_token, decode_access_token

        token = create_access_token("user_123", "hh_456")
        payload = decode_access_token(token)

        assert payload["sub"] == "user_123"
        assert payload["household_id"] == "hh_456"

    def test_raises_token_error_for_invalid_token(self) -> None:
        """decode_access_token raises TokenError for invalid token."""
        from src.adapters.security.jwt import decode_access_token, TokenError

        with pytest.raises(TokenError, match="Invalid token"):
            decode_access_token("not.a.valid.token")

    def test_raises_token_error_for_expired_token(self) -> None:
        """decode_access_token raises TokenError for expired token."""
        from src.adapters.security.jwt import create_access_token, decode_access_token, TokenError

        # Create token that expires immediately
        token = create_access_token("user_123", "hh_456", expires_delta=timedelta(seconds=-1))

        with pytest.raises(TokenError, match="expired"):
            decode_access_token(token)

    def test_raises_token_error_for_tampered_token(self) -> None:
        """decode_access_token raises TokenError for tampered signature."""
        from src.adapters.security.jwt import create_access_token, decode_access_token, TokenError

        token = create_access_token("user_123", "hh_456")
        # Tamper with signature
        tampered = token[:-5] + "XXXXX"

        with pytest.raises(TokenError):
            decode_access_token(tampered)
```
  </action>
  <verify>pytest tests/unit/adapters/security/test_jwt.py -x (should FAIL - jwt module doesn't exist)</verify>
  <done>Test file exists with 8 tests for JWT functions, all fail with ImportError</done>
</task>

<task id="5">
  <title>Implement JWT functions to pass tests</title>
  <type>impl</type>
  <files>src/adapters/security/jwt.py, src/adapters/security/__init__.py</files>
  <action>
Create JWT handling module:

**src/adapters/security/jwt.py:**
```python
"""JWT token creation and validation using PyJWT.

Access tokens are short-lived (15 min) and contain user_id + household_id.
Refresh tokens are handled separately (stored in database, not stateless JWT).

IMPORTANT: Do NOT use python-jose (abandoned, has CVE-2025-61152).
CRITICAL: Always specify algorithms explicitly to prevent algorithm confusion attacks.
"""

import os
from datetime import UTC, datetime, timedelta
from typing import Any

import jwt
from jwt.exceptions import ExpiredSignatureError, InvalidTokenError

# Configuration from environment
JWT_SECRET = os.environ.get("JWT_SECRET", "CHANGE-ME-IN-PRODUCTION")
JWT_ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 15


class TokenError(Exception):
    """Raised when token validation fails."""
    pass


def create_access_token(
    user_id: str,
    household_id: str,
    expires_delta: timedelta | None = None,
) -> str:
    """Create a JWT access token.

    Token payload includes:
    - sub: user_id (standard JWT subject claim)
    - household_id: for data scoping
    - exp: expiration timestamp
    - iat: issued at timestamp

    Args:
        user_id: User identifier (string form of UserId)
        household_id: Household identifier (string form of HouseholdId)
        expires_delta: Optional custom expiry (defaults to 15 minutes)

    Returns:
        Encoded JWT string
    """
    if expires_delta is None:
        expires_delta = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)

    now = datetime.now(UTC)
    expire = now + expires_delta

    to_encode = {
        "sub": user_id,
        "household_id": household_id,
        "exp": expire,
        "iat": now,
    }

    return jwt.encode(to_encode, JWT_SECRET, algorithm=JWT_ALGORITHM)


def decode_access_token(token: str) -> dict[str, Any]:
    """Decode and validate a JWT access token.

    Args:
        token: The JWT string to decode

    Returns:
        Decoded payload dict with sub, household_id, exp, iat

    Raises:
        TokenError: If token is invalid, expired, or missing required claims
    """
    try:
        payload = jwt.decode(
            token,
            JWT_SECRET,
            algorithms=[JWT_ALGORITHM],  # CRITICAL: explicit algorithm list
            options={"require": ["exp", "sub", "household_id"]},
        )
        return payload
    except ExpiredSignatureError:
        raise TokenError("Token has expired")
    except InvalidTokenError as e:
        raise TokenError(f"Invalid token: {e}")
```

Update `src/adapters/security/__init__.py` to export JWT functions.
  </action>
  <verify>pytest tests/unit/adapters/security/test_jwt.py -x (should PASS)</verify>
  <done>JWT functions work correctly, all 8 tests pass</done>
</task>

<task id="6">
  <title>Write failing tests for email verification tokens</title>
  <type>test</type>
  <files>tests/unit/adapters/security/test_tokens.py</files>
  <action>
Create test file for email verification tokens:

```python
"""Tests for email verification token infrastructure."""

import pytest
import time


class TestGenerateVerificationToken:
    """Tests for generate_verification_token function."""

    def test_returns_url_safe_string(self) -> None:
        """generate_verification_token returns URL-safe string."""
        from src.adapters.security.tokens import generate_verification_token

        token = generate_verification_token("test@example.com")

        # URL-safe: no special chars except - _ .
        assert all(c.isalnum() or c in "-_." for c in token)

    def test_different_emails_produce_different_tokens(self) -> None:
        """Different emails produce different tokens."""
        from src.adapters.security.tokens import generate_verification_token

        token1 = generate_verification_token("user1@example.com")
        token2 = generate_verification_token("user2@example.com")

        assert token1 != token2


class TestVerifyEmailToken:
    """Tests for verify_email_token function."""

    def test_valid_token_returns_email(self) -> None:
        """verify_email_token returns email for valid token."""
        from src.adapters.security.tokens import generate_verification_token, verify_email_token

        email = "test@example.com"
        token = generate_verification_token(email)

        result = verify_email_token(token)

        assert result == email

    def test_invalid_token_returns_none(self) -> None:
        """verify_email_token returns None for invalid token."""
        from src.adapters.security.tokens import verify_email_token

        result = verify_email_token("invalid-token-string")

        assert result is None

    def test_tampered_token_returns_none(self) -> None:
        """verify_email_token returns None for tampered token."""
        from src.adapters.security.tokens import generate_verification_token, verify_email_token

        token = generate_verification_token("test@example.com")
        tampered = token[:-5] + "XXXXX"

        result = verify_email_token(tampered)

        assert result is None

    def test_expired_token_returns_none(self) -> None:
        """verify_email_token returns None for expired token."""
        from src.adapters.security.tokens import generate_verification_token, verify_email_token

        token = generate_verification_token("test@example.com")

        # Verify with 0 max_age (expired immediately)
        result = verify_email_token(token, max_age=0)

        assert result is None
```
  </action>
  <verify>pytest tests/unit/adapters/security/test_tokens.py -x (should FAIL - tokens module doesn't exist)</verify>
  <done>Test file exists with 6 tests for verification tokens, all fail with ImportError</done>
</task>

<task id="7">
  <title>Implement email verification tokens to pass tests</title>
  <type>impl</type>
  <files>src/adapters/security/tokens.py, src/adapters/security/__init__.py</files>
  <action>
Create email verification token module:

**src/adapters/security/tokens.py:**
```python
"""Timed token generation for email verification.

Uses itsdangerous URLSafeTimedSerializer for cryptographically signed,
time-limited tokens. No database lookup required - the token itself
contains the email and is validated by signature + timestamp.
"""

import os

from itsdangerous import BadSignature, SignatureExpired, URLSafeTimedSerializer

# Use same secret as JWT (or separate if needed)
TOKEN_SECRET = os.environ.get("JWT_SECRET", "CHANGE-ME-IN-PRODUCTION")
EMAIL_VERIFICATION_SALT = "email-verification"
EMAIL_VERIFICATION_MAX_AGE = 86400  # 24 hours in seconds


def generate_verification_token(email: str) -> str:
    """Generate a URL-safe verification token for email.

    Token is cryptographically signed and includes timestamp.
    Valid for 24 hours by default.

    Args:
        email: The email address to embed in token

    Returns:
        URL-safe token string (can be used in links)
    """
    serializer = URLSafeTimedSerializer(TOKEN_SECRET)
    return serializer.dumps(email, salt=EMAIL_VERIFICATION_SALT)


def verify_email_token(token: str, max_age: int = EMAIL_VERIFICATION_MAX_AGE) -> str | None:
    """Verify an email verification token and extract the email.

    Args:
        token: The token to verify
        max_age: Maximum age in seconds (default 24 hours)

    Returns:
        The email address if token is valid, None if invalid/expired
    """
    serializer = URLSafeTimedSerializer(TOKEN_SECRET)
    try:
        email = serializer.loads(token, salt=EMAIL_VERIFICATION_SALT, max_age=max_age)
        return email
    except (SignatureExpired, BadSignature):
        return None
```

Update `src/adapters/security/__init__.py` to export all security functions.
  </action>
  <verify>pytest tests/unit/adapters/security/test_tokens.py -x (should PASS)</verify>
  <done>Email verification tokens work correctly, all 6 tests pass</done>
</task>

</tasks>

<verification>
Security infrastructure is complete:
1. `pytest tests/unit/adapters/security/ -v` - all 19 tests pass
2. Password hashing returns different hashes for same password (salted)
3. JWT decoding rejects tampered tokens
4. Verification tokens expire after max_age
5. `make lint` passes
</verification>

<success_criteria>
- PyJWT, pwdlib[argon2], itsdangerous, python-multipart installed
- hash_password() returns Argon2 hash (2 tests)
- verify_password() performs constant-time comparison (3 tests)
- create_access_token() includes user_id, household_id, exp, iat (4 tests)
- decode_access_token() raises TokenError on invalid/expired (4 tests)
- generate_verification_token() creates URL-safe timed token (2 tests)
- verify_email_token() returns email or None (4 tests)
</success_criteria>

<output>
After completion, create `.planning/phases/04-authentication-infrastructure/04-02-SUMMARY.md`
</output>
