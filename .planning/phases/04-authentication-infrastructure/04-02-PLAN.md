---
phase: 04-authentication-infrastructure
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - pyproject.toml
  - src/adapters/security/password.py
  - src/adapters/security/jwt.py
  - src/adapters/security/tokens.py
  - src/adapters/security/__init__.py
autonomous: true

must_haves:
  truths:
    - "Passwords can be hashed with Argon2 and verified"
    - "Access tokens can be created and decoded with PyJWT"
    - "Email verification tokens can be generated and validated with expiry"
    - "JWT decoding rejects expired/invalid tokens"
  artifacts:
    - path: "src/adapters/security/password.py"
      provides: "Password hashing with pwdlib/Argon2"
      contains: "hash_password"
    - path: "src/adapters/security/jwt.py"
      provides: "JWT creation and validation"
      contains: "create_access_token"
    - path: "src/adapters/security/tokens.py"
      provides: "Email verification tokens"
      contains: "generate_verification_token"
  key_links:
    - from: "src/adapters/security/jwt.py"
      to: "environment"
      via: "JWT_SECRET from os.environ"
      pattern: "os\\.environ.*JWT_SECRET"
---

<objective>
Create security infrastructure for password hashing, JWT tokens, and email verification tokens.

Purpose: Provide the cryptographic primitives needed for authentication. These are infrastructure adapters that the auth service will use.

Output: Password hashing, JWT creation/validation, and timed token generation utilities.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-authentication-infrastructure/04-CONTEXT.md
@.planning/phases/04-authentication-infrastructure/04-RESEARCH.md
@src/adapters/security/encryption.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add auth dependencies to pyproject.toml</name>
  <files>pyproject.toml</files>
  <action>
Add the authentication dependencies to the dependencies list in pyproject.toml:

```toml
# Add to dependencies list (after existing entries):
    "PyJWT>=2.11.0",
    "pwdlib[argon2]>=0.3.0",
    "itsdangerous>=2.2.0",
    "python-multipart>=0.0.9",
```

These are per RESEARCH.md recommendations:
- PyJWT: JWT encoding/decoding (NOT python-jose - abandoned/vulnerable)
- pwdlib[argon2]: Password hashing (NOT passlib - deprecated)
- itsdangerous: Timed URL-safe tokens for email verification
- python-multipart: Required for OAuth2PasswordRequestForm

After editing, run `uv sync` to install dependencies.
  </action>
  <verify>
Run `uv sync && python -c "import jwt; import pwdlib; import itsdangerous; print('Dependencies installed')"` to verify all packages are available.
  </verify>
  <done>PyJWT, pwdlib[argon2], itsdangerous, and python-multipart added to dependencies and installed.</done>
</task>

<task type="auto">
  <name>Task 2: Create password hashing module</name>
  <files>src/adapters/security/password.py, src/adapters/security/__init__.py</files>
  <action>
Create password hashing adapter using pwdlib with Argon2 (per RESEARCH.md pattern):

**src/adapters/security/password.py:**
```python
"""Password hashing infrastructure using Argon2.

Uses pwdlib with Argon2Hasher (winner of Password Hashing Competition).
This module is infrastructure - domain layer does not depend on it.

IMPORTANT: Do NOT use passlib (deprecated, breaks on Python 3.13+).
"""

from pwdlib import PasswordHash
from pwdlib.hashers.argon2 import Argon2Hasher

# Create password hasher with Argon2 (recommended by FastAPI-Users, pwdlib docs)
_password_hash = PasswordHash((Argon2Hasher(),))


def hash_password(plain_password: str) -> str:
    """Hash a password using Argon2.

    Args:
        plain_password: The plaintext password to hash.

    Returns:
        Argon2 hash string suitable for database storage.
    """
    return _password_hash.hash(plain_password)


def verify_password(plain_password: str, hashed_password: str) -> bool:
    """Verify a password against its hash.

    Uses constant-time comparison to prevent timing attacks.

    Args:
        plain_password: The plaintext password to verify.
        hashed_password: The stored Argon2 hash.

    Returns:
        True if password matches, False otherwise.
    """
    return _password_hash.verify(plain_password, hashed_password)
```

Update `src/adapters/security/__init__.py` to export these functions.
  </action>
  <verify>
Run `python -c "from src.adapters.security.password import hash_password, verify_password; h = hash_password('Test123!'); print(verify_password('Test123!', h), verify_password('wrong', h))"` - should print `True False`.
  </verify>
  <done>Password hashing uses Argon2 via pwdlib, hash_password() and verify_password() work correctly.</done>
</task>

<task type="auto">
  <name>Task 3: Create JWT and email verification token modules</name>
  <files>src/adapters/security/jwt.py, src/adapters/security/tokens.py, src/adapters/security/__init__.py</files>
  <action>
Create JWT handling and email verification token modules.

**src/adapters/security/jwt.py:**
```python
"""JWT token creation and validation using PyJWT.

Access tokens are short-lived (15 min) and contain user_id + household_id.
Refresh tokens are handled separately (stored in database, not stateless JWT).

IMPORTANT: Do NOT use python-jose (abandoned, has CVE-2025-61152).
CRITICAL: Always specify algorithms explicitly to prevent algorithm confusion attacks.
"""

import os
from datetime import UTC, datetime, timedelta
from typing import Any

import jwt
from jwt.exceptions import ExpiredSignatureError, InvalidTokenError

# Configuration from environment
JWT_SECRET = os.environ.get("JWT_SECRET", "CHANGE-ME-IN-PRODUCTION")
JWT_ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 15


class TokenError(Exception):
    """Raised when token validation fails."""
    pass


def create_access_token(
    user_id: str,
    household_id: str,
    expires_delta: timedelta | None = None,
) -> str:
    """Create a JWT access token.

    Token payload includes:
    - sub: user_id (standard JWT subject claim)
    - household_id: for data scoping
    - exp: expiration timestamp
    - iat: issued at timestamp

    Args:
        user_id: User identifier (string form of UserId)
        household_id: Household identifier (string form of HouseholdId)
        expires_delta: Optional custom expiry (defaults to 15 minutes)

    Returns:
        Encoded JWT string
    """
    if expires_delta is None:
        expires_delta = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)

    now = datetime.now(UTC)
    expire = now + expires_delta

    to_encode = {
        "sub": user_id,
        "household_id": household_id,
        "exp": expire,
        "iat": now,
    }

    return jwt.encode(to_encode, JWT_SECRET, algorithm=JWT_ALGORITHM)


def decode_access_token(token: str) -> dict[str, Any]:
    """Decode and validate a JWT access token.

    Args:
        token: The JWT string to decode

    Returns:
        Decoded payload dict with sub, household_id, exp, iat

    Raises:
        TokenError: If token is invalid, expired, or missing required claims
    """
    try:
        payload = jwt.decode(
            token,
            JWT_SECRET,
            algorithms=[JWT_ALGORITHM],  # CRITICAL: explicit algorithm list
            options={"require": ["exp", "sub", "household_id"]},
        )
        return payload
    except ExpiredSignatureError:
        raise TokenError("Token has expired")
    except InvalidTokenError as e:
        raise TokenError(f"Invalid token: {e}")
```

**src/adapters/security/tokens.py:**
```python
"""Timed token generation for email verification.

Uses itsdangerous URLSafeTimedSerializer for cryptographically signed,
time-limited tokens. No database lookup required - the token itself
contains the email and is validated by signature + timestamp.
"""

import os

from itsdangerous import BadSignature, SignatureExpired, URLSafeTimedSerializer

# Use same secret as JWT (or separate if needed)
TOKEN_SECRET = os.environ.get("JWT_SECRET", "CHANGE-ME-IN-PRODUCTION")
EMAIL_VERIFICATION_SALT = "email-verification"
EMAIL_VERIFICATION_MAX_AGE = 86400  # 24 hours in seconds


def generate_verification_token(email: str) -> str:
    """Generate a URL-safe verification token for email.

    Token is cryptographically signed and includes timestamp.
    Valid for 24 hours by default.

    Args:
        email: The email address to embed in token

    Returns:
        URL-safe token string (can be used in links)
    """
    serializer = URLSafeTimedSerializer(TOKEN_SECRET)
    return serializer.dumps(email, salt=EMAIL_VERIFICATION_SALT)


def verify_email_token(token: str, max_age: int = EMAIL_VERIFICATION_MAX_AGE) -> str | None:
    """Verify an email verification token and extract the email.

    Args:
        token: The token to verify
        max_age: Maximum age in seconds (default 24 hours)

    Returns:
        The email address if token is valid, None if invalid/expired
    """
    serializer = URLSafeTimedSerializer(TOKEN_SECRET)
    try:
        email = serializer.loads(token, salt=EMAIL_VERIFICATION_SALT, max_age=max_age)
        return email
    except (SignatureExpired, BadSignature):
        return None
```

Update `src/adapters/security/__init__.py` to export all security functions.
  </action>
  <verify>
Test JWT: `python -c "from src.adapters.security.jwt import create_access_token, decode_access_token; t = create_access_token('user_123', 'hh_456'); p = decode_access_token(t); print(p['sub'], p['household_id'])"` - should print user and household IDs.

Test tokens: `python -c "from src.adapters.security.tokens import generate_verification_token, verify_email_token; t = generate_verification_token('test@example.com'); e = verify_email_token(t); print(e)"` - should print email.
  </verify>
  <done>JWT tokens work with user_id and household_id claims, email verification tokens work with 24-hour expiry.</done>
</task>

</tasks>

<verification>
Security infrastructure is complete:
1. `uv sync` installs all dependencies without errors
2. Password hashing returns different hashes for same password (salted)
3. JWT decoding rejects tampered tokens
4. Verification tokens expire after max_age
5. `make lint` passes
</verification>

<success_criteria>
- PyJWT, pwdlib[argon2], itsdangerous, python-multipart installed
- hash_password() returns Argon2 hash
- verify_password() performs constant-time comparison
- create_access_token() includes user_id, household_id, exp, iat
- decode_access_token() raises TokenError on invalid/expired tokens
- generate_verification_token() creates URL-safe timed token
- verify_email_token() returns email or None
</success_criteria>

<output>
After completion, create `.planning/phases/04-authentication-infrastructure/04-02-SUMMARY.md`
</output>
