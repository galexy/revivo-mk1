---
phase: 04-authentication-infrastructure
plan: 05
type: execute
wave: 3
depends_on: ["04-02", "04-04"]
files_modified:
  - src/application/services/auth_service.py
  - src/application/services/__init__.py
autonomous: true

must_haves:
  truths:
    - "User can register with email, password, display name"
    - "User can login with email and password"
    - "Access and refresh tokens are issued on login"
    - "Refresh token can be exchanged for new access token"
    - "Email verification token can be generated and validated"
  artifacts:
    - path: "src/application/services/auth_service.py"
      provides: "Authentication application service"
      contains: "class AuthService"
  key_links:
    - from: "src/application/services/auth_service.py"
      to: "src/adapters/security/password.py"
      via: "password hashing"
      pattern: "hash_password|verify_password"
    - from: "src/application/services/auth_service.py"
      to: "src/adapters/security/jwt.py"
      via: "token creation"
      pattern: "create_access_token"
---

<objective>
Create AuthService application service for registration, login, and token management.

Purpose: Orchestrate authentication use cases - registration (creates User + Household), login (validates credentials, issues tokens), token refresh (rotates refresh token).

Output: AuthService with register, login, refresh, verify_email methods.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-authentication-infrastructure/04-CONTEXT.md
@.planning/phases/04-authentication-infrastructure/04-RESEARCH.md
@src/application/services/account_service.py
@src/adapters/security/password.py
@src/adapters/security/jwt.py
@src/adapters/security/tokens.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AuthService with registration</name>
  <files>src/application/services/auth_service.py, src/application/services/__init__.py</files>
  <action>
Create AuthService following the AccountService pattern with error dataclasses.

```python
"""AuthService application service for authentication use cases.

Coordinates:
- User registration (creates User + Household atomically)
- Login (validates credentials, issues tokens)
- Token refresh (rotates refresh token)
- Email verification

Uses UnitOfWork for transaction boundaries.
"""

from dataclasses import dataclass
from typing import TYPE_CHECKING

from src.adapters.security.jwt import create_access_token
from src.adapters.security.password import hash_password, verify_password
from src.adapters.security.tokens import generate_verification_token, verify_email_token
from src.domain.model.entity_id import HouseholdId, UserId
from src.domain.model.household import Household
from src.domain.model.user import User

if TYPE_CHECKING:
    from src.domain.ports.unit_of_work import UnitOfWork


@dataclass(frozen=True, slots=True)
class AuthError:
    """Error result for authentication operations.

    Attributes:
        code: Machine-readable error code
        message: Human-readable error message
    """
    code: str
    message: str


@dataclass(frozen=True, slots=True)
class AuthTokens:
    """Token pair returned on successful login.

    Attributes:
        access_token: Short-lived JWT for API access
        refresh_token: Long-lived token for getting new access tokens
        token_type: Always "bearer"
        expires_in: Access token expiry in seconds
    """
    access_token: str
    refresh_token: str
    token_type: str = "bearer"
    expires_in: int = 900  # 15 minutes


@dataclass(frozen=True, slots=True)
class RegistrationResult:
    """Result of successful registration.

    Attributes:
        user: Created user
        household: Created household
        verification_token: Token for email verification
    """
    user: User
    household: Household
    verification_token: str


class AuthService:
    """Application service for authentication use cases.

    Coordinates domain operations, password hashing, and token generation.

    Attributes:
        _uow: Unit of Work for transaction management
    """

    def __init__(self, uow: "UnitOfWork") -> None:
        """Initialize AuthService with Unit of Work.

        Args:
            uow: Unit of Work for transaction management
        """
        self._uow = uow

    def register(
        self,
        email: str,
        password: str,
        display_name: str,
        household_name: str | None = None,
    ) -> RegistrationResult | AuthError:
        """Register a new user with their household.

        Creates both User and Household atomically. User cannot login
        until email is verified.

        Args:
            email: User's email address
            password: Plaintext password (will be hashed)
            display_name: User's display name
            household_name: Optional household name (defaults to "{display_name}'s Household")

        Returns:
            RegistrationResult on success, AuthError on failure
        """
        with self._uow:
            # Check if email already exists
            existing = self._uow.users.get_by_email(email)
            if existing:
                # Return generic error to prevent email enumeration
                return AuthError(
                    code="REGISTRATION_FAILED",
                    message="Registration failed. Please try again.",
                )

            # Create household first (User needs household_id)
            hh_name = household_name or f"{display_name}'s Household"
            # We'll set owner_id after User is created
            household = Household.create(name=hh_name, owner_id=UserId.generate())

            # Create user
            password_hashed = hash_password(password)
            user = User.create(
                email=email,
                display_name=display_name,
                password_hash=password_hashed,
                household_id=household.id,
            )

            # Update household owner_id to actual user
            household.owner_id = user.id

            # Persist both
            self._uow.households.add(household)
            self._uow.users.add(user)

            # Collect domain events
            events = user.collect_events()
            self._uow.collect_events(events)

            self._uow.commit()

            # Generate verification token (outside transaction)
            verification_token = generate_verification_token(user.email)

            return RegistrationResult(
                user=user,
                household=household,
                verification_token=verification_token,
            )

    def login(self, email: str, password: str) -> AuthTokens | AuthError:
        """Authenticate user and issue tokens.

        Args:
            email: User's email address
            password: Plaintext password

        Returns:
            AuthTokens on success, AuthError on failure
        """
        with self._uow:
            user = self._uow.users.get_by_email(email)

            # Generic error for both invalid email and wrong password
            # Prevents email enumeration attacks
            invalid_creds = AuthError(
                code="INVALID_CREDENTIALS",
                message="Invalid credentials",
            )

            if not user:
                return invalid_creds

            if not verify_password(password, user.password_hash):
                return invalid_creds

            if not user.email_verified:
                return AuthError(
                    code="EMAIL_NOT_VERIFIED",
                    message="Please verify your email before logging in",
                )

            # Create tokens
            access_token = create_access_token(
                user_id=str(user.id),
                household_id=str(user.household_id),
            )

            raw_refresh_token, _ = self._uow.refresh_tokens.create_token(user.id)

            self._uow.commit()

            return AuthTokens(
                access_token=access_token,
                refresh_token=raw_refresh_token,
            )

    def refresh(self, refresh_token: str) -> AuthTokens | AuthError:
        """Exchange refresh token for new access token.

        Implements token rotation - old refresh token is invalidated
        and a new one is issued.

        Args:
            refresh_token: The refresh token to validate and rotate

        Returns:
            AuthTokens on success, AuthError on failure
        """
        with self._uow:
            result = self._uow.refresh_tokens.validate_and_rotate(refresh_token)

            if not result:
                return AuthError(
                    code="INVALID_REFRESH_TOKEN",
                    message="Invalid or expired refresh token",
                )

            new_refresh_token, user_id = result

            # Get user to include household_id in access token
            user = self._uow.users.get_by_id(user_id)
            if not user:
                return AuthError(
                    code="USER_NOT_FOUND",
                    message="User not found",
                )

            access_token = create_access_token(
                user_id=str(user.id),
                household_id=str(user.household_id),
            )

            self._uow.commit()

            return AuthTokens(
                access_token=access_token,
                refresh_token=new_refresh_token,
            )

    def verify_email(self, token: str) -> User | AuthError:
        """Verify user's email using verification token.

        Args:
            token: The verification token from registration email

        Returns:
            Updated User on success, AuthError on failure
        """
        email = verify_email_token(token)
        if not email:
            return AuthError(
                code="INVALID_VERIFICATION_TOKEN",
                message="Invalid or expired verification token",
            )

        with self._uow:
            user = self._uow.users.get_by_email(email)
            if not user:
                return AuthError(
                    code="USER_NOT_FOUND",
                    message="User not found",
                )

            if user.email_verified:
                # Already verified - return success (idempotent)
                return user

            user.verify_email()

            # Collect domain events
            events = user.collect_events()
            self._uow.collect_events(events)

            self._uow.commit()

            return user

    def logout_all_sessions(self, user_id: UserId) -> None:
        """Revoke all refresh tokens for user (logout everywhere).

        Args:
            user_id: User to logout
        """
        with self._uow:
            self._uow.refresh_tokens.revoke_all_for_user(user_id)
            self._uow.commit()

    def get_user_by_id(self, user_id: UserId) -> User | None:
        """Get user by ID (for route handlers that need user details).

        Args:
            user_id: User identifier

        Returns:
            User if found, None otherwise
        """
        with self._uow:
            return self._uow.users.get_by_id(user_id)
```

Update `src/application/services/__init__.py` to export AuthService and related types.
  </action>
  <verify>
Run `python -c "from src.application.services.auth_service import AuthService, AuthError, AuthTokens, RegistrationResult; print('AuthService OK')"` to verify imports.
  </verify>
  <done>AuthService implements register, login, refresh, verify_email with proper error handling and token management.</done>
</task>

</tasks>

<verification>
AuthService is complete:
1. All methods follow UnitOfWork pattern
2. Password hashing uses security adapter
3. JWT creation uses security adapter
4. Domain events collected and stored
5. `make lint` passes
</verification>

<success_criteria>
- register() creates User + Household atomically
- register() returns verification token
- login() validates password and issues tokens
- login() rejects unverified users
- refresh() rotates tokens correctly
- verify_email() marks user verified
- All errors return AuthError with appropriate codes
</success_criteria>

<output>
After completion, create `.planning/phases/04-authentication-infrastructure/04-05-SUMMARY.md`
</output>
