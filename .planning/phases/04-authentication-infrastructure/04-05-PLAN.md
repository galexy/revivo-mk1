---
phase: 04-authentication-infrastructure
plan: 05
type: tdd
wave: 3
depends_on: ["04-02", "04-04"]
files_modified:
  - src/application/services/auth_service.py
  - src/application/services/__init__.py
  - tests/unit/application/test_auth_service.py
autonomous: true

must_haves:
  truths:
    - "User can register with email, password, display name"
    - "User can login with email and password"
    - "Access and refresh tokens are issued on login"
    - "Refresh token can be exchanged for new access token"
    - "Email verification token can be generated and validated"
  artifacts:
    - path: "src/application/services/auth_service.py"
      provides: "Authentication application service"
      contains: "class AuthService"
  key_links:
    - from: "src/application/services/auth_service.py"
      to: "src/adapters/security/password.py"
      via: "password hashing"
      pattern: "hash_password|verify_password"
    - from: "src/application/services/auth_service.py"
      to: "src/adapters/security/jwt.py"
      via: "token creation"
      pattern: "create_access_token"
---

<objective>
Create AuthService application service for registration, login, and token management using TDD.

Purpose: Orchestrate authentication use cases -- registration (creates User + Household), login (validates credentials, issues tokens), token refresh (rotates refresh token). TDD ensures each use case returns correct results for valid and invalid inputs.

Output: AuthService with register, login, refresh, verify_email methods and comprehensive unit tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-authentication-infrastructure/04-CONTEXT.md
@.planning/phases/04-authentication-infrastructure/04-RESEARCH.md
@src/application/services/account_service.py
@src/adapters/security/password.py
@src/adapters/security/jwt.py
@src/adapters/security/tokens.py
</context>

<tasks>

<task id="1">
  <title>Write failing tests for AuthService registration</title>
  <type>test</type>
  <files>tests/unit/application/test_auth_service.py</files>
  <action>
Create test file with tests for AuthService.register() method. Use a mock UnitOfWork that provides in-memory repositories (or unittest.mock).

```python
"""Tests for AuthService application service."""

import pytest
from unittest.mock import MagicMock, patch


class TestAuthServiceRegister:
    """Tests for AuthService.register() method."""

    def test_register_creates_user_and_household(self) -> None:
        """register() creates User and Household, returns RegistrationResult."""
        from src.application.services.auth_service import AuthService, RegistrationResult

        uow = self._make_mock_uow(existing_email=None)
        service = AuthService(uow)

        result = service.register(
            email="new@example.com",
            password="Test123!@",
            display_name="New User",
        )

        assert isinstance(result, RegistrationResult)
        assert result.user.email == "new@example.com"
        assert result.household.name == "New User's Household"
        assert result.verification_token is not None

    def test_register_normalizes_email(self) -> None:
        """register() lowercases email."""
        from src.application.services.auth_service import AuthService, RegistrationResult

        uow = self._make_mock_uow(existing_email=None)
        service = AuthService(uow)

        result = service.register(
            email="Test@EXAMPLE.COM",
            password="Test123!@",
            display_name="Test",
        )

        assert isinstance(result, RegistrationResult)
        assert result.user.email == "test@example.com"

    def test_register_duplicate_email_returns_error(self) -> None:
        """register() returns AuthError when email already exists."""
        from src.application.services.auth_service import AuthService, AuthError

        # Mock returns existing user for this email
        uow = self._make_mock_uow(existing_email="taken@example.com")
        service = AuthService(uow)

        result = service.register(
            email="taken@example.com",
            password="Test123!@",
            display_name="Test",
        )

        assert isinstance(result, AuthError)
        assert result.code == "REGISTRATION_FAILED"

    def test_register_hashes_password(self) -> None:
        """register() hashes password (does not store plaintext)."""
        from src.application.services.auth_service import AuthService, RegistrationResult

        uow = self._make_mock_uow(existing_email=None)
        service = AuthService(uow)

        result = service.register(
            email="new@example.com",
            password="Test123!@",
            display_name="Test",
        )

        assert isinstance(result, RegistrationResult)
        assert result.user.password_hash != "Test123!@"
        assert result.user.password_hash.startswith("$argon2")

    @staticmethod
    def _make_mock_uow(existing_email: str | None) -> MagicMock:
        """Create mock UnitOfWork with stubbed repositories."""
        from src.domain.model.entity_id import HouseholdId, UserId
        from src.domain.model.user import User

        uow = MagicMock()
        uow.__enter__ = MagicMock(return_value=uow)
        uow.__exit__ = MagicMock(return_value=False)

        # Stub users.get_by_email
        if existing_email:
            mock_user = MagicMock(spec=User)
            mock_user.email = existing_email
            uow.users.get_by_email.return_value = mock_user
        else:
            uow.users.get_by_email.return_value = None

        # Stub other methods
        uow.users.add = MagicMock()
        uow.households.add = MagicMock()
        uow.commit = MagicMock()
        uow.collect_events = MagicMock()

        return uow
```
  </action>
  <verify>pytest tests/unit/application/test_auth_service.py::TestAuthServiceRegister -x (should FAIL - AuthService doesn't exist)</verify>
  <done>Test file exists with 4 tests for registration, all fail with ImportError</done>
</task>

<task id="2">
  <title>Implement AuthService register() to pass tests</title>
  <type>impl</type>
  <files>src/application/services/auth_service.py, src/application/services/__init__.py</files>
  <action>
Create AuthService with register() method, AuthError, AuthTokens, and RegistrationResult dataclasses.

Follow the AccountService pattern. register() should:
1. Check if email already exists (return AuthError if so)
2. Hash password using hash_password()
3. Create Household (default name: "{display_name}'s Household")
4. Create User with hashed password and household_id
5. Update household owner_id to the created user
6. Persist both, commit
7. Generate verification token
8. Return RegistrationResult

Include AuthError, AuthTokens, RegistrationResult dataclasses.
Include login(), refresh(), verify_email(), logout_all_sessions(), get_user_by_id() method stubs (will be tested in next task).

Update `src/application/services/__init__.py` to export AuthService.
  </action>
  <verify>pytest tests/unit/application/test_auth_service.py::TestAuthServiceRegister -x (should PASS)</verify>
  <done>AuthService.register() creates User + Household atomically, all 4 register tests pass</done>
</task>

<task id="3">
  <title>Write failing tests for AuthService login and token refresh</title>
  <type>test</type>
  <files>tests/unit/application/test_auth_service.py</files>
  <action>
Add test classes for login() and refresh() to the existing test file:

```python
class TestAuthServiceLogin:
    """Tests for AuthService.login() method."""

    def test_login_with_valid_credentials_returns_tokens(self) -> None:
        """login() returns AuthTokens for valid credentials."""
        from src.application.services.auth_service import AuthService, AuthTokens
        from src.adapters.security.password import hash_password

        uow = self._make_mock_uow_with_user(
            email="user@example.com",
            password_hash=hash_password("ValidPass123!"),
            email_verified=True,
        )
        service = AuthService(uow)

        result = service.login("user@example.com", "ValidPass123!")

        assert isinstance(result, AuthTokens)
        assert result.access_token is not None
        assert result.refresh_token is not None
        assert result.token_type == "bearer"

    def test_login_wrong_password_returns_error(self) -> None:
        """login() returns AuthError for wrong password."""
        from src.application.services.auth_service import AuthService, AuthError
        from src.adapters.security.password import hash_password

        uow = self._make_mock_uow_with_user(
            email="user@example.com",
            password_hash=hash_password("CorrectPassword123!"),
            email_verified=True,
        )
        service = AuthService(uow)

        result = service.login("user@example.com", "WrongPassword123!")

        assert isinstance(result, AuthError)
        assert result.code == "INVALID_CREDENTIALS"

    def test_login_nonexistent_email_returns_error(self) -> None:
        """login() returns AuthError for nonexistent email."""
        from src.application.services.auth_service import AuthService, AuthError

        uow = self._make_mock_uow_with_user(email=None)
        service = AuthService(uow)

        result = service.login("nobody@example.com", "SomePass123!")

        assert isinstance(result, AuthError)
        assert result.code == "INVALID_CREDENTIALS"

    def test_login_unverified_email_returns_error(self) -> None:
        """login() returns AuthError if email not verified."""
        from src.application.services.auth_service import AuthService, AuthError
        from src.adapters.security.password import hash_password

        uow = self._make_mock_uow_with_user(
            email="user@example.com",
            password_hash=hash_password("ValidPass123!"),
            email_verified=False,
        )
        service = AuthService(uow)

        result = service.login("user@example.com", "ValidPass123!")

        assert isinstance(result, AuthError)
        assert result.code == "EMAIL_NOT_VERIFIED"

    @staticmethod
    def _make_mock_uow_with_user(
        email: str | None,
        password_hash: str = "",
        email_verified: bool = True,
    ) -> MagicMock:
        """Create mock UnitOfWork with optional user."""
        from src.domain.model.entity_id import HouseholdId, UserId

        uow = MagicMock()
        uow.__enter__ = MagicMock(return_value=uow)
        uow.__exit__ = MagicMock(return_value=False)

        if email:
            mock_user = MagicMock()
            mock_user.id = UserId.generate()
            mock_user.email = email
            mock_user.password_hash = password_hash
            mock_user.email_verified = email_verified
            mock_user.household_id = HouseholdId.generate()
            uow.users.get_by_email.return_value = mock_user
        else:
            uow.users.get_by_email.return_value = None

        uow.refresh_tokens.create_token.return_value = ("raw_refresh_token", MagicMock())
        uow.commit = MagicMock()

        return uow


class TestAuthServiceVerifyEmail:
    """Tests for AuthService.verify_email() method."""

    def test_valid_token_marks_email_verified(self) -> None:
        """verify_email() marks user verified for valid token."""
        from src.application.services.auth_service import AuthService
        from src.adapters.security.tokens import generate_verification_token
        from src.domain.model.entity_id import HouseholdId, UserId
        from src.domain.model.user import User

        token = generate_verification_token("user@example.com")
        hh_id = HouseholdId.generate()
        user = User.create("user@example.com", "Test", "hash", hh_id)

        uow = MagicMock()
        uow.__enter__ = MagicMock(return_value=uow)
        uow.__exit__ = MagicMock(return_value=False)
        uow.users.get_by_email.return_value = user
        uow.commit = MagicMock()
        uow.collect_events = MagicMock()

        service = AuthService(uow)
        result = service.verify_email(token)

        assert not isinstance(result, type(None))
        assert hasattr(result, 'email_verified')

    def test_invalid_token_returns_error(self) -> None:
        """verify_email() returns AuthError for invalid token."""
        from src.application.services.auth_service import AuthService, AuthError

        uow = MagicMock()
        service = AuthService(uow)

        result = service.verify_email("invalid-token")

        assert isinstance(result, AuthError)
        assert result.code == "INVALID_VERIFICATION_TOKEN"
```
  </action>
  <verify>pytest tests/unit/application/test_auth_service.py -x (should FAIL on new tests - login/verify not implemented)</verify>
  <done>Test file has 6 additional tests for login and verify_email</done>
</task>

<task id="4">
  <title>Implement AuthService login, refresh, verify_email to pass tests</title>
  <type>impl</type>
  <files>src/application/services/auth_service.py</files>
  <action>
Implement the remaining AuthService methods:

**login():** Validates credentials against stored hash using verify_password(), checks email_verified, creates access token via create_access_token(), creates refresh token via uow.refresh_tokens.create_token(). Returns AuthTokens on success, AuthError on failure (generic "Invalid credentials" message for both nonexistent email and wrong password).

**refresh():** Calls uow.refresh_tokens.validate_and_rotate(). If valid, looks up user, creates new access token with household_id. Returns AuthTokens or AuthError.

**verify_email():** Validates token via verify_email_token(). If valid, looks up user by email, calls user.verify_email(), commits. Returns User or AuthError.

**logout_all_sessions():** Calls uow.refresh_tokens.revoke_all_for_user().

**get_user_by_id():** Simple lookup via uow.users.get_by_id().
  </action>
  <verify>pytest tests/unit/application/test_auth_service.py -x (should PASS - all 10 tests)</verify>
  <done>AuthService fully implements register, login, refresh, verify_email. All 10 tests pass.</done>
</task>

</tasks>

<verification>
AuthService is complete:
1. `pytest tests/unit/application/test_auth_service.py -v` - all tests pass
2. All methods follow UnitOfWork pattern
3. Password hashing uses security adapter
4. JWT creation uses security adapter
5. `make lint` passes
</verification>

<success_criteria>
- register() creates User + Household atomically (4 tests)
- login() validates password and issues tokens (4 tests)
- login() rejects unverified users
- verify_email() marks user verified (2 tests)
- All errors return AuthError with appropriate codes
</success_criteria>

<output>
After completion, create `.planning/phases/04-authentication-infrastructure/04-05-SUMMARY.md`
</output>
