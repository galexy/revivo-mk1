---
phase: 04-authentication-infrastructure
plan: 04
type: execute
wave: 3
depends_on: ["04-01", "04-02", "04-03"]
files_modified:
  - src/adapters/persistence/orm/mappers.py
  - src/adapters/persistence/repositories/user.py
  - src/adapters/persistence/repositories/household.py
  - src/adapters/persistence/repositories/refresh_token.py
  - src/adapters/persistence/repositories/__init__.py
  - src/adapters/persistence/unit_of_work.py
  - src/domain/ports/repositories.py
autonomous: true

must_haves:
  truths:
    - "User can be persisted and retrieved by email"
    - "Household can be persisted and retrieved by ID"
    - "Refresh tokens can be stored, validated, and rotated"
    - "UnitOfWork provides access to new repositories"
  artifacts:
    - path: "src/adapters/persistence/repositories/user.py"
      provides: "User repository implementation"
      contains: "class UserRepository"
    - path: "src/adapters/persistence/repositories/household.py"
      provides: "Household repository implementation"
      contains: "class HouseholdRepository"
    - path: "src/adapters/persistence/repositories/refresh_token.py"
      provides: "Refresh token repository"
      contains: "class RefreshTokenRepository"
  key_links:
    - from: "src/adapters/persistence/unit_of_work.py"
      to: "repositories"
      via: "lazy property initialization"
      pattern: "@property.*def users"
---

<objective>
Create ORM mappers and repositories for User, Household, and RefreshToken.

Purpose: Provide persistence layer for authentication entities. Repositories handle domain object reconstruction and storage. ORM mappers and UnitOfWork wiring are config tasks (auto). Repositories are created alongside their ports.

Output: User/Household/RefreshToken repositories, ORM mappers, UnitOfWork integration.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-authentication-infrastructure/04-CONTEXT.md
@.planning/phases/04-authentication-infrastructure/04-RESEARCH.md
@src/adapters/persistence/orm/mappers.py
@src/adapters/persistence/repositories/account.py
@src/adapters/persistence/unit_of_work.py
@src/domain/ports/repositories.py
</context>

<tasks>

<task id="1">
  <title>Add ORM mappers for User and Household</title>
  <type>auto</type>
  <files>src/adapters/persistence/orm/mappers.py</files>
  <action>
Add mappers for User and Household following the Account pattern. RefreshToken does not need a mapper (simple data, not a domain aggregate).

Add imports:
```python
from src.domain.model.user import User
from src.domain.model.household import Household
from src.domain.model.entity_id import HouseholdId
```

Add mapper for Household:
```python
mapper_registry.map_imperatively(
    Household,
    households,
    properties={
        "id": column_property(households.c.id),
        "name": households.c.name,
        "owner_id": households.c.owner_id,
        "created_at": households.c.created_at,
        "updated_at": households.c.updated_at,
    },
)
```

Add mapper for User:
```python
mapper_registry.map_imperatively(
    User,
    users,
    properties={
        "id": column_property(users.c.id),
        "email": users.c.email,
        "display_name": users.c.display_name,
        "password_hash": users.c.password_hash,
        "household_id": users.c.household_id,
        "email_verified": users.c.email_verified,
        "email_verified_at": users.c.email_verified_at,
        "created_at": users.c.created_at,
        "updated_at": users.c.updated_at,
    },
    exclude_properties=["_events"],  # Don't persist event list
)
```

Import households, users tables from .tables.
  </action>
  <verify>python -c "from src.adapters.persistence.orm.mappers import start_mappers; start_mappers(); print('Mappers OK')"</verify>
  <done>User and Household mapped to database tables, exclude _events from User persistence</done>
</task>

<task id="2">
  <title>Create repository ports and implementations</title>
  <type>auto</type>
  <files>src/domain/ports/repositories.py, src/adapters/persistence/repositories/user.py, src/adapters/persistence/repositories/household.py, src/adapters/persistence/repositories/refresh_token.py, src/adapters/persistence/repositories/__init__.py</files>
  <action>
**Add to src/domain/ports/repositories.py:**
```python
from typing import Protocol

from src.domain.model.user import User
from src.domain.model.household import Household
from src.domain.model.entity_id import UserId, HouseholdId


class UserRepositoryProtocol(Protocol):
    """Port for User persistence."""

    def add(self, user: User) -> None: ...
    def get_by_id(self, user_id: UserId) -> User | None: ...
    def get_by_email(self, email: str) -> User | None: ...
    def update(self, user: User) -> None: ...


class HouseholdRepositoryProtocol(Protocol):
    """Port for Household persistence."""

    def add(self, household: Household) -> None: ...
    def get_by_id(self, household_id: HouseholdId) -> Household | None: ...
    def update(self, household: Household) -> None: ...
```

**Create src/adapters/persistence/repositories/user.py:**
```python
"""User repository implementation."""

from sqlalchemy.orm import Session

from src.domain.model.entity_id import UserId
from src.domain.model.user import User


class UserRepository:
    """SQLAlchemy implementation of UserRepositoryProtocol."""

    def __init__(self, session: Session) -> None:
        self._session = session

    def add(self, user: User) -> None:
        self._session.add(user)

    def get_by_id(self, user_id: UserId) -> User | None:
        return self._session.query(User).filter(User.id == user_id).first()

    def get_by_email(self, email: str) -> User | None:
        return self._session.query(User).filter(User.email == email.lower()).first()

    def update(self, user: User) -> None:
        self._session.merge(user)
```

**Create src/adapters/persistence/repositories/household.py:**
```python
"""Household repository implementation."""

from sqlalchemy.orm import Session

from src.domain.model.entity_id import HouseholdId
from src.domain.model.household import Household


class HouseholdRepository:
    """SQLAlchemy implementation of HouseholdRepositoryProtocol."""

    def __init__(self, session: Session) -> None:
        self._session = session

    def add(self, household: Household) -> None:
        self._session.add(household)

    def get_by_id(self, household_id: HouseholdId) -> Household | None:
        return self._session.query(Household).filter(Household.id == household_id).first()

    def update(self, household: Household) -> None:
        self._session.merge(household)
```

**Create src/adapters/persistence/repositories/refresh_token.py:**
Create the RefreshTokenRepository with create_token, validate_and_rotate, revoke_all_for_user, revoke_family, cleanup_expired methods. Use SHA-256 hashing for tokens. Store in refresh_tokens table directly via SQLAlchemy Core (not ORM -- refresh tokens are not domain aggregates). Include RefreshTokenRecord dataclass for internal use.

REFRESH_TOKEN_EXPIRE_DAYS = 7. Token creation generates with secrets.token_urlsafe(32).

Update `src/adapters/persistence/repositories/__init__.py` to export new repositories.
  </action>
  <verify>python -c "from src.adapters.persistence.repositories import UserRepository, HouseholdRepository, RefreshTokenRepository; print('Repos OK')"</verify>
  <done>User, Household, RefreshToken repositories implemented with proper patterns</done>
</task>

<task id="3">
  <title>Update UnitOfWork with new repositories</title>
  <type>auto</type>
  <files>src/adapters/persistence/unit_of_work.py, src/domain/ports/unit_of_work.py</files>
  <action>
Add lazy repository properties to SqlAlchemyUnitOfWork following the existing pattern for accounts, categories, etc.

**Update src/domain/ports/unit_of_work.py protocol:**
```python
@property
def users(self) -> UserRepositoryProtocol: ...

@property
def households(self) -> HouseholdRepositoryProtocol: ...

@property
def refresh_tokens(self) -> "RefreshTokenRepository": ...
```

**Update src/adapters/persistence/unit_of_work.py:**

Add imports for UserRepository, HouseholdRepository, RefreshTokenRepository.

Add lazy properties:
```python
@property
def users(self) -> UserRepository:
    if self._users is None:
        self._users = UserRepository(self._session)
    return self._users

@property
def households(self) -> HouseholdRepository:
    if self._households is None:
        self._households = HouseholdRepository(self._session)
    return self._households

@property
def refresh_tokens(self) -> RefreshTokenRepository:
    if self._refresh_tokens is None:
        self._refresh_tokens = RefreshTokenRepository(self._session)
    return self._refresh_tokens
```

Add corresponding private attributes in `__init__`:
```python
self._users: UserRepository | None = None
self._households: HouseholdRepository | None = None
self._refresh_tokens: RefreshTokenRepository | None = None
```
  </action>
  <verify>python -c "from src.adapters.persistence.unit_of_work import SqlAlchemyUnitOfWork; print('UoW OK')"</verify>
  <done>UnitOfWork provides users, households, refresh_tokens repositories via lazy properties</done>
</task>

</tasks>

<verification>
Repository layer is complete:
1. ORM mappers compile without errors
2. Repositories can be instantiated from UnitOfWork
3. `make lint` passes
4. Protocol definitions match implementations
</verification>

<success_criteria>
- User mapped to users table, _events excluded
- Household mapped to households table
- UserRepository has add, get_by_id, get_by_email, update
- HouseholdRepository has add, get_by_id, update
- RefreshTokenRepository has create_token, validate_and_rotate, revoke methods
- UnitOfWork exposes users, households, refresh_tokens properties
</success_criteria>

<output>
After completion, create `.planning/phases/04-authentication-infrastructure/04-04-SUMMARY.md`
</output>
