---
phase: 04-authentication-infrastructure
plan: 04
type: execute
wave: 3
depends_on: ["04-01", "04-02", "04-03"]
files_modified:
  - src/adapters/persistence/orm/mappers.py
  - src/adapters/persistence/repositories/user.py
  - src/adapters/persistence/repositories/household.py
  - src/adapters/persistence/repositories/refresh_token.py
  - src/adapters/persistence/repositories/__init__.py
  - src/adapters/persistence/unit_of_work.py
  - src/domain/ports/repositories.py
autonomous: true

must_haves:
  truths:
    - "User can be persisted and retrieved by email"
    - "Household can be persisted and retrieved by ID"
    - "Refresh tokens can be stored, validated, and rotated"
    - "UnitOfWork provides access to new repositories"
  artifacts:
    - path: "src/adapters/persistence/repositories/user.py"
      provides: "User repository implementation"
      contains: "class UserRepository"
    - path: "src/adapters/persistence/repositories/household.py"
      provides: "Household repository implementation"
      contains: "class HouseholdRepository"
    - path: "src/adapters/persistence/repositories/refresh_token.py"
      provides: "Refresh token repository"
      contains: "class RefreshTokenRepository"
  key_links:
    - from: "src/adapters/persistence/unit_of_work.py"
      to: "repositories"
      via: "lazy property initialization"
      pattern: "@property.*def users"
---

<objective>
Create ORM mappers and repositories for User, Household, and RefreshToken.

Purpose: Provide persistence layer for authentication entities. Repositories handle domain object reconstruction and storage.

Output: User/Household/RefreshToken repositories, ORM mappers, UnitOfWork integration.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-authentication-infrastructure/04-CONTEXT.md
@.planning/phases/04-authentication-infrastructure/04-RESEARCH.md
@src/adapters/persistence/orm/mappers.py
@src/adapters/persistence/repositories/account.py
@src/adapters/persistence/unit_of_work.py
@src/domain/ports/repositories.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ORM mappers for User and Household</name>
  <files>src/adapters/persistence/orm/mappers.py</files>
  <action>
Add mappers for User and Household following the Account pattern. RefreshToken does not need a mapper (simple data, not a domain aggregate).

Add imports:
```python
from src.domain.model.user import User
from src.domain.model.household import Household
from src.domain.model.entity_id import HouseholdId
```

Add mapper for Household (simpler, no relationships yet):
```python
mapper_registry.map_imperatively(
    Household,
    households,
    properties={
        "id": column_property(households.c.id),
        "name": households.c.name,
        "owner_id": households.c.owner_id,
        "created_at": households.c.created_at,
        "updated_at": households.c.updated_at,
    },
)
```

Add mapper for User:
```python
mapper_registry.map_imperatively(
    User,
    users,
    properties={
        "id": column_property(users.c.id),
        "email": users.c.email,
        "display_name": users.c.display_name,
        "password_hash": users.c.password_hash,
        "household_id": users.c.household_id,
        "email_verified": users.c.email_verified,
        "email_verified_at": users.c.email_verified_at,
        "created_at": users.c.created_at,
        "updated_at": users.c.updated_at,
    },
    exclude_properties=["_events"],  # Don't persist event list
)
```

Note: Import households, users tables from .tables.
  </action>
  <verify>
Run `python -c "from src.adapters.persistence.orm.mappers import start_mappers; start_mappers(); print('Mappers OK')"` to verify mappers compile.
  </verify>
  <done>User and Household mapped to database tables, exclude _events from User persistence.</done>
</task>

<task type="auto">
  <name>Task 2: Create repository ports and implementations</name>
  <files>src/domain/ports/repositories.py, src/adapters/persistence/repositories/user.py, src/adapters/persistence/repositories/household.py, src/adapters/persistence/repositories/refresh_token.py, src/adapters/persistence/repositories/__init__.py</files>
  <action>
**Add to src/domain/ports/repositories.py:**
```python
from typing import Protocol

from src.domain.model.user import User
from src.domain.model.household import Household
from src.domain.model.entity_id import UserId, HouseholdId


class UserRepositoryProtocol(Protocol):
    """Port for User persistence."""

    def add(self, user: User) -> None: ...
    def get_by_id(self, user_id: UserId) -> User | None: ...
    def get_by_email(self, email: str) -> User | None: ...
    def update(self, user: User) -> None: ...


class HouseholdRepositoryProtocol(Protocol):
    """Port for Household persistence."""

    def add(self, household: Household) -> None: ...
    def get_by_id(self, household_id: HouseholdId) -> Household | None: ...
    def update(self, household: Household) -> None: ...
```

**Create src/adapters/persistence/repositories/user.py:**
```python
"""User repository implementation."""

from sqlalchemy.orm import Session

from src.domain.model.entity_id import UserId
from src.domain.model.user import User


class UserRepository:
    """SQLAlchemy implementation of UserRepositoryProtocol."""

    def __init__(self, session: Session) -> None:
        self._session = session

    def add(self, user: User) -> None:
        """Add a new user."""
        self._session.add(user)

    def get_by_id(self, user_id: UserId) -> User | None:
        """Get user by ID."""
        return self._session.query(User).filter(User.id == user_id).first()

    def get_by_email(self, email: str) -> User | None:
        """Get user by email (case-insensitive)."""
        return self._session.query(User).filter(User.email == email.lower()).first()

    def update(self, user: User) -> None:
        """Update existing user."""
        self._session.merge(user)
```

**Create src/adapters/persistence/repositories/household.py:**
```python
"""Household repository implementation."""

from sqlalchemy.orm import Session

from src.domain.model.entity_id import HouseholdId
from src.domain.model.household import Household


class HouseholdRepository:
    """SQLAlchemy implementation of HouseholdRepositoryProtocol."""

    def __init__(self, session: Session) -> None:
        self._session = session

    def add(self, household: Household) -> None:
        """Add a new household."""
        self._session.add(household)

    def get_by_id(self, household_id: HouseholdId) -> Household | None:
        """Get household by ID."""
        return self._session.query(Household).filter(Household.id == household_id).first()

    def update(self, household: Household) -> None:
        """Update existing household."""
        self._session.merge(household)
```

**Create src/adapters/persistence/repositories/refresh_token.py:**
```python
"""Refresh token repository implementation.

Refresh tokens are stored hashed (SHA-256) and support rotation.
Token families enable reuse detection for security.
"""

import hashlib
import secrets
from dataclasses import dataclass
from datetime import UTC, datetime, timedelta

from sqlalchemy import delete, select, update
from sqlalchemy.orm import Session

from src.adapters.persistence.orm.tables import refresh_tokens
from src.domain.model.entity_id import UserId

# Token configuration
REFRESH_TOKEN_EXPIRE_DAYS = 7


@dataclass
class RefreshTokenRecord:
    """Data class for refresh token storage."""
    id: int | None
    user_id: str
    token_hash: str
    token_family: str
    expires_at: datetime
    created_at: datetime
    revoked_at: datetime | None = None


class RefreshTokenRepository:
    """Repository for refresh token storage and validation."""

    def __init__(self, session: Session) -> None:
        self._session = session

    def create_token(self, user_id: UserId) -> tuple[str, RefreshTokenRecord]:
        """Create a new refresh token for user.

        Returns:
            Tuple of (raw_token, record) - raw token for client, record for storage
        """
        raw_token = secrets.token_urlsafe(32)
        token_hash = self._hash_token(raw_token)
        token_family = secrets.token_urlsafe(16)
        now = datetime.now(UTC)
        expires_at = now + timedelta(days=REFRESH_TOKEN_EXPIRE_DAYS)

        self._session.execute(
            refresh_tokens.insert().values(
                user_id=str(user_id),
                token_hash=token_hash,
                token_family=token_family,
                expires_at=expires_at,
                created_at=now,
            )
        )

        record = RefreshTokenRecord(
            id=None,
            user_id=str(user_id),
            token_hash=token_hash,
            token_family=token_family,
            expires_at=expires_at,
            created_at=now,
        )
        return raw_token, record

    def validate_and_rotate(self, raw_token: str) -> tuple[str, UserId] | None:
        """Validate token and rotate (issue new token, invalidate old).

        Returns:
            Tuple of (new_raw_token, user_id) if valid, None if invalid/expired
        """
        token_hash = self._hash_token(raw_token)
        now = datetime.now(UTC)

        # Find token
        result = self._session.execute(
            select(refresh_tokens).where(
                refresh_tokens.c.token_hash == token_hash,
                refresh_tokens.c.revoked_at.is_(None),
                refresh_tokens.c.expires_at > now,
            )
        ).first()

        if not result:
            return None

        user_id = UserId.from_string(result.user_id)
        token_family = result.token_family

        # Revoke old token
        self._session.execute(
            update(refresh_tokens)
            .where(refresh_tokens.c.token_hash == token_hash)
            .values(revoked_at=now)
        )

        # Create new token in same family
        new_raw_token = secrets.token_urlsafe(32)
        new_token_hash = self._hash_token(new_raw_token)
        expires_at = now + timedelta(days=REFRESH_TOKEN_EXPIRE_DAYS)

        self._session.execute(
            refresh_tokens.insert().values(
                user_id=str(user_id),
                token_hash=new_token_hash,
                token_family=token_family,
                expires_at=expires_at,
                created_at=now,
            )
        )

        return new_raw_token, user_id

    def revoke_all_for_user(self, user_id: UserId) -> None:
        """Revoke all refresh tokens for a user (logout everywhere)."""
        self._session.execute(
            update(refresh_tokens)
            .where(
                refresh_tokens.c.user_id == str(user_id),
                refresh_tokens.c.revoked_at.is_(None),
            )
            .values(revoked_at=datetime.now(UTC))
        )

    def revoke_family(self, token_family: str) -> None:
        """Revoke all tokens in a family (reuse detection)."""
        self._session.execute(
            update(refresh_tokens)
            .where(
                refresh_tokens.c.token_family == token_family,
                refresh_tokens.c.revoked_at.is_(None),
            )
            .values(revoked_at=datetime.now(UTC))
        )

    def cleanup_expired(self) -> int:
        """Delete expired tokens. Returns count deleted."""
        result = self._session.execute(
            delete(refresh_tokens).where(
                refresh_tokens.c.expires_at < datetime.now(UTC)
            )
        )
        return result.rowcount

    @staticmethod
    def _hash_token(token: str) -> str:
        """Hash token with SHA-256."""
        return hashlib.sha256(token.encode()).hexdigest()
```

Update `src/adapters/persistence/repositories/__init__.py` to export new repositories.
  </action>
  <verify>
Run `python -c "from src.adapters.persistence.repositories import UserRepository, HouseholdRepository, RefreshTokenRepository; print('Repos OK')"` to verify imports.
  </verify>
  <done>User, Household, RefreshToken repositories implemented with proper patterns.</done>
</task>

<task type="auto">
  <name>Task 3: Update UnitOfWork with new repositories</name>
  <files>src/adapters/persistence/unit_of_work.py, src/domain/ports/unit_of_work.py</files>
  <action>
Add lazy repository properties to SqlAlchemyUnitOfWork following the existing pattern for accounts, categories, etc.

**Update src/domain/ports/unit_of_work.py protocol:**
Add new repository properties to UnitOfWork protocol:
```python
@property
def users(self) -> UserRepositoryProtocol: ...

@property
def households(self) -> HouseholdRepositoryProtocol: ...

@property
def refresh_tokens(self) -> "RefreshTokenRepository": ...  # No protocol needed
```

**Update src/adapters/persistence/unit_of_work.py:**

Add imports:
```python
from src.adapters.persistence.repositories.user import UserRepository
from src.adapters.persistence.repositories.household import HouseholdRepository
from src.adapters.persistence.repositories.refresh_token import RefreshTokenRepository
```

Add lazy properties following the existing pattern:
```python
@property
def users(self) -> UserRepository:
    """User repository (lazy initialization)."""
    if self._users is None:
        self._users = UserRepository(self._session)
    return self._users

@property
def households(self) -> HouseholdRepository:
    """Household repository (lazy initialization)."""
    if self._households is None:
        self._households = HouseholdRepository(self._session)
    return self._households

@property
def refresh_tokens(self) -> RefreshTokenRepository:
    """Refresh token repository (lazy initialization)."""
    if self._refresh_tokens is None:
        self._refresh_tokens = RefreshTokenRepository(self._session)
    return self._refresh_tokens
```

Add corresponding private attributes in `__init__`:
```python
self._users: UserRepository | None = None
self._households: HouseholdRepository | None = None
self._refresh_tokens: RefreshTokenRepository | None = None
```
  </action>
  <verify>
Run `python -c "from src.adapters.persistence.unit_of_work import SqlAlchemyUnitOfWork; from src.adapters.persistence.database import create_sync_session_factory; uow = SqlAlchemyUnitOfWork(create_sync_session_factory()); print(type(uow.users), type(uow.households))"` to verify properties work.
  </verify>
  <done>UnitOfWork provides users, households, refresh_tokens repositories via lazy properties.</done>
</task>

</tasks>

<verification>
Repository layer is complete:
1. ORM mappers compile without errors
2. Repositories can be instantiated from UnitOfWork
3. `make lint` passes
4. Protocol definitions match implementations
</verification>

<success_criteria>
- User mapped to users table, _events excluded
- Household mapped to households table
- UserRepository has add, get_by_id, get_by_email, update
- HouseholdRepository has add, get_by_id, update
- RefreshTokenRepository has create_token, validate_and_rotate, revoke methods
- UnitOfWork exposes users, households, refresh_tokens properties
</success_criteria>

<output>
After completion, create `.planning/phases/04-authentication-infrastructure/04-04-SUMMARY.md`
</output>
