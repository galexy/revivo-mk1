---
phase: 04-authentication-infrastructure
plan: 04
type: execute
wave: 3
depends_on: ["04-01", "04-02", "04-03"]
files_modified:
  - src/adapters/persistence/orm/mappers.py
  - src/adapters/persistence/repositories/user.py
  - src/adapters/persistence/repositories/household.py
  - src/adapters/persistence/repositories/refresh_token.py
  - src/adapters/persistence/repositories/__init__.py
  - src/adapters/persistence/unit_of_work.py
  - src/domain/ports/repositories.py
autonomous: true

must_haves:
  truths:
    - "User can be persisted and retrieved by email"
    - "Household can be persisted and retrieved by ID"
    - "Refresh tokens can be stored, validated, and rotated"
    - "UnitOfWork provides access to new repositories"
  artifacts:
    - path: "src/adapters/persistence/repositories/user.py"
      provides: "User repository implementation"
      contains: "class UserRepository"
    - path: "src/adapters/persistence/repositories/household.py"
      provides: "Household repository implementation"
      contains: "class HouseholdRepository"
    - path: "src/adapters/persistence/repositories/refresh_token.py"
      provides: "Refresh token repository"
      contains: "class RefreshTokenRepository"
  key_links:
    - from: "src/adapters/persistence/unit_of_work.py"
      to: "repositories"
      via: "lazy property initialization"
      pattern: "@property.*def users"
---

<objective>
Create ORM mappers and repositories for User, Household, and RefreshToken.

Purpose: Provide persistence layer for authentication entities. Repositories handle domain object reconstruction and storage. ORM mappers and UnitOfWork wiring are config tasks (auto). Repositories are created alongside their ports.

Output: User/Household/RefreshToken repositories, ORM mappers, UnitOfWork integration.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-authentication-infrastructure/04-CONTEXT.md
@.planning/phases/04-authentication-infrastructure/04-RESEARCH.md
@src/adapters/persistence/orm/mappers.py
@src/adapters/persistence/repositories/account.py
@src/adapters/persistence/unit_of_work.py
@src/domain/ports/repositories.py
</context>

<tasks>

<task id="1">
  <title>Add ORM mappers for User and Household</title>
  <type>auto</type>
  <files>src/adapters/persistence/orm/mappers.py</files>
  <action>
Add mappers for User and Household following the Account pattern. RefreshToken does not need a mapper (simple data, not a domain aggregate).

Add imports:
```python
from src.domain.model.user import User
from src.domain.model.household import Household
from src.domain.model.entity_id import HouseholdId
```

Add mapper for Household:
```python
mapper_registry.map_imperatively(
    Household,
    households,
    properties={
        "id": column_property(households.c.id),
        "name": households.c.name,
        "owner_id": households.c.owner_id,
        "created_at": households.c.created_at,
        "updated_at": households.c.updated_at,
    },
)
```

Add mapper for User:
```python
mapper_registry.map_imperatively(
    User,
    users,
    properties={
        "id": column_property(users.c.id),
        "email": users.c.email,
        "display_name": users.c.display_name,
        "password_hash": users.c.password_hash,
        "household_id": users.c.household_id,
        "email_verified": users.c.email_verified,
        "email_verified_at": users.c.email_verified_at,
        "created_at": users.c.created_at,
        "updated_at": users.c.updated_at,
    },
    exclude_properties=["_events"],  # Don't persist event list
)
```

Import households, users tables from .tables.
  </action>
  <verify>python -c "from src.adapters.persistence.orm.mappers import start_mappers; start_mappers(); print('Mappers OK')"</verify>
  <done>User and Household mapped to database tables, exclude _events from User persistence</done>
</task>

<task id="2">
  <title>Create repository ports and implementations</title>
  <type>auto</type>
  <files>src/domain/ports/repositories.py, src/adapters/persistence/repositories/user.py, src/adapters/persistence/repositories/household.py, src/adapters/persistence/repositories/refresh_token.py, src/adapters/persistence/repositories/__init__.py</files>
  <action>
**Add to src/domain/ports/repositories.py:**
```python
from typing import Protocol

from src.domain.model.user import User
from src.domain.model.household import Household
from src.domain.model.entity_id import UserId, HouseholdId


class UserRepositoryProtocol(Protocol):
    """Port for User persistence."""

    def add(self, user: User) -> None: ...
    def get_by_id(self, user_id: UserId) -> User | None: ...
    def get_by_email(self, email: str) -> User | None: ...
    def update(self, user: User) -> None: ...


class HouseholdRepositoryProtocol(Protocol):
    """Port for Household persistence."""

    def add(self, household: Household) -> None: ...
    def get_by_id(self, household_id: HouseholdId) -> Household | None: ...
    def update(self, household: Household) -> None: ...
```

**Create src/adapters/persistence/repositories/user.py:**
```python
"""User repository implementation."""

from sqlalchemy.orm import Session

from src.domain.model.entity_id import UserId
from src.domain.model.user import User


class UserRepository:
    """SQLAlchemy implementation of UserRepositoryProtocol."""

    def __init__(self, session: Session) -> None:
        self._session = session

    def add(self, user: User) -> None:
        self._session.add(user)

    def get_by_id(self, user_id: UserId) -> User | None:
        return self._session.query(User).filter(User.id == user_id).first()

    def get_by_email(self, email: str) -> User | None:
        return self._session.query(User).filter(User.email == email.lower()).first()

    def update(self, user: User) -> None:
        self._session.merge(user)
```

**Create src/adapters/persistence/repositories/household.py:**
```python
"""Household repository implementation."""

from sqlalchemy.orm import Session

from src.domain.model.entity_id import HouseholdId
from src.domain.model.household import Household


class HouseholdRepository:
    """SQLAlchemy implementation of HouseholdRepositoryProtocol."""

    def __init__(self, session: Session) -> None:
        self._session = session

    def add(self, household: Household) -> None:
        self._session.add(household)

    def get_by_id(self, household_id: HouseholdId) -> Household | None:
        return self._session.query(Household).filter(Household.id == household_id).first()

    def update(self, household: Household) -> None:
        self._session.merge(household)
```

**Create src/adapters/persistence/repositories/refresh_token.py:**

This repository uses SQLAlchemy Core (not ORM) because refresh tokens are NOT domain aggregates -- they are infrastructure records. All operations go through `self._session.execute()` against the `refresh_tokens` table imported from `src.adapters.persistence.orm.tables`.

```python
"""Refresh token repository using SQLAlchemy Core."""

import hashlib
import secrets
import uuid
from dataclasses import dataclass
from datetime import UTC, datetime, timedelta

from sqlalchemy import and_, delete, select, update
from sqlalchemy.orm import Session

from src.adapters.persistence.orm.tables import refresh_tokens
from src.domain.model.entity_id import UserId

REFRESH_TOKEN_EXPIRE_DAYS = 7


@dataclass
class RefreshTokenRecord:
    """Internal record representing a stored refresh token."""
    id: int
    user_id: str
    token_hash: str
    token_family: str
    expires_at: datetime
    created_at: datetime
    revoked_at: datetime | None


def _hash_token(raw_token: str) -> str:
    """Hash a raw token with SHA-256 for storage."""
    return hashlib.sha256(raw_token.encode("utf-8")).hexdigest()


class RefreshTokenRepository:
    """SQLAlchemy Core implementation for refresh token persistence.

    Refresh tokens are NOT domain aggregates. They are security infrastructure
    records managed via SQLAlchemy Core (insert/select/update/delete statements)
    executed through self._session.execute().

    Token values are hashed with SHA-256 before storage. Raw tokens are never
    persisted -- only the caller (AuthService) sees the raw value.
    """

    def __init__(self, session: Session) -> None:
        self._session = session

    def create_token(self, user_id: UserId, family: str | None = None) -> tuple[str, RefreshTokenRecord]:
        """Create a new refresh token for a user.

        Generates a cryptographically random token via secrets.token_urlsafe(32),
        hashes it with SHA-256, and inserts a row into refresh_tokens table.

        Args:
            user_id: The user this token belongs to.
            family: Token family ID for rotation tracking. If None, generates a new
                    family (used for initial login). Subsequent rotations pass the
                    existing family to maintain the chain.

        Returns:
            Tuple of (raw_token, RefreshTokenRecord). The raw_token is returned
            ONLY here -- it is never stored. The record contains the hashed version.

        SQL equivalent:
            INSERT INTO refresh_tokens (user_id, token_hash, token_family, expires_at, created_at)
            VALUES (:user_id, :token_hash, :family, :expires_at, :now)
        """
        raw_token = secrets.token_urlsafe(32)
        token_hash = _hash_token(raw_token)
        now = datetime.now(UTC)
        expires_at = now + timedelta(days=REFRESH_TOKEN_EXPIRE_DAYS)
        token_family = family or str(uuid.uuid4())

        result = self._session.execute(
            refresh_tokens.insert()
            .values(
                user_id=str(user_id),
                token_hash=token_hash,
                token_family=token_family,
                expires_at=expires_at,
                created_at=now,
                revoked_at=None,
            )
            .returning(refresh_tokens.c.id)
        )
        token_id = result.scalar_one()

        record = RefreshTokenRecord(
            id=token_id,
            user_id=str(user_id),
            token_hash=token_hash,
            token_family=token_family,
            expires_at=expires_at,
            created_at=now,
            revoked_at=None,
        )
        return raw_token, record

    def validate_and_rotate(self, raw_token: str) -> tuple[str, RefreshTokenRecord] | None:
        """Validate a refresh token and rotate it (issue new token, revoke old).

        Looks up the token by its SHA-256 hash. If found, checks:
        1. Token is not revoked (revoked_at IS NULL)
        2. Token is not expired (expires_at > now)

        If the token is revoked (reuse detected), revokes the ENTIRE family
        as a security measure (potential token theft).

        If valid, revokes the old token and creates a new one in the same family.

        Args:
            raw_token: The raw token value from the client cookie.

        Returns:
            Tuple of (new_raw_token, new_record) on success, or None if invalid.

        SQL for lookup:
            SELECT * FROM refresh_tokens WHERE token_hash = :hash

        SQL for revoke old:
            UPDATE refresh_tokens SET revoked_at = :now WHERE id = :id

        SQL for family revocation (on reuse):
            UPDATE refresh_tokens SET revoked_at = :now
            WHERE token_family = :family AND revoked_at IS NULL
        """
        token_hash = _hash_token(raw_token)
        now = datetime.now(UTC)

        # Look up token by hash
        result = self._session.execute(
            select(refresh_tokens).where(refresh_tokens.c.token_hash == token_hash)
        )
        row = result.mappings().first()
        if row is None:
            return None

        # If already revoked -> reuse detected, revoke entire family
        if row["revoked_at"] is not None:
            self.revoke_family(row["token_family"])
            return None

        # If expired -> return None
        if row["expires_at"] <= now:
            return None

        # Revoke old token
        self._session.execute(
            update(refresh_tokens)
            .where(refresh_tokens.c.id == row["id"])
            .values(revoked_at=now)
        )

        # Create new token in same family
        return self.create_token(
            UserId.from_string(row["user_id"]),
            family=row["token_family"],
        )

    def revoke_all_for_user(self, user_id: UserId) -> int:
        """Revoke all active refresh tokens for a user (logout all sessions).

        Args:
            user_id: The user whose tokens to revoke.

        Returns:
            Number of tokens revoked.

        SQL:
            UPDATE refresh_tokens SET revoked_at = :now
            WHERE user_id = :user_id AND revoked_at IS NULL
        """
        now = datetime.now(UTC)
        result = self._session.execute(
            update(refresh_tokens)
            .where(
                and_(
                    refresh_tokens.c.user_id == str(user_id),
                    refresh_tokens.c.revoked_at.is_(None),
                )
            )
            .values(revoked_at=now)
        )
        return result.rowcount

    def revoke_family(self, family: str) -> int:
        """Revoke all tokens in a family (reuse detection response).

        When a revoked token is presented, this indicates potential theft.
        Revoke ALL tokens in the family to force re-authentication.

        Args:
            family: The token_family identifier.

        Returns:
            Number of tokens revoked.

        SQL:
            UPDATE refresh_tokens SET revoked_at = :now
            WHERE token_family = :family AND revoked_at IS NULL
        """
        now = datetime.now(UTC)
        result = self._session.execute(
            update(refresh_tokens)
            .where(
                and_(
                    refresh_tokens.c.token_family == family,
                    refresh_tokens.c.revoked_at.is_(None),
                )
            )
            .values(revoked_at=now)
        )
        return result.rowcount

    def cleanup_expired(self, older_than_days: int = 30) -> int:
        """Delete expired tokens older than the specified number of days.

        Removes fully expired tokens from the database to prevent table bloat.
        Only deletes tokens that expired more than `older_than_days` ago
        (keeps recent expired tokens for audit trail).

        Args:
            older_than_days: Delete tokens expired more than this many days ago.

        Returns:
            Number of tokens deleted.

        SQL:
            DELETE FROM refresh_tokens
            WHERE expires_at < :cutoff
        """
        cutoff = datetime.now(UTC) - timedelta(days=older_than_days)
        result = self._session.execute(
            delete(refresh_tokens).where(refresh_tokens.c.expires_at < cutoff)
        )
        return result.rowcount
```

Update `src/adapters/persistence/repositories/__init__.py` to export new repositories:
```python
from src.adapters.persistence.repositories.user import UserRepository
from src.adapters.persistence.repositories.household import HouseholdRepository
from src.adapters.persistence.repositories.refresh_token import RefreshTokenRepository
```
  </action>
  <verify>python -c "from src.adapters.persistence.repositories import UserRepository, HouseholdRepository, RefreshTokenRepository; print('Repos OK')"</verify>
  <done>User, Household, RefreshToken repositories implemented with proper patterns. RefreshTokenRepository uses SQLAlchemy Core with SHA-256 hashed tokens, family-based rotation, and reuse detection.</done>
</task>

<task id="3">
  <title>Update UnitOfWork with new repositories</title>
  <type>auto</type>
  <files>src/adapters/persistence/unit_of_work.py, src/domain/ports/unit_of_work.py</files>
  <action>
Add lazy repository properties to SqlAlchemyUnitOfWork following the existing pattern for accounts, categories, etc.

**Update src/domain/ports/unit_of_work.py protocol:**
```python
@property
def users(self) -> UserRepositoryProtocol: ...

@property
def households(self) -> HouseholdRepositoryProtocol: ...

@property
def refresh_tokens(self) -> "RefreshTokenRepository": ...
```

**Update src/adapters/persistence/unit_of_work.py:**

Add imports for UserRepository, HouseholdRepository, RefreshTokenRepository.

Add lazy properties:
```python
@property
def users(self) -> UserRepository:
    if self._users is None:
        self._users = UserRepository(self._session)
    return self._users

@property
def households(self) -> HouseholdRepository:
    if self._households is None:
        self._households = HouseholdRepository(self._session)
    return self._households

@property
def refresh_tokens(self) -> RefreshTokenRepository:
    if self._refresh_tokens is None:
        self._refresh_tokens = RefreshTokenRepository(self._session)
    return self._refresh_tokens
```

Add corresponding private attributes in `__init__`:
```python
self._users: UserRepository | None = None
self._households: HouseholdRepository | None = None
self._refresh_tokens: RefreshTokenRepository | None = None
```
  </action>
  <verify>python -c "from src.adapters.persistence.unit_of_work import SqlAlchemyUnitOfWork; print('UoW OK')"</verify>
  <done>UnitOfWork provides users, households, refresh_tokens repositories via lazy properties</done>
</task>

</tasks>

<verification>
Repository layer is complete:
1. ORM mappers compile without errors
2. Repositories can be instantiated from UnitOfWork
3. `make lint` passes
4. Protocol definitions match implementations
</verification>

<success_criteria>
- User mapped to users table, _events excluded
- Household mapped to households table
- UserRepository has add, get_by_id, get_by_email, update
- HouseholdRepository has add, get_by_id, update
- RefreshTokenRepository has create_token, validate_and_rotate, revoke_all_for_user, revoke_family, cleanup_expired
- RefreshTokenRepository uses SHA-256 hashing via hashlib.sha256 for token storage
- RefreshTokenRepository uses self._session.execute() with SQLAlchemy Core insert/select/update/delete against refresh_tokens table
- Token rotation: validate_and_rotate revokes old token then creates new in same family
- Reuse detection: presenting a revoked token revokes the entire family
- UnitOfWork exposes users, households, refresh_tokens properties
</success_criteria>

<output>
After completion, create `.planning/phases/04-authentication-infrastructure/04-04-SUMMARY.md`
</output>
