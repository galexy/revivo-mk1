---
phase: 04-authentication-infrastructure
plan: 06
type: tdd
wave: 3
depends_on: ["04-02", "04-05"]
files_modified:
  - src/adapters/api/routes/auth.py
  - src/adapters/api/schemas/auth.py
  - src/adapters/api/dependencies.py
  - src/adapters/api/app.py
  - tests/unit/adapters/api/test_auth_schemas.py
  - tests/conftest.py
  - tests/integration/api/test_auth.py
autonomous: true

must_haves:
  truths:
    - "POST /auth/register creates user and returns 202"
    - "POST /auth/token returns access token in body and refresh token in cookie"
    - "POST /auth/refresh rotates refresh token and returns new access token"
    - "GET /auth/verify validates email verification token"
    - "get_current_user dependency extracts user from JWT"
    - "Auth tests verify registration, login, refresh, verify-email flows"
    - "Test fixtures create authenticated user context"
  artifacts:
    - path: "src/adapters/api/routes/auth.py"
      provides: "Authentication API endpoints"
      contains: "router"
    - path: "src/adapters/api/schemas/auth.py"
      provides: "Auth request/response schemas"
      contains: "RegisterRequest"
    - path: "src/adapters/api/dependencies.py"
      provides: "get_current_user dependency"
      contains: "get_current_user"
    - path: "tests/integration/api/test_auth.py"
      provides: "Authentication endpoint tests"
      contains: "test_register"
    - path: "tests/conftest.py"
      provides: "Auth fixtures for tests"
      contains: "auth_headers"
  key_links:
    - from: "src/adapters/api/routes/auth.py"
      to: "src/application/services/auth_service.py"
      via: "AuthService dependency"
      pattern: "AuthService"
    - from: "src/adapters/api/dependencies.py"
      to: "src/adapters/security/jwt.py"
      via: "decode_access_token"
      pattern: "decode_access_token"
    - from: "tests/integration/api/test_auth.py"
      to: "tests/conftest.py"
      via: "auth fixtures"
      pattern: "registered_user|auth_headers|auth_tokens"
---

<objective>
Create authentication API routes, Pydantic schemas, get_current_user dependency, auth test fixtures, and auth endpoint integration tests using TDD.

Purpose: Expose authentication endpoints (register, login, refresh, verify-email) and provide the dependency that all protected routes will use. TDD ensures schema validation and route behavior are specified before wiring. Integration tests and fixtures are written as the RED step, then implementation makes them GREEN.

Output: Auth routes, Pydantic schemas (with password validation tests), CurrentUser dependency, router registered in app, auth endpoint integration tests (14+ tests), reusable auth fixtures in conftest.py.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-authentication-infrastructure/04-CONTEXT.md
@.planning/phases/04-authentication-infrastructure/04-RESEARCH.md
@src/adapters/api/routes/accounts.py
@src/adapters/api/schemas/account.py
@src/adapters/api/dependencies.py
@src/adapters/api/app.py
@tests/conftest.py
</context>

<tasks>

<task id="1">
  <title>RED: Write failing tests for auth schemas and auth endpoint integration tests</title>
  <type>test</type>
  <files>tests/unit/adapters/api/test_auth_schemas.py, tests/conftest.py, tests/integration/api/test_auth.py</files>
  <action>
Write all test code FIRST. This is the RED phase -- everything must fail because the implementation does not exist yet.

**Create tests/unit/adapters/api/test_auth_schemas.py** with schema validation tests:

```python
"""Tests for auth request/response schemas."""

import pytest
from pydantic import ValidationError


class TestRegisterRequestPasswordValidation:
    """Tests for RegisterRequest password complexity rules."""

    def test_valid_password_accepted(self) -> None:
        """Valid password passes validation."""
        from src.adapters.api.schemas.auth import RegisterRequest

        req = RegisterRequest(
            email="test@example.com",
            password="ValidPass123!",
            display_name="Test",
        )
        assert req.password == "ValidPass123!"

    def test_password_too_short_rejected(self) -> None:
        """Password under 8 chars is rejected."""
        from src.adapters.api.schemas.auth import RegisterRequest

        with pytest.raises(ValidationError, match="8 characters"):
            RegisterRequest(
                email="test@example.com",
                password="Ab1!",
                display_name="Test",
            )

    def test_password_no_uppercase_rejected(self) -> None:
        """Password without uppercase is rejected."""
        from src.adapters.api.schemas.auth import RegisterRequest

        with pytest.raises(ValidationError, match="uppercase"):
            RegisterRequest(
                email="test@example.com",
                password="alllowercase1!",
                display_name="Test",
            )

    def test_password_no_lowercase_rejected(self) -> None:
        """Password without lowercase is rejected."""
        from src.adapters.api.schemas.auth import RegisterRequest

        with pytest.raises(ValidationError, match="lowercase"):
            RegisterRequest(
                email="test@example.com",
                password="ALLUPPERCASE1!",
                display_name="Test",
            )

    def test_password_no_number_rejected(self) -> None:
        """Password without number is rejected."""
        from src.adapters.api.schemas.auth import RegisterRequest

        with pytest.raises(ValidationError, match="number"):
            RegisterRequest(
                email="test@example.com",
                password="NoNumbers!!",
                display_name="Test",
            )

    def test_password_no_symbol_rejected(self) -> None:
        """Password without symbol is rejected."""
        from src.adapters.api.schemas.auth import RegisterRequest

        with pytest.raises(ValidationError, match="symbol"):
            RegisterRequest(
                email="test@example.com",
                password="NoSymbol123",
                display_name="Test",
            )

    def test_invalid_email_rejected(self) -> None:
        """Invalid email format is rejected."""
        from src.adapters.api.schemas.auth import RegisterRequest

        with pytest.raises(ValidationError):
            RegisterRequest(
                email="not-an-email",
                password="ValidPass123!",
                display_name="Test",
            )

    def test_empty_display_name_rejected(self) -> None:
        """Empty display name is rejected."""
        from src.adapters.api.schemas.auth import RegisterRequest

        with pytest.raises(ValidationError, match="empty"):
            RegisterRequest(
                email="test@example.com",
                password="ValidPass123!",
                display_name="   ",
            )
```

**Add auth fixtures to tests/conftest.py** (append to existing file):

```python
@pytest.fixture
def test_user_data() -> dict:
    """Test user credentials."""
    return {
        "email": f"test_{uuid.uuid4().hex[:8]}@example.com",
        "password": "TestPassword123!",
        "display_name": "Test User",
    }

@pytest.fixture
def registered_user(client: TestClient, test_user_data: dict) -> dict:
    """Register a test user and verify their email."""
    # Register
    response = client.post("/auth/register", json=test_user_data)
    assert response.status_code == 202

    # Verify email
    from src.adapters.security.tokens import generate_verification_token
    verification_token = generate_verification_token(test_user_data["email"])
    response = client.get(f"/auth/verify?token={verification_token}")
    assert response.status_code == 200

    return {**test_user_data, "user_id": response.json()["user_id"]}

@pytest.fixture
def auth_tokens(client: TestClient, registered_user: dict) -> dict:
    """Login and return tokens."""
    response = client.post(
        "/auth/token",
        data={"username": registered_user["email"], "password": registered_user["password"]},
    )
    assert response.status_code == 200
    return response.json()

@pytest.fixture
def auth_headers(auth_tokens: dict) -> dict:
    """Authorization headers for authenticated requests."""
    return {"Authorization": f"Bearer {auth_tokens['access_token']}"}
```

**Create tests/integration/api/test_auth.py** with full auth endpoint tests:

```python
"""Authentication endpoint integration tests."""


class TestRegistration:
    def test_register_success(self, client) -> None:
        """Registration returns 202."""
        # POST /auth/register with valid data -> 202

    def test_register_weak_password_rejected(self, client) -> None:
        """Weak password returns 422."""

    def test_register_invalid_email_rejected(self, client) -> None:
        """Invalid email returns 422."""

    def test_register_duplicate_email_returns_202(self, client, registered_user) -> None:
        """Duplicate email returns 202 (enumeration protection)."""


class TestLogin:
    def test_login_success(self, client, registered_user) -> None:
        """Login returns access token and sets refresh cookie."""

    def test_login_wrong_password(self, client, registered_user) -> None:
        """Wrong password returns 401."""

    def test_login_nonexistent_email(self, client) -> None:
        """Nonexistent email returns 401."""

    def test_login_unverified_email(self, client) -> None:
        """Unverified email returns 401."""


class TestTokenRefresh:
    def test_refresh_success(self, client, registered_user) -> None:
        """Refresh returns new access token."""

    def test_refresh_without_cookie(self, client) -> None:
        """Refresh without cookie returns 401."""


class TestEmailVerification:
    def test_verify_success(self, client) -> None:
        """Valid token verifies email."""

    def test_verify_invalid_token(self, client) -> None:
        """Invalid token returns 400."""
```

Write full test implementations following the patterns described above. All tests should exercise the real HTTP endpoints via the TestClient.
  </action>
  <verify>pytest tests/unit/adapters/api/test_auth_schemas.py tests/integration/api/test_auth.py -x (should FAIL - schemas and routes don't exist yet)</verify>
  <done>Test files exist: 8 schema validation tests, 12 auth endpoint integration tests, 4 auth fixtures in conftest.py. All fail with ImportError or 404.</done>
</task>

<task id="2">
  <title>GREEN: Implement auth schemas, dependencies, routes, and register router</title>
  <type>impl</type>
  <files>src/adapters/api/schemas/auth.py, src/adapters/api/schemas/__init__.py, src/adapters/api/dependencies.py, src/adapters/api/routes/auth.py, src/adapters/api/routes/__init__.py, src/adapters/api/app.py</files>
  <action>
Implement everything needed to make the failing tests from Task 1 pass. This is the GREEN phase.

**Create src/adapters/api/schemas/auth.py** with:
- RegisterRequest: email (EmailStr), password (with field_validator for 8+ chars, uppercase, lowercase, number, symbol), display_name (strip + not empty), household_name (optional)
- RegisterResponse: message, user_id, email
- TokenResponse: access_token, token_type="bearer", expires_in=900
- RefreshRequest: empty (token from cookie)
- VerifyEmailResponse: message, user_id, email
- ErrorResponse: detail, code

Update schemas __init__.py to export.

**Update src/adapters/api/dependencies.py** with:
- oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/auth/token")
- CurrentUser dataclass (frozen, slots): user_id: UserId, household_id: HouseholdId
- get_current_user(token) -> CurrentUser: decodes JWT, extracts user_id/household_id, raises 401 on failure
- get_auth_service(uow) -> AuthService: factory dependency

Keep old get_current_user_id() for backward compatibility (removed in plan 07).

**Create src/adapters/api/routes/auth.py:**
- POST /auth/register: Accepts RegisterRequest, calls service.register(), returns 202 with RegisterResponse. Always returns 202 even on duplicate email (enumeration protection).
- POST /auth/token: OAuth2 compatible (OAuth2PasswordRequestForm), calls service.login(), sets refresh token as HttpOnly cookie (secure=True, samesite="strict", path="/auth/refresh", max_age=7days), returns TokenResponse.
- POST /auth/refresh: Reads refresh_token from Cookie, calls service.refresh(), rotates cookie, returns TokenResponse.
- GET /auth/verify: Query param token, calls service.verify_email(), returns VerifyEmailResponse or 400.
- POST /auth/logout: Clears refresh token cookie, returns 204.

Helper functions: _set_refresh_cookie(), _clear_refresh_cookie().

Update routes __init__.py to export auth router.
Update app.py to include auth router: `app.include_router(auth_router)`.

Iterate until ALL tests from Task 1 pass: both schema unit tests and auth integration tests.
  </action>
  <verify>pytest tests/unit/adapters/api/test_auth_schemas.py tests/integration/api/test_auth.py -v (ALL tests PASS)</verify>
  <done>Auth schemas with password validation, CurrentUser dependency, auth routes, and router registration all implemented. All 20+ tests (8 schema + 12 integration) pass. Auth fixtures (registered_user, auth_tokens, auth_headers) work correctly.</done>
</task>

</tasks>

<verification>
Auth API and tests are complete:
1. `pytest tests/unit/adapters/api/test_auth_schemas.py -v` - all schema tests pass
2. `pytest tests/integration/api/test_auth.py -v` - all auth endpoint tests pass
3. Auth fixtures chain correctly: test_user_data -> registered_user -> auth_tokens -> auth_headers
4. Schema validation rejects weak passwords
5. get_current_user dependency compiles
6. Routes registered in app
7. `make lint` passes
</verification>

<success_criteria>
- RegisterRequest validates password complexity (8 tests)
- POST /auth/register returns 202 (even on duplicate email)
- POST /auth/token is OAuth2 compatible
- Refresh token set as HttpOnly cookie with path="/auth/refresh"
- get_current_user dependency extracts user from JWT
- All auth errors return generic messages
- Auth tests cover: register (4), login (4), refresh (2), verify (2) = 12+ integration tests
- Auth fixtures: registered_user, auth_tokens, auth_headers work correctly
</success_criteria>

<output>
After completion, create `.planning/phases/04-authentication-infrastructure/04-06-SUMMARY.md`
</output>
