---
phase: 04-authentication-infrastructure
plan: 06
type: execute
wave: 3
depends_on: ["04-02", "04-05"]
files_modified:
  - src/adapters/api/routes/auth.py
  - src/adapters/api/schemas/auth.py
  - src/adapters/api/dependencies.py
  - src/adapters/api/app.py
autonomous: true

must_haves:
  truths:
    - "POST /auth/register creates user and returns 202"
    - "POST /auth/token returns access token in body and refresh token in cookie"
    - "POST /auth/refresh rotates refresh token and returns new access token"
    - "GET /auth/verify validates email verification token"
    - "get_current_user dependency extracts user from JWT"
  artifacts:
    - path: "src/adapters/api/routes/auth.py"
      provides: "Authentication API endpoints"
      contains: "router"
    - path: "src/adapters/api/schemas/auth.py"
      provides: "Auth request/response schemas"
      contains: "RegisterRequest"
    - path: "src/adapters/api/dependencies.py"
      provides: "get_current_user dependency"
      contains: "get_current_user"
  key_links:
    - from: "src/adapters/api/routes/auth.py"
      to: "src/application/services/auth_service.py"
      via: "AuthService dependency"
      pattern: "AuthService"
    - from: "src/adapters/api/dependencies.py"
      to: "src/adapters/security/jwt.py"
      via: "decode_access_token"
      pattern: "decode_access_token"
---

<objective>
Create authentication API routes and the get_current_user dependency.

Purpose: Expose authentication endpoints (register, login, refresh, verify-email) and provide the dependency that all protected routes will use.

Output: Auth routes, Pydantic schemas, CurrentUser dependency, router registered in app.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-authentication-infrastructure/04-CONTEXT.md
@.planning/phases/04-authentication-infrastructure/04-RESEARCH.md
@src/adapters/api/routes/accounts.py
@src/adapters/api/schemas/account.py
@src/adapters/api/dependencies.py
@src/adapters/api/app.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create auth Pydantic schemas</name>
  <files>src/adapters/api/schemas/auth.py, src/adapters/api/schemas/__init__.py</files>
  <action>
Create Pydantic schemas for auth requests and responses.

**src/adapters/api/schemas/auth.py:**
```python
"""Authentication request/response schemas.

Follows FastAPI OAuth2 conventions where applicable.
"""

import re
from typing import Annotated

from pydantic import BaseModel, EmailStr, field_validator


class RegisterRequest(BaseModel):
    """Registration request schema.

    Attributes:
        email: User's email address
        password: Password (8+ chars, uppercase, lowercase, number, symbol)
        display_name: User's display name
        household_name: Optional household name
    """
    email: EmailStr
    password: str
    display_name: str
    household_name: str | None = None

    @field_validator("password")
    @classmethod
    def validate_password(cls, v: str) -> str:
        """Validate password complexity per CONTEXT.md requirements."""
        if len(v) < 8:
            raise ValueError("Password must be at least 8 characters")
        if not re.search(r"[A-Z]", v):
            raise ValueError("Password must contain an uppercase letter")
        if not re.search(r"[a-z]", v):
            raise ValueError("Password must contain a lowercase letter")
        if not re.search(r"\d", v):
            raise ValueError("Password must contain a number")
        if not re.search(r"[!@#$%^&*(),.?\":{}|<>\-_=+\[\]\\;'`~]", v):
            raise ValueError("Password must contain a symbol")
        return v

    @field_validator("display_name")
    @classmethod
    def validate_display_name(cls, v: str) -> str:
        """Validate display name is not empty."""
        v = v.strip()
        if not v:
            raise ValueError("Display name cannot be empty")
        if len(v) > 255:
            raise ValueError("Display name must be 255 characters or less")
        return v


class RegisterResponse(BaseModel):
    """Registration response schema.

    Returns 202 Accepted - user must verify email before login.
    """
    message: str = "Registration successful. Please check your email to verify your account."
    user_id: str
    email: str


class TokenResponse(BaseModel):
    """Token response schema (OAuth2 compatible).

    Access token in body, refresh token in HttpOnly cookie.
    """
    access_token: str
    token_type: str = "bearer"
    expires_in: int = 900  # 15 minutes


class RefreshRequest(BaseModel):
    """Refresh token request (token comes from cookie, not body)."""
    pass  # Token read from cookie by route


class VerifyEmailRequest(BaseModel):
    """Email verification request."""
    token: str


class VerifyEmailResponse(BaseModel):
    """Email verification response."""
    message: str = "Email verified successfully. You can now log in."
    user_id: str
    email: str


class ErrorResponse(BaseModel):
    """Standard error response."""
    detail: str
    code: str | None = None
```

Update `src/adapters/api/schemas/__init__.py` to export auth schemas.
  </action>
  <verify>
Run `python -c "from src.adapters.api.schemas.auth import RegisterRequest; r = RegisterRequest(email='test@example.com', password='Test123!@', display_name='Test'); print(r)"` to verify schema works.
  </verify>
  <done>Auth schemas with password validation, email validation via Pydantic EmailStr.</done>
</task>

<task type="auto">
  <name>Task 2: Update dependencies.py with CurrentUser and get_current_user</name>
  <files>src/adapters/api/dependencies.py</files>
  <action>
Add CurrentUser dataclass and get_current_user dependency following FastAPI OAuth2 pattern.

Add imports:
```python
from dataclasses import dataclass
from fastapi import HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from src.adapters.security.jwt import decode_access_token, TokenError
from src.domain.model.entity_id import HouseholdId
from src.application.services.auth_service import AuthService
```

Add OAuth2 scheme:
```python
# OAuth2PasswordBearer provides the "Authorize" button in Swagger
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/auth/token")
```

Add CurrentUser dataclass:
```python
@dataclass(frozen=True, slots=True)
class CurrentUser:
    """Authenticated user context for request handling.

    Injected into protected routes via Depends(get_current_user).
    Contains minimal data needed for authorization and data scoping.

    Attributes:
        user_id: User identifier
        household_id: Household identifier for data scoping
    """
    user_id: UserId
    household_id: HouseholdId
```

Add get_current_user dependency:
```python
def get_current_user(token: str = Depends(oauth2_scheme)) -> CurrentUser:
    """Extract and validate user from JWT token.

    This is THE dependency for protected routes. All routes that need
    authentication should use `current_user: CurrentUser = Depends(get_current_user)`.

    Args:
        token: JWT from Authorization header (extracted by OAuth2PasswordBearer)

    Returns:
        CurrentUser with user_id and household_id

    Raises:
        HTTPException 401 if token is invalid, expired, or missing
    """
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Not authenticated",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = decode_access_token(token)
        user_id = UserId.from_string(payload["sub"])
        household_id = HouseholdId.from_string(payload["household_id"])
        return CurrentUser(user_id=user_id, household_id=household_id)
    except (TokenError, ValueError, KeyError):
        raise credentials_exception
```

Add auth service factory:
```python
def get_auth_service(
    uow: SqlAlchemyUnitOfWork = Depends(get_unit_of_work),
) -> AuthService:
    """Provide AuthService with UnitOfWork."""
    return AuthService(uow)
```

**IMPORTANT:** Keep the old `get_current_user_id()` function for backward compatibility during this phase. It will be removed in plan 07.
  </action>
  <verify>
Run `python -c "from src.adapters.api.dependencies import CurrentUser, get_current_user, oauth2_scheme; print('Dependencies OK')"` to verify imports.
  </verify>
  <done>CurrentUser dataclass and get_current_user dependency follow FastAPI OAuth2 pattern.</done>
</task>

<task type="auto">
  <name>Task 3: Create auth routes</name>
  <files>src/adapters/api/routes/auth.py, src/adapters/api/routes/__init__.py, src/adapters/api/app.py</files>
  <action>
Create auth routes following FastAPI OAuth2 conventions.

**src/adapters/api/routes/auth.py:**
```python
"""Authentication API routes.

Endpoints:
- POST /auth/register - Register new user (returns 202, must verify email)
- POST /auth/token - Login with email/password (OAuth2 compatible)
- POST /auth/refresh - Refresh access token (token in cookie)
- GET /auth/verify - Verify email with token

Per CONTEXT.md:
- Access token returned in body
- Refresh token set as HttpOnly cookie
- All auth failures return generic "Invalid credentials" or "Not authenticated"
"""

from typing import Annotated

from fastapi import APIRouter, Cookie, Depends, HTTPException, Response, status
from fastapi.security import OAuth2PasswordRequestForm

from src.adapters.api.dependencies import get_auth_service, get_unit_of_work
from src.adapters.api.schemas.auth import (
    ErrorResponse,
    RegisterRequest,
    RegisterResponse,
    TokenResponse,
    VerifyEmailResponse,
)
from src.adapters.persistence.unit_of_work import SqlAlchemyUnitOfWork
from src.application.services.auth_service import AuthError, AuthService

router = APIRouter(prefix="/auth", tags=["authentication"])


# --- Dependencies ---

AuthServiceDep = Annotated[AuthService, Depends(get_auth_service)]


def _set_refresh_cookie(response: Response, token: str) -> None:
    """Set refresh token as HttpOnly cookie."""
    response.set_cookie(
        key="refresh_token",
        value=token,
        httponly=True,
        secure=True,  # HTTPS only (set False for local dev if needed)
        samesite="strict",
        max_age=7 * 24 * 60 * 60,  # 7 days
        path="/auth/refresh",  # Only sent to refresh endpoint
    )


def _clear_refresh_cookie(response: Response) -> None:
    """Clear refresh token cookie."""
    response.delete_cookie(
        key="refresh_token",
        path="/auth/refresh",
    )


# --- Routes ---


@router.post(
    "/register",
    response_model=RegisterResponse,
    status_code=status.HTTP_202_ACCEPTED,
    summary="Register new user",
    responses={
        202: {"description": "Registration accepted, verification email sent"},
        400: {"model": ErrorResponse, "description": "Registration failed"},
        422: {"description": "Validation error"},
    },
)
async def register(
    request: RegisterRequest,
    service: AuthServiceDep,
) -> RegisterResponse:
    """Register a new user.

    Creates user and household. Returns 202 Accepted.
    User must verify email before they can login.

    Note: Always returns 202 even if email exists (prevents email enumeration).
    """
    result = service.register(
        email=request.email,
        password=request.password,
        display_name=request.display_name,
        household_name=request.household_name,
    )

    if isinstance(result, AuthError):
        # Generic error to prevent email enumeration
        # Still returns 202 to not reveal if email exists
        # In production, you'd log the actual error
        pass  # Fall through to success response

    # Always return success-like response
    # Real verification token would be sent via email
    if isinstance(result, AuthError):
        # Return generic success (email enumeration protection)
        return RegisterResponse(
            user_id="redacted",
            email=request.email,
        )

    return RegisterResponse(
        user_id=str(result.user.id),
        email=result.user.email,
    )


@router.post(
    "/token",
    response_model=TokenResponse,
    summary="Login (OAuth2 compatible)",
    responses={
        200: {"description": "Login successful"},
        401: {"model": ErrorResponse, "description": "Invalid credentials"},
    },
)
async def login(
    response: Response,
    form_data: Annotated[OAuth2PasswordRequestForm, Depends()],
    service: AuthServiceDep,
) -> TokenResponse:
    """Authenticate user and issue tokens.

    OAuth2 compatible - accepts form data with username (email) and password.
    Returns access token in body, sets refresh token as HttpOnly cookie.
    """
    result = service.login(email=form_data.username, password=form_data.password)

    if isinstance(result, AuthError):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid credentials",  # Generic message
            headers={"WWW-Authenticate": "Bearer"},
        )

    # Set refresh token as HttpOnly cookie
    _set_refresh_cookie(response, result.refresh_token)

    return TokenResponse(
        access_token=result.access_token,
        token_type=result.token_type,
        expires_in=result.expires_in,
    )


@router.post(
    "/refresh",
    response_model=TokenResponse,
    summary="Refresh access token",
    responses={
        200: {"description": "Token refreshed"},
        401: {"model": ErrorResponse, "description": "Invalid refresh token"},
    },
)
async def refresh_token(
    response: Response,
    service: AuthServiceDep,
    refresh_token: Annotated[str | None, Cookie()] = None,
) -> TokenResponse:
    """Refresh access token using refresh token from cookie.

    Implements token rotation - old refresh token is invalidated
    and a new one is issued.
    """
    if not refresh_token:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Not authenticated",
            headers={"WWW-Authenticate": "Bearer"},
        )

    result = service.refresh(refresh_token)

    if isinstance(result, AuthError):
        _clear_refresh_cookie(response)
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Not authenticated",
            headers={"WWW-Authenticate": "Bearer"},
        )

    # Set new refresh token cookie
    _set_refresh_cookie(response, result.refresh_token)

    return TokenResponse(
        access_token=result.access_token,
        token_type=result.token_type,
        expires_in=result.expires_in,
    )


@router.get(
    "/verify",
    response_model=VerifyEmailResponse,
    summary="Verify email address",
    responses={
        200: {"description": "Email verified"},
        400: {"model": ErrorResponse, "description": "Invalid or expired token"},
    },
)
async def verify_email(
    token: str,
    service: AuthServiceDep,
) -> VerifyEmailResponse:
    """Verify user's email using verification token.

    Token is sent via email during registration.
    Valid for 24 hours.
    """
    result = service.verify_email(token)

    if isinstance(result, AuthError):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=result.message,
        )

    return VerifyEmailResponse(
        user_id=str(result.id),
        email=result.email,
    )


@router.post(
    "/logout",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Logout (clear refresh token)",
)
async def logout(response: Response) -> None:
    """Clear refresh token cookie.

    Note: Access token remains valid until expiry (15 min).
    For immediate revocation, use /auth/logout-all.
    """
    _clear_refresh_cookie(response)
```

Update `src/adapters/api/routes/__init__.py` to export auth router.

Update `src/adapters/api/app.py` to include auth router:
```python
from src.adapters.api.routes.auth import router as auth_router

# Add after existing router includes
app.include_router(auth_router)
```
  </action>
  <verify>
Start the app: `cd /workspace && uvicorn src.adapters.api.app:app --reload &`
Test registration: `curl -X POST http://localhost:8000/auth/register -H "Content-Type: application/json" -d '{"email":"test@example.com","password":"Test123!@","display_name":"Test User"}'`
Check Swagger: Open http://localhost:8000/docs and verify auth endpoints appear.
  </verify>
  <done>Auth routes implement register, login (OAuth2 compatible), refresh, verify-email, logout with HttpOnly cookie handling.</done>
</task>

</tasks>

<verification>
Auth API is complete:
1. POST /auth/register returns 202 with user_id
2. POST /auth/token accepts form data, returns access_token, sets cookie
3. POST /auth/refresh reads cookie, rotates tokens
4. GET /auth/verify validates token and marks email verified
5. Swagger docs show auth endpoints with "Authorize" button
6. `make lint` passes
</verification>

<success_criteria>
- RegisterRequest validates password complexity
- POST /auth/register returns 202 (even on duplicate email - enumeration protection)
- POST /auth/token is OAuth2 compatible (form data with username/password)
- Refresh token set as HttpOnly cookie with path="/auth/refresh"
- get_current_user dependency extracts user from JWT
- All auth errors return generic messages (no email enumeration)
</success_criteria>

<output>
After completion, create `.planning/phases/04-authentication-infrastructure/04-06-SUMMARY.md`
</output>
